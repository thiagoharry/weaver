\catcode`@=11
\font\tenit@=cmti10 % text italic
\font\tennegit@=cmbxti10 % Negrito e itálico
\font\tennegsl@=cmbxsl10 % Negrito e inclinado
\font\tensl@=cmsl10 % slanted roman
\font\tenrm@=cmr10 % roman text
\font\tenbf@=cmbx10 % boldface extended
\font\tentt@=cmtt10 % typewriter
\font\tennegtt@=cmbtt10 % Negrito monoespaço?
\font\teni@=cmmi10 % math italic
\font\tensy@=cmsy10 % math symbols
\font\tenex@=cmex10 % math extension
\font\sevenrm@=cmr7 % Usado em subscritos e sobrescritos
\font\fiverm@=cmr5 % Usado em subsubscritos e sobresobrescritos
\font\seveni@=cmmi7 % Sobrescritos e subscritos matemáticos
\font\fivei@=cmmi5 % Subsubscritos itálicos
\font\sevensy@=cmsy7 % Símbolos subscritos
\font\fivesy@=cmsy5 % Símbolos subsubscritos
\font\sevenbf@=cmbx7 % Subscritos negritos
\font\fivebf@=cmbx5 % Subsubscritos negritos
\dimendef\epsfrsize@=20
\dimendef\pspoints@=21
\dimendef\epsftsize@=22
\dimendef\epsfxsize@=23    % horizontal size after scaling
\dimendef\epsfysize@=24    % vertical size after scaling
\dimendef\epsftmp@=25
\def\loop@#1\repeat@{\def\body{#1}\iterate@}
\def\iterate@{\body \let\next\iterate@ \else\let\next\relax\fi \next}
\let\repeat@=\fi % this makes \loop...\if...\repeat skippable
\outer\def\newif@#1{\count@\escapechar \escapechar-1
  \expandafter\expandafter\expandafter
   \def\@if#1{true}{\let#1=\iftrue}%
  \expandafter\expandafter\expandafter
   \def\@if#1{false}{\let#1=\iffalse}%
  \@if#1{false}\escapechar\count@} % the condition starts out false
\def\@if#1#2{\csname\expandafter\if@\string#1#2\endcsname}
{\uccode`1=`i \uccode`2=`f \uppercase{\gdef\if@12{}}}
\input tex/epsf.tex
\def\espaco#1{{\dimen0=#1\divide\dimen0 by 3\ifvmode\vskip#1
          plus\dimen0 minus\dimen0\else\hskip#1 plus\dimen0
minus\dimen0\relax\fi}}
\def\linha{{\hrule\vskip1pt}}
\def\imagem#1{\epsfbox@{#1}}
\def\\{\char"5C}
\def\fim{\par\vfill\par\penalty-20000\end}
% Suporte a texto colorido:
\def\usoucor@{0}
\def\cor#1#2{\if\usoucor@0\special{color push rgb 0 0 0}\fi%
           \gdef\usoucor@{1}%w
           \special{color push rgb #1}#2\special{color pop}}
% Texto colorido em caixa colorida:
\def\caixacor#1#2#3{%
        \if\usoucor@0\special{color push rgb 0 0 0}\fi%
        \gdef\usoucor@{1}%
        {\setbox0=\hbox{#3}\skip0=\ht0%
        \advance\skip0 by 0.5ex%
        \hbox{\cor{#1}{\vrule height \skip0 width \wd0 depth \dp0}%
\hskip-\wd0\box0}}}

{\catcode`\^^M=13 %
  \gdef\obeylines@{\parfillskip=0pt\catcode`\^^M13 \gdef^^M{\hbox{}\par}}%
  \global\let^^M\par} % Se ^^M aparecer em um \write
% E para cancelarmos o \obeylines usamos:
\def\dontobeylines@{\tenrm@\parfillskip=0pt plus 1fil\catcode`\^^M=5\everypar{}}
% Obedece espaços:
\def\obeyspaces@{\catcode`\ 13}
{\catcode`&=11\gdef\sh&{}
        \gdef\space@{\hskip1.21ex\sh&}
        \catcode`&=4}
{\obeyspaces@\global\let =\space@}
% Comandos de justificação e texto:
\def\alinhaesquerda{\tenrm@\dontobeylines@\rightskip 0em plus 2em
     \leftskip 0pt \spaceskip.3333em\xspaceskip.5em\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
     \catcode`\ =10}
\def\alinhaversoesquerdo{\tenrm@\obeylines@\rightskip0pt plus 1fil\leftskip0pt%
     \xspaceskip0pt\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
     \catcode`\ =10}
\def\alinhadireita{\tenrm@\dontobeylines@\leftskip 0em plus 2em \rightskip0pt
     \spaceskip.3333em\xspaceskip.5em\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
     \catcode`\ =10}
\def\alinhaversodireito{\tenrm@\obeylines@\rightskip0pt\leftskip0pt plus 1fil%
     \xspaceskip0pt\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
     \catcode`\ =10}
\def\alinhacentro{\tenrm@\dontobeylines@\rightskip 0em plus 2em \leftskip 0em plus 2em%
                  \spaceskip.3333em \xspaceskip.5em\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
     \catcode`\ =10}
\def\alinhaversocentro{\tenrm@\obeylines@\rightskip0pt plus 1fil%
       \leftskip0pt plus 1 fil\xspaceskip0pt\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
\catcode`\ =10}
\def\alinhaverbatim{\alinhaversoesquerdo\parindent=0pt\tentt@
     \sfcode`\.0 \sfcode`\?0 \sfcode`\!0 \sfcode`\:0 \sfcode`\;0
     \sfcode`\,0
     \catcode`\{=12\catcode`\}=12\catcode`\$=12\catcode`\&=12\catcode`\#=12
     \catcode`\^=12\catcode`\_=12\catcode`\^^I=12\catcode`\~=12\catcode`\%=12
     \obeyspaces@\obeylines@}
\def\alinhanormal{\tenrm@\dontobeylines@\leftskip0pt\rightskip0pt\spaceskip0pt%
                  \xspaceskip0pt\parindent=20pt
     \sfcode`\.3000 \sfcode`\?3000 \sfcode`\!3000 \sfcode`\:2000 \sfcode`\;1500
     \sfcode`\,1250
     \catcode`\{=1\catcode`\}=2\catcode`\$=3\catcode`\&=4\catcode`\#=6
     \catcode`\^=7\catcode`\_=8\catcode`\^^I=10\catcode`\~=13\catcode`\%=14
\catcode`\ =10}
\catcode`@=12
\catcode`&=11
\catcode`@=0
\catcode`|=13 % Para inserir porções de código em texto


\countdef\parte&=50 \parte&=0
\countdef\capitulo&=51 \capitulo&=0
\countdef\secao&=52 \secao&=0
\countdef\subsecao&=53 \subsecao&=0
\countdef\ss&=54 \ss&=0
\countdef\sss&=55 \sss&=0
\countdef\ssss&=56 \ssss&=0
\countdef\sssss&=57 \sssss&=0
\countdef\ssssss&=58 \ssssss&=0
\countdef\sssssss&=59 \sssssss&=0
\countdef\ssssssss&=60 \ssssssss&=0
\countdef\aux&=61 \aux&=0

% Fontes
\font\twentyone&=cmr17 scaled 1200  % Para @**
\font\twentyonett&=cmtt12 scaled 1700

\font\twenty&=cmr17 scaled 1176     % Para @  e @*0
\font\twentytt&=cmtt12 scaled 1666

\font\nineteen&=cmr17 scaled 1118   % Para @*1
\font\nineteentt&=cmtt12 scaled 1583

\font\eighteen&=cmr17 scaled 1059   % Para @*2
\font\eighteentt&=cmtt12 scaled 1500

\font\seventeen&=cmr17              % Para @*3
\font\seventeentt&=cmtt12 scaled 1417

\font\sixteen&=cmr17 scaled 941     % Para @*4
\font\sixteentt&=cmtt12 scaled 1333

\font\fifteen&=cmr12 scaled 1250   % Para @*5
\font\fifteentt&=cmtt12 scaled 1250

\font\fourteen&=cmr12 scaled 1167  % Para @*6
\font\fourteentt&=cmtt12 scaled 1167

\font\thirteen&=cmr12 scaled 1083  % Para @*7
\font\thirteentt&=cmtt12 scaled 1083

\font\twelve&=cmr12              % Para @*8
\font\twelvett&=cmtt12

\font\eleven&=cmr12 scaled 917     % Para @*9
\font\eleventt&=cmtt12 scaled 917

\font\tenrm&=cmr10                  % Para voltar ao normal.

\font\tenbf&=cmbx10 % boldface extended
\font\tentt&=cmtt10 % typewriter

% Definições
\gdef\.{.} % O . é redefinido como comando em alguns contextos. Pode
           % ser útil então poder usar \. para inserir um ponto.

% Redefinindo o alinha verbatim para podermos usar os caracteres
% especiais como '|' dentro dele:
\let\alinhaverbatim&\alinhaverbatim
\let\alinhanormal&\alinhanormal

\gdef\alinhaverbatim{\alinhaverbatim&\catcode`|=12}
\gdef\alinhanormal{\alinhanormal&\catcode`|=13}

\gdef|{\gdef|{\fimsh&@alinhanormal&@catcode`\\=0@gdef@cm&{0}@gdef@c&{0} }%
       \ifvmode\indent\fi\alinhaverbatim&\gdef\c&{1}\catcode`\\=12@gdef@cm&{1}%
       \iniciosh&}
\gdef\naparte&{0} % Estamos formatando o título de uma parte?
\gdef\big&{0}     % Estamos formatando o título de um capítulo ou seção?
\gdef\c&{0}       % Estamos formatando código C?
\gdef\cm&{0}      % Estamos em códig C inline?
{\catcode`.=13\gdef.{\if\naparte&1%
                       \vskip5mm%
                     \else%
                       \if\big&1%
                         \vskip5mm%
                       \else%
                         \if\c&1%
                           \char"2E%
                         \else%
                            \vskip3mm%
                         \fi%
                       \fi%
                     \fi\if\c& 1\tentt&\else\tenrm&\fi%
                     \if\c&0%
                       \let\monoespaco=\monoespaco&%
                       \catcode`.=12\par\alinhanormal&%
                     \fi\if\naparte&1\vfill\quebra\fi%
        \if\c&0\gdef\naparte&{0}\gdef\big&{0}\fi\sh&}}
\let\monoespaco&=\monoespaco
\def@*#1{\fimcodigo&\catcode`.=13
        \if#1*\quebra\ \vfill\rightskip 0em plus 1fil \leftskip 0em plus 2fil
              \twentyone&\advance\parte& by 1  % @**
              \def\monoespaco##1{{\twentyonett& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0\ss&=0%
              \subsecao&=0\secao&=0%
              \gdef\naparte&{1}\noindent Parte \the\parte&:\else
        \if#10\vfil\quebra\twenty&\vskip5mm\advance\capitulo& by 1 % @*0
             \def\monoespaco##1{{\twentytt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0\ss&=0%
              \global\subsecao&=0\global\secao&=0%
             \vfill\rightskip 0em plus 1fil \leftskip 0em plus 2fil
             \gdef\big&{1}\noindent Capítulo \the\capitulo&:\else
         \if#11\nineteen&\vskip5mm\advance\secao& by 1 % @*1
              \def\monoespaco##1{{\nineteentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0\ss&=0%
              \subsecao&=0%
              \gdef\big&{1}\noindent\the\capitulo&.\the\secao&\ - \else
         \if#12\eighteen&\vskip3mm\advance\subsecao& by 1 % @*2
              \def\monoespaco##1{{\eighteentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0\ss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&-\else
         \if#13\seventeen&\vskip3mm\advance\ss& by 1 % @*3
              \def\monoespaco##1{{\seventeentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&-\else
         \if#14\sixteen&\vskip3mm\advance\sss& by 1 % @*4
              \def\monoespaco##1{{\sixteentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&-\else
         \if#15\fifteen&\vskip3mm\advance\ssss& by 1 % @*5
              \def\monoespaco##1{{\fifteentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&.\the\ssss&-\else
         \if#16\fourteen&\vskip3mm\advance\sssss& by 1 % @*6
              \def\monoespaco##1{{\fourteentt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&.\the\ssss&.\the\sssss&-\else
         \if#17\thirteen&\vskip3mm\advance\ssssss& by 1 % @*7
              \def\monoespaco##1{{\thirteentt& ##1}}%
              \ssssssss&=0\sssssss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&.\the\ssss&.\the\sssss&.\the\ssssss&-\else
         \if#18\twelve&\vskip3mm\advance\sssssss& by 1 % @*8
              \def\monoespaco##1{{\twelvett& ##1}}%
              \ssssssss&=0%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&.\the\ssss&.\the\sssss&.\the\ssssss&.\the\sssssss&-\else
         \if#19\eleven&\vskip3mm\advance\ssssssss& by 1 % @*9
              \def\monoespaco##1{{\eleventt& ##1}}%
               \noindent\the\capitulo&.\the\secao&.\the\subsecao&.\the\ss&.%
               \the\sss&.\the\ssss&.\the\sssss&.\the\ssssss&.\the\sssssss&.%
               \the\ssssssss&-\else
\vfil\quebra\twenty&\vskip5mm\advance\capitulo& by 1 % @*0
             \def\monoespaco##1{{\twentytt& ##1}}%
              \ssssssss&=0\sssssss&=0\ssssss&=0\sssss&=0\ssss&=0\sss&=0\ss&=0%
              \global\subsecao&=0\global\secao&=0%
             \vfill\rightskip 0em plus 1fil \leftskip 0em plus 2fil
             \gdef\big&{1}\noindent Capítulo \the\capitulo&: #1%
             \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}

\def\chomp&#1{\relax}
\gdef\<#1@>#2{%
  \linha\espaco{1mm}\noindent\negrito{Seção: #1%
  \if#2+
    (continuação)%
  \fi:}%
  \alinhacodigo\vskip1mm\chomp&}
\def@({@global@catcode`_=11\linha\espaco{1mm}\noindent\negrito{Arquivo:} \apar&}
\def\apar&#1@>#2{%
  \monoespaco{#1}%
  \if#2+
    \negrito{(continuação)}%
  \fi\negrito{:}%
  \alinhacodigo\vskip1mm\chomp&}

% Esta macro é usada em todos os comandos conhecidos por encerrarem
% código C:
\def\fimcodigo&{@fimsh&@if@c&1@catcode`\\=0@alinhanormal&@linha@vskip1mm%
        @gdef@c&{0}@fi}

\gdef\space&{\hskip 0.5em\sh&}
% Cor especial para macros:

@gdef@macro&{0}
% Preparando cor especial para strings:
@gdef@string&{0}
@gdef@comentario&{0}
@gdef@insercao&{0}
{\catcode`"=13@gdef"{%
  @if@comentario&0%
    @if@string&0%
      @gdef@string&{1}@special{color push rgb 0.2 0.8 0.2}@char'42%
    @else%
      @gdef@string&{0}@char'42@special{color pop}%
    @fi%
  @else%
    @char'42%
  @fi}}
{\catcode`(=13@gdef({@char'50@sh&}}
{\catcode`:=13@gdef:{@char'72@sh&}}
% Ativa syntax hightlight:
\def\iniciosh&{%
@everypar{%
  @if@comentario& 1%
    @gdef@comentario&{0}@special{color pop}%
  @fi%
  @if@cm&0@hbox{@cor{0.92 0.92 0.92}{@vrule height 2ex width @hsize depth @maxdepth}}%
  @hskip-@hsize@fi@tentt&@sh&%
  }%
  @if@cm& 0%
    @catcode`|=11%
  @fi%
@catcode`_=11@catcode`0=11@catcode`1=11%
@catcode`2=11@catcode`3=11@catcode`4=11@catcode`5=11@catcode`6=11%
@catcode`7=11@catcode`8=11@catcode`9=11@catcode`"=13@catcode`(=13%
@catcode`:=13@catcode`.=13%
@gdef@<{@hskip0ptplus1fil@relax@negrito{$<$Seção a ser Inserida:} %
        @special{color push rgb 1 0 0}@tenbf&@gdef@insercao&{1}}%
@gdef@>{@special{color pop}$>$@gdef@insercao&{0}@tentt&@relax}%
@gdef@ {@fimcodigo&@space&}
@gdef@sh&##1{%
  @if@macro& 1@special{color pop}@gdef@macro&{0}@fi%
  @if@string& 0%
    @if@comentario& 2%
      @if##1*%
        @let@prox&@terminacomentario&%
      @else%
        @let@prox&@relax%
      @fi%
    @else%
      @if@comentario& 1%
        @let@prox&@relax%
      @else%
        @if@insercao& 1%
          @let@prox&@relax%
        @else%
          @ifcat##1a%
            @let@prox&@letra&%
          @else%
            @if##1/%
              @let@prox&@lecomentario&%
            @else%
              @if##1####%
                @gdef@macro&{1}@special{color push rgb 0 0 0.5}@let@prox&@relax%
              @else%
                @let@prox&@relax%
              @fi%
            @fi%
          @fi%
        @fi%
      @fi%
    @fi%
  @else%
    @let@prox&@relax%
  @fi@prox&##1}%
@gdef@letra&##1{% Invocada quando temos a 1a letra de palavra
  @if##1i%
    @let@next&@letrai&%
  @else%
    @if##1a%
      @let@next&@letraa&%
    @else%
      @if##1b%
        @let@next&@letrab&%
      @else%
        @if##1c%
          @let@next&@letrac&%
        @else%
          @if##1d%
            @let@next&@letrad&%
          @else%
            @if##1e%
              @let@next&@letrae&%
            @else%
              @if##1f%
                @let@next&@letraf&%
              @else%
                @if##1g%
                  @let@next&@letrag&%
                @else%
                  @if##1l%
                    @let@next&@letral&%
                  @else%
                    @if##1r%
                      @let@next&@letrar&%
                    @else%
                      @if##1s%
                        @let@next&@letras&%
                      @else%
                        @if##1t%
                          @let@next&@letrat&%
                        @else%
                          @if##1u%
                            @let@next&@letrau&%
                          @else%
                            @if##1v%
                              @let@next&@letrav&%
                            @else%
                              @if##1w%
                                @let@next&@letraw&%
                              @else%
                                ##1@let@next&@relax%
                              @fi%
                            @fi%
                          @fi%
                        @fi%
                      @fi
                    @fi
                  @fi%
                @fi%
              @fi%
            @fi%
          @fi%
        @fi%
      @fi%
    @fi%
  @fi@next&}%
@gdef@terminacomentario&##1##2{%
  @if##2/%
    */@gdef@comentario&{0}@special{color pop}%
  @else%
    *@expandafter##2%
  @fi%
}%
@gdef@lecomentario&##1##2{%
  @if##2/%
    @gdef@comentario&{1}@special{color push rgb 0.5 0.5 0.5}//%
  @else%
    @if##2*%
      @gdef@comentario&{2}@special{color push rgb 0.5 0.5 0.5}/*%
    @else%
      /@expandafter@expandafter@expandafter##2%
    @fi
  @fi%
}%
@gdef@letrag&##1{% Temos 'g'
  @ifcat##1a%
    @letraG&##1%
  @else%
    g@expandafter##1%    
  @fi%
}%
@gdef@letraG&##1{% Temos 'g'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letrago&%
  @else%
    g##1%
  @fi%
}%
@gdef@letraw&##1{% Temos 'w'
  @ifcat##1a%
    @letraW&##1%
  @else%
    w@expandafter##1%    
  @fi%
}%
@gdef@letraW&##1{% Temos 'w'+letra
  @if##1h%
    @expandafter@expandafter@expandafter@letrawh&%
  @else%
    w##1%
  @fi%
}%
@gdef@letrawh&##1{% Temos 'wh'
  @ifcat##1a%
    @letraWH&##1%
  @else%
    wh@expandafter##1%    
  @fi%
}%
@gdef@letraWH&##1{% Temos 'wh'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letrawhi&%
  @else%
    wh##1%
  @fi%
}%
@gdef@letrawhi&##1{% Temos 'whi'
  @ifcat##1a%
    @letraWHI&##1%
  @else%
    whi@expandafter##1%    
  @fi%
}%
@gdef@letraWHI&##1{% Temos 'whi'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letrawhil&%
  @else%
    whi##1%
  @fi%
}%
@gdef@letrawhil&##1{% Temos 'whil'
  @ifcat##1a%
    @letraWHIL&##1%
  @else%
    whil@expandafter##1%    
  @fi%
}%
@gdef@letraWHIL&##1{% Temos 'whil'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrawhile&%
  @else%
    whil##1%
  @fi%
}%
@gdef@letrawhile&##1{% Temos 'while'
  @ifcat##1a%
    while##1%
  @else%
    @cor{0 0.5 0.5}{while}@expandafter##1%    
  @fi%
}%
@gdef@letrav&##1{% Temos 'v'
  @ifcat##1a%
    @letraV&##1%
  @else%
    v@expandafter##1%    
  @fi%
}%
@gdef@letraV&##1{% Temos 'v'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letravo&%
  @else%
    v##1%
  @fi%
}%
@gdef@letravo&##1{% Temos 'vo'
  @ifcat##1a%
    @letraVO&##1%
  @else%
    vo@expandafter##1%    
  @fi%
}%
@gdef@letraVO&##1{% Temos 'vo'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letravoi&%
  @else%
    @if##1l%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letravol&%
    @else%
      vo##1%
    @fi%
  @fi%
}%
@gdef@letravol&##1{% Temos 'vol'
  @ifcat##1a%
    @letraVOL&##1%
  @else%
    vol@expandafter##1%    
  @fi%
}%
@gdef@letraVOL&##1{% Temos 'vol'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letravola&%
  @else%
    vol##1%
  @fi%
}%
@gdef@letravola&##1{% Temos 'vola'
  @ifcat##1a%
    @letraVOLA&##1%
  @else%
    vola@expandafter##1%    
  @fi%
}%
@gdef@letraVOLA&##1{% Temos 'vola'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letravolat&%
  @else%
    vola##1%
  @fi%
}%
@gdef@letravolat&##1{% Temos 'volat'
  @ifcat##1a%
    @letraVOLAT&##1%
  @else%
    volat@expandafter##1%    
  @fi%
}%
@gdef@letraVOLAT&##1{% Temos 'volat'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letravolati&%
  @else%
    volat##1%
  @fi%
}%
@gdef@letravolati&##1{% Temos 'volati'
  @ifcat##1a%
    @letraVOLATI&##1%
  @else%
    volati@expandafter##1%    
  @fi%
}%
@gdef@letraVOLATI&##1{% Temos 'volati'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letravolatil&%
  @else%
    volati##1%
  @fi%
}%
@gdef@letravolatil&##1{% Temos 'volatil'
  @ifcat##1a%
    @letraVOLATIL&##1%
  @else%
    volatil@expandafter##1%    
  @fi%
}%
@gdef@letraVOLATIL&##1{% Temos 'volatil'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letravolatile&%
  @else%
    volatil##1%
  @fi%
}%
@gdef@letravolatile&##1{% Temos 'volatile'
  @ifcat##1a%
    volatile##1%
  @else%
    @cor{0 0.5 0.5}{volatile}@expandafter##1%    
  @fi%
}%
@gdef@letravoi&##1{% Temos 'voi'
  @ifcat##1a%
    @letraVOI&##1%
  @else%
    voi@expandafter##1%    
  @fi%
}%
@gdef@letraVOI&##1{% Temos 'voi'+letra
  @if##1d%
    @expandafter@expandafter@expandafter@letravoid&%
  @else%
    voi##1%
  @fi%
}%
@gdef@letravoid&##1{% Temos 'void'
  @ifcat##1a%
    void##1%
  @else%
    @cor{0 0.5 0}{void}@expandafter##1%    
  @fi%
}%
@gdef@letrau&##1{% Temos 'u'
  @ifcat##1a%
    @letraU&##1%
  @else%
    u@expandafter##1%    
  @fi%
}%
@gdef@letraU&##1{% Temos 'u'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letraun&%
  @else%
    u##1%
  @fi%
}%
@gdef@letraun&##1{% Temos 'un'
  @ifcat##1a%
    @letraUN&##1%
  @else%
    un@expandafter##1%    
  @fi%
}%
@gdef@letraUN&##1{% Temos 'un'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letrauni&%
  @else%
    @if##1s%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrauns&%
    @else%
      un##1%
    @fi%
  @fi%
}%
@gdef@letrauni&##1{% Temos 'uni'
  @ifcat##1a%
    @letraUNI&##1%
  @else%
    uni@expandafter##1%    
  @fi%
}%
@gdef@letraUNI&##1{% Temos 'uni'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letraunio&%
  @else%
    uni##1%
  @fi%
}%
@gdef@letrauns&##1{% Temos 'uns'
  @ifcat##1a%
    @letraUNS&##1%
  @else%
    uns@expandafter##1%    
  @fi%
}%
@gdef@letraUNS&##1{% Temos 'uns'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letraunsi&%
  @else%
    uns##1%
  @fi%
}%
@gdef@letraunsi&##1{% Temos 'unsi'
  @ifcat##1a%
    @letraUNSI&##1%
  @else%
    unsi@expandafter##1%    
  @fi%
}%
@gdef@letraUNSI&##1{% Temos 'unsi'+letra
  @if##1g%
    @expandafter@expandafter@expandafter@letraunsig&%
  @else%
    unsi##1%
  @fi%
}%
@gdef@letraunsig&##1{% Temos 'unsig'
  @ifcat##1a%
    @letraUNSIG&##1%
  @else%
    unsig@expandafter##1%    
  @fi%
}%
@gdef@letraUNSIG&##1{% Temos 'unsig'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letraunsign&%
  @else%
    unsig##1%
  @fi%
}%
@gdef@letraunsign&##1{% Temos 'unsign'
  @ifcat##1a%
    @letraUNSIGN&##1%
  @else%
    unsign@expandafter##1%    
  @fi%
}%
@gdef@letraUNSIGN&##1{% Temos 'unsign'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letraunsigne&%
  @else%
    unsign##1%
  @fi%
}%
@gdef@letraunsigne&##1{% Temos 'unsigne'
  @ifcat##1a%
    @letraUNSIGNE&##1%
  @else%
    unsigne@expandafter##1%    
  @fi%
}%
@gdef@letraUNSIGNE&##1{% Temos 'unsigne'+letra
  @if##1d%
    @expandafter@expandafter@expandafter@letraunsigned&%
  @else%
    unsigne##1%
  @fi%
}%
@gdef@letraunsigned&##1{% Temos 'unsigned'
  @ifcat##1a%
    unsigned##1%
  @else%
    @cor{0 0.5 0}{unsigned}@expandafter##1%    
  @fi%
}%
@gdef@letraunio&##1{% Temos 'unio'
  @ifcat##1a%
    @letraUNIO&##1%
  @else%
    unio@expandafter##1%    
  @fi%
}%
@gdef@letraUNIO&##1{% Temos 'unio'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letraunion&%
  @else%
    unio##1%
  @fi%
}%
@gdef@letraunion&##1{% Temos 'union'
  @ifcat##1a%
    union##1%
  @else%
    @cor{0 0.5 0}{union}@expandafter##1%    
  @fi%
}%
@gdef@letrat&##1{% Temos 't'
  @ifcat##1a%
    @letraT&##1%
  @else%
    t@expandafter##1%    
  @fi%
}%
@gdef@letraT&##1{% Temos 't'+letra
  @if##1y%
    @expandafter@expandafter@expandafter@letraty&%
  @else%
    t##1%
  @fi%
}%
@gdef@letraty&##1{% Temos 'ty'
  @ifcat##1a%
    @letraTY&##1%
  @else%
    ty@expandafter##1%    
  @fi%
}%
@gdef@letraTY&##1{% Temos 'ty'+letra
  @if##1p%
    @expandafter@expandafter@expandafter@letratyp&%
  @else%
    ty##1%
  @fi%
}%
@gdef@letratyp&##1{% Temos 'typ'
  @ifcat##1a%
    @letraTYP&##1%
  @else%
    typ@expandafter##1%    
  @fi%
}%
@gdef@letraTYP&##1{% Temos 'typ'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letratype&%
  @else%
    typ##1%
  @fi%
}%
@gdef@letratype&##1{% Temos 'type'
  @ifcat##1a%
    @letraTYPE&##1%
  @else%
    type@expandafter##1%    
  @fi%
}%
@gdef@letraTYPE&##1{% Temos 'type'+letra
  @if##1d%
    @expandafter@expandafter@expandafter@letratyped&%
  @else%
    type##1%
  @fi%
}%
@gdef@letratyped&##1{% Temos 'typed'
  @ifcat##1a%
    @letraTYPED&##1%
  @else%
    typed@expandafter##1%    
  @fi%
}%
@gdef@letraTYPED&##1{% Temos 'typed'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letratypede&%
  @else%
    typed##1%
  @fi%
}%
@gdef@letratypede&##1{% Temos 'typede'
  @ifcat##1a%
    @letraTYPEDE&##1%
  @else%
    typede@expandafter##1%    
  @fi%
}%
@gdef@letraTYPEDE&##1{% Temos 'typede'+letra
  @if##1f%
    @expandafter@expandafter@expandafter@letratypedef&%
  @else%
    typede##1%
  @fi%
}%
@gdef@letratypedef&##1{% Temos 'typedef'
  @ifcat##1a%
    typedef##1%
  @else%
    @cor{0 0.5 0.5}{typedef}@expandafter##1%    
  @fi%
}%
@gdef@letras&##1{% Temos 's'
  @ifcat##1a%
    @letraS&##1%
  @else%
    s@expandafter##1%    
  @fi%
}%
@gdef@letraS&##1{% Temos 's'+letra
  @if##1h%
    @expandafter@expandafter@expandafter@letrash&%
  @else%
    @if##1i%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrasi&%
    @else%
      @if##1t%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@letrast&%
      @else%
        @if##1w%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@expandafter@expandafter@expandafter@expandafter%
          @expandafter@letrasw&%
        @else%
          s##1%
        @fi
      @fi%
    @fi%
  @fi%
}%
@gdef@letrasw&##1{% Temos 'sw'
  @ifcat##1a%
    @letraSW&##1%
  @else%
    sw@expandafter##1%    
  @fi%
}%
@gdef@letraSW&##1{% Temos 'sw'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letraswi&%
  @else%
    sw##1%
  @fi%
}%
@gdef@letraswi&##1{% Temos 'swi'
  @ifcat##1a%
    @letraSWI&##1%
  @else%
    swi@expandafter##1%    
  @fi%
}%
@gdef@letraSWI&##1{% Temos 'sw'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraswit&%
  @else%
    swi##1%
  @fi%
}%
@gdef@letraswit&##1{% Temos 'swit'
  @ifcat##1a%
    @letraSWIT&##1%
  @else%
    swit@expandafter##1%    
  @fi%
}%
@gdef@letraSWIT&##1{% Temos 'sw'+letra
  @if##1c%
    @expandafter@expandafter@expandafter@letraswitc&%
  @else%
    swit##1%
  @fi%
}%
@gdef@letraswitc&##1{% Temos 'switc'
  @ifcat##1a%
    @letraSWITC&##1%
  @else%
    switc@expandafter##1%    
  @fi%
}%
@gdef@letraSWITC&##1{% Temos 'sw'+letra
  @if##1h%
    @expandafter@expandafter@expandafter@letraswitch&%
  @else%
    switc##1%
  @fi%
}%
@gdef@letraswitch&##1{% Temos 'switch'
  @ifcat##1a%
    switch##1%
  @else%
    @cor{0 0.5 0.5}{switch}@expandafter##1%    
  @fi%
}%
@gdef@letrast&##1{% Temos 'st'
  @ifcat##1a%
    @letraST&##1%
  @else%
    st@expandafter##1%    
  @fi%
}%
@gdef@letraST&##1{% Temos 'st'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letrasta&%
  @else%
    @if##1r%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrastr&%
    @else%
      st##1%
    @fi%
  @fi%
}%
@gdef@letrastr&##1{% Temos 'str'
  @ifcat##1a%
    @letraSTR&##1%
  @else%
    str@expandafter##1%    
  @fi%
}%
@gdef@letraSTR&##1{% Temos 'str'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letrastru&%
  @else%
    str##1%
  @fi%
}%
@gdef@letrastru&##1{% Temos 'stru'
  @ifcat##1a%
    @letraSTRU&##1%
  @else%
    stru@expandafter##1%    
  @fi%
}%
@gdef@letraSTRU&##1{% Temos 'stru'+letra
  @if##1c%
    @expandafter@expandafter@expandafter@letrastruc&%
  @else%
    stru##1%
  @fi%
}%
@gdef@letrastruc&##1{% Temos 'struc'
  @ifcat##1a%
    @letraSTRUC&##1%
  @else%
    struc@expandafter##1%    
  @fi%
}%
@gdef@letraSTRUC&##1{% Temos 'struc'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrastruct&%
  @else%
    struc##1%
  @fi%
}%
@gdef@letrastruct&##1{% Temos 'struct'
  @ifcat##1a%
    struct##1%
  @else%
    @cor{0 0.5 0}{struct}@expandafter##1%    
  @fi%
}%
@gdef@letrasta&##1{% Temos 'sta'
  @ifcat##1a%
    @letraSTA&##1%
  @else%
    sta@expandafter##1%    
  @fi%
}%
@gdef@letraSTA&##1{% Temos 'sta'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrastat&%
  @else%
    sta##1%
  @fi%
}%
@gdef@letrastat&##1{% Temos 'stat'
  @ifcat##1a%
    @letraSTAT&##1%
  @else%
    stat@expandafter##1%    
  @fi%
}%
@gdef@letraSTAT&##1{% Temos 'stat'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letrastati&%
  @else%
    stat##1%
  @fi%
}%
@gdef@letrastati&##1{% Temos 'stati'
  @ifcat##1a%
    @letraSTATI&##1%
  @else%
    stati@expandafter##1%    
  @fi%
}%
@gdef@letraSTATI&##1{% Temos 'stati'+letra
  @if##1c%
    @expandafter@expandafter@expandafter@letrastatic&%
  @else%
    stati##1%
  @fi%
}%
@gdef@letrastatic&##1{% Temos 'static'
  @ifcat##1a%
    static##1%
  @else%
    @cor{0 0.5 0.5}{static}@expandafter##1%    
  @fi%
}%
@gdef@letrasi&##1{% Temos 'si'
  @ifcat##1a%
    @letraSI&##1%
  @else%
    si@expandafter##1%    
  @fi%
}%
@gdef@letraSI&##1{% Temos 'si'+letra
  @if##1g%
    @expandafter@expandafter@expandafter@letrasig&%
  @else%
    @if##1z%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrasiz&%
    @else%
      si##1%
    @fi%
  @fi%
}%
@gdef@letrasiz&##1{% Temos 'siz'
  @ifcat##1a%
    @letraSIZ&##1%
  @else%
    siz@expandafter##1%    
  @fi%
}%
@gdef@letraSIZ&##1{% Temos 'siz'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrasize&%
  @else%
    siz##1%
  @fi%
}%
@gdef@letrasize&##1{% Temos 'size'
  @ifcat##1a%
    @letraSIZE&##1%
  @else%
    size@expandafter##1%    
  @fi%
}%
@gdef@letraSIZE&##1{% Temos 'size'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letrasizeo&%
  @else%
    size##1%
  @fi%
}%
@gdef@letrasizeo&##1{% Temos 'sizeo'
  @ifcat##1a%
    @letraSIZEO&##1%
  @else%
    sizeo@expandafter##1%    
  @fi%
}%
@gdef@letraSIZEO&##1{% Temos 'sizeo'+letra
  @if##1f%
    @expandafter@expandafter@expandafter@letrasizeof&%
  @else%
    sizeo##1%
  @fi%
}%
@gdef@letrasizeof&##1{% Temos 'sizeof'
  @ifcat##1a%
    sizeof##1%
  @else%
    @cor{0 0.5 0.5}{sizeof}@expandafter##1%    
  @fi%
}%
@gdef@letrasig&##1{% Temos 'sig'
  @ifcat##1a%
    @letraSIG&##1%
  @else%
    sig@expandafter##1%    
  @fi%
}%
@gdef@letraSIG&##1{% Temos 'sig'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letrasign&%
  @else%
    sig##1%
  @fi%
}%
@gdef@letrasign&##1{% Temos 'sign'
  @ifcat##1a%
    @letraSIGN&##1%
  @else%
    sign@expandafter##1%    
  @fi%
}%
@gdef@letraSIGN&##1{% Temos 'sign'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrasigne&%
  @else%
    sign##1%
  @fi%
}%
@gdef@letrasigne&##1{% Temos 'signe'
  @ifcat##1a%
    @letraSIGNE&##1%
  @else%
    signe@expandafter##1%    
  @fi%
}%
@gdef@letraSIGNE&##1{% Temos 'signe'+letra
  @if##1d%
    @expandafter@expandafter@expandafter@letrasigned&%
  @else%
    signe##1%
  @fi%
}%
@gdef@letrasigned&##1{% Temos 'signed'
  @ifcat##1a%
    signed##1%
  @else%
    @cor{0 0.5 0}{signed}@expandafter##1%    
  @fi%
}%
@gdef@letrash&##1{% Temos 'sh'
  @ifcat##1a%
    @letraSH&##1%
  @else%
    sh@expandafter##1%    
  @fi%
}%
@gdef@letraSH&##1{% Temos 'sh'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letrasho&%
  @else%
    sh##1%
  @fi%
}%
@gdef@letrasho&##1{% Temos 'sho'
  @ifcat##1a%
    @letraSHO&##1%
  @else%
    sho@expandafter##1%    
  @fi%
}%
@gdef@letraSHO&##1{% Temos 'sho'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letrashor&%
  @else%
    sho##1%
  @fi%
}%
@gdef@letrashor&##1{% Temos 'shor'
  @ifcat##1a%
    @letraSHOR&##1%
  @else%
    shor@expandafter##1%    
  @fi%
}%
@gdef@letraSHOR&##1{% Temos 'shor'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrashort&%
  @else%
    shor##1%
  @fi%
}%
@gdef@letrashort&##1{% Temos 'shor'
  @ifcat##1a%
    short##1%
  @else%
    @cor{0 0.5 0}{short}@expandafter##1%    
  @fi%
}%
@gdef@letrar&##1{% Temos 'r'
  @ifcat##1a%
    @letraR&##1%
  @else%
    r@expandafter##1%    
  @fi%
}%
@gdef@letraR&##1{% Temos 'r'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrare&%
  @else%
    r##1%
  @fi%
}%
@gdef@letrare&##1{% Temos 're'
  @ifcat##1a%
    @letraRE&##1%
  @else%
    re@expandafter##1%    
  @fi%
}%
@gdef@letraRE&##1{% Temos 're'+letra
  @if##1g%
    @expandafter@expandafter@expandafter@letrareg&%
  @else%
    @if##1s%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrares&%
    @else%
      @if##1t%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@letraret&
      @else%
        re##1%
      @fi%
    @fi
  @fi%
}%
@gdef@letraret&##1{% Temos 'ret'
  @ifcat##1a%
    @letraRET&##1%
  @else%
    ret@expandafter##1%    
  @fi%
}%
@gdef@letraRET&##1{% Temos 'ret'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letraretu&%
  @else%
    ret##1%
  @fi%
}%
@gdef@letraretu&##1{% Temos 'retu'
  @ifcat##1a%
    @letraRETU&##1%
  @else%
    retu@expandafter##1%    
  @fi%
}%
@gdef@letraRETU&##1{% Temos 'retu'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letraretur&%
  @else%
    retu##1%
  @fi%
}%
@gdef@letraretur&##1{% Temos 'retur'
  @ifcat##1a%
    @letraRETUR&##1%
  @else%
    retur@expandafter##1%    
  @fi%
}%
@gdef@letraRETUR&##1{% Temos 'retur'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letrareturn&%
  @else%
    retur##1%
  @fi%
}%
@gdef@letrareturn&##1{% Temos 'retur'
  @ifcat##1a%
    return##1%
  @else%
    @cor{0 0.5 0.5}{return}@expandafter##1%    
  @fi%
}%
@gdef@letrares&##1{% Temos 'res'
  @ifcat##1a%
    @letraRES&##1%
  @else%
    res@expandafter##1%    
  @fi%
}%
@gdef@letraRES&##1{% Temos 'res'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrarest&%
  @else%
    res##1%
  @fi%
}%
@gdef@letrarest&##1{% Temos 'rest'
  @ifcat##1a%
    @letraREST&##1%
  @else%
    rest@expandafter##1%    
  @fi%
}%
@gdef@letraREST&##1{% Temos 'rest'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letrarestr&%
  @else%
    rest##1%
  @fi%
}%
@gdef@letrarestr&##1{% Temos 'restr'
  @ifcat##1a%
    @letraRESTR&##1%
  @else%
    restr@expandafter##1%    
  @fi%
}%
@gdef@letraRESTR&##1{% Temos 'restr'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letrarestri&%
  @else%
    restr##1%
  @fi%
}%
@gdef@letrarestri&##1{% Temos 'restri'
  @ifcat##1a%
    @letraRESTRI&##1%
  @else%
    restri@expandafter##1%    
  @fi%
}%
@gdef@letraRESTRI&##1{% Temos 'restri'+letra
  @if##1c%
    @expandafter@expandafter@expandafter@letrarestric&%
  @else%
    restri##1%
  @fi%
}%
@gdef@letrarestric&##1{% Temos 'restric'
  @ifcat##1a%
    @letraRESTRIC&##1%
  @else%
    restric@expandafter##1%    
  @fi%
}%
@gdef@letraRESTRIC&##1{% Temos 'restric'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrarestrict&%
  @else%
    restric##1%
  @fi%
}%
@gdef@letrarestrict&##1{% Temos 'restrict'
  @ifcat##1a%
    restrict&##1%
  @else%
    @cor{0 0.5 0.5}{restrict}@expandafter##1%    
  @fi%
}%
@gdef@letrareg&##1{% Temos 'reg'
  @ifcat##1a%
    @letraREG&##1%
  @else%
    reg@expandafter##1%    
  @fi%
}%
@gdef@letraREG&##1{% Temos 'reg'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letraregi&%
  @else%
    reg##1%
  @fi%
}%
@gdef@letraregi&##1{% Temos 'regi'
  @ifcat##1a%
    @letraREGI&##1%
  @else%
    regi@expandafter##1%    
  @fi%
}%
@gdef@letraREGI&##1{% Temos 'regi'+letra
  @if##1s%
    @expandafter@expandafter@expandafter@letraregis&%
  @else%
    regi##1%
  @fi%
}%
@gdef@letraregis&##1{% Temos 'regis'
  @ifcat##1a%
    @letraREGIS&##1%
  @else%
    regis@expandafter##1%    
  @fi%
}%
@gdef@letraREGIS&##1{% Temos 'regis'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraregist&%
  @else%
    regis##1%
  @fi%
}%
@gdef@letraregist&##1{% Temos 'regist'
  @ifcat##1a%
    @letraREGIST&##1%
  @else%
    regist@expandafter##1%    
  @fi%
}%
@gdef@letraREGIST&##1{% Temos 'regist'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letraregiste&%
  @else%
    regist##1%
  @fi%
}%
@gdef@letraregiste&##1{% Temos 'registe'
  @ifcat##1a%
    @letraREGISTE&##1%
  @else%
    registe@expandafter##1%    
  @fi%
}%
@gdef@letraREGISTE&##1{% Temos 'registe'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letraregister&%
  @else%
    registe##1%
  @fi%
}%
@gdef@letraregister&##1{% Temos 'register'
  @ifcat##1a%
    register##1%
  @else%
    @cor{0 0.5 0.5}{register}@expandafter##1%    
  @fi%
}%
@gdef@letral&##1{% Temos 'l'
  @ifcat##1a%
    @letraL&##1%
  @else%
    l@expandafter##1%    
  @fi%
}%
@gdef@letraL&##1{% Temos 'l'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letralo&%
  @else%
    l##1%
  @fi%
}%
@gdef@letralo&##1{% Temos 'lo'
  @ifcat##1a%
    @letraLO&##1%
  @else%
    lo@expandafter##1%    
  @fi%
}%
@gdef@letraLO&##1{% Temos 'lo'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letralon&%
  @else%
    lo##1%
  @fi%
}%
@gdef@letralon&##1{% Temos 'lon'
  @ifcat##1a%
    @letraLON&##1%
  @else%
    lon@expandafter##1%    
  @fi%
}%
@gdef@letraLON&##1{% Temos 'lon'+letra
  @if##1g%
    @expandafter@expandafter@expandafter@letralong&%
  @else%
    lon##1%
  @fi%
}%
@gdef@letralong&##1{% Temos 'lon'
  @ifcat##1a%
    long##1%
  @else%
    @cor{0 0.5 0}{long}@expandafter##1%    
  @fi%
}%
@gdef@letrago&##1{% Temos 'go'
  @ifcat##1a%
    @letraGO&##1%
  @else%
    go@expandafter##1%    
  @fi%
}%
@gdef@letraGO&##1{% Temos 'go'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letragot&%
  @else%
    go##1%
  @fi%
}%
@gdef@letragot&##1{% Temos 'got'
  @ifcat##1a%
    @letraGOT&##1%
  @else%
    got@expandafter##1%    
  @fi%
}%
@gdef@letraGOT&##1{% Temos 'got'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letragoto&%
  @else%
    got##1%
  @fi%
}%
@gdef@letragoto&##1{% Temos 'got'
  @ifcat##1a%
    goto##1%
  @else%
    @cor{0 0.5 0.5}{goto}@expandafter##1%    
  @fi%
}%
@gdef@letraf&##1{% Temos 'f'
  @ifcat##1a%
    @letraF&##1%
  @else%
    f@expandafter##1%    
  @fi%
}%
@gdef@letraF&##1{% Temos 'f'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letrafl&%
  @else%
    @if##1o%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrafo&%
    @else%
      f##1%
    @fi%
  @fi%
}%
@gdef@letrafo&##1{% Temos 'fo'
  @ifcat##1a%
    @letraFO&##1%
  @else%
    fo@expandafter##1%    
  @fi%
}%
@gdef@letraFO&##1{% Temos 'fo'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letrafor&%
  @else%
    fo##1%
  @fi%
}%
@gdef@letrafor&##1{% Temos 'for'
  @ifcat##1a%
    for##1%
  @else%
    @cor{0 0.5 0.5}{for}@expandafter##1%    
  @fi%
}%
@gdef@letrafl&##1{% Temos 'fl'
  @ifcat##1a%
    @letraFL&##1%
  @else%
    fl@expandafter##1%    
  @fi%
}%
@gdef@letraFL&##1{% Temos 'fl'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letraflo&%
  @else%
    fl##1%
  @fi%
}%
@gdef@letraflo&##1{% Temos 'flo'
  @ifcat##1a%
    @letraFLO&##1%
  @else%
    flo@expandafter##1%    
  @fi%
}%
@gdef@letraFLO&##1{% Temos 'flo'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letrafloa&%
  @else%
    flo##1%
  @fi%
}%
@gdef@letrafloa&##1{% Temos 'floa'
  @ifcat##1a%
    @letraFLOA&##1%
  @else%
    floa@expandafter##1%    
  @fi%
}%
@gdef@letraFLOA&##1{% Temos 'floa'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letrafloat&%
  @else%
    floa##1%
  @fi%
}%
@gdef@letrafloat&##1{% Temos 'float'
  @ifcat##1a%
    float##1%
  @else%
    @cor{0 0.5 0}{float}@expandafter##1%    
  @fi%
}%
@gdef@letrae&##1{% Temos 'e'
  @ifcat##1a%
    @letraE&##1%
  @else%
    e@expandafter##1%    
  @fi%
}%
@gdef@letraE&##1{% Temos 'e'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letrael&%
  @else%
    @if##1n%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letraen&%
    @else%
      @if##1x%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@letraex&%
      @else%
        e##1%
      @fi
    @fi
  @fi%
}%
@gdef@letraex&##1{% Temos 'ex'
  @ifcat##1a%
    @letraEX&##1%
  @else%
    ex@expandafter##1%    
  @fi%
}%
@gdef@letraEX&##1{% Temos 'ex'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraext&%
  @else%
    ex##1%
  @fi%
}%
@gdef@letraext&##1{% Temos 'ext'
  @ifcat##1a%
    @letraEXT&##1%
  @else%
    ext@expandafter##1%    
  @fi%
}%
@gdef@letraEXT&##1{% Temos 'ext'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letraexte&%
  @else%
    ext##1%
  @fi%
}%
@gdef@letraexte&##1{% Temos 'exte'
  @ifcat##1a%
    @letraEXTE&##1%
  @else%
    exte@expandafter##1%    
  @fi%
}%
@gdef@letraEXTE&##1{% Temos 'exte'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letraexter&%
  @else%
    exte##1%
  @fi%
}%
@gdef@letraexter&##1{% Temos 'exter'
  @ifcat##1a%
    @letraEXTER&##1%
  @else%
    exter@expandafter##1%    
  @fi%
}%
@gdef@letraEXTER&##1{% Temos 'exter'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letraextern&%
  @else%
    exter##1%
  @fi%
}%
@gdef@letraextern&##1{% Temos 'extern'
  @ifcat##1a%
    extern##1%
  @else%
    @cor{0 0.5 0.5}{extern}@expandafter##1%    
  @fi%
}%
@gdef@letraen&##1{% Temos 'en'
  @ifcat##1a%
    @letraEN&##1%
  @else%
    en@expandafter##1%    
  @fi%
}%
@gdef@letraEN&##1{% Temos 'en'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letraenu&%
  @else%
    en##1%
  @fi%
}%
@gdef@letraenu&##1{% Temos 'enu'
  @ifcat##1a%
    @letraENU&##1%
  @else%
    enu@expandafter##1%    
  @fi%
}%
@gdef@letraENU&##1{% Temos 'enu'+letra
  @if##1m%
    @expandafter@expandafter@expandafter@letraenum&%
  @else%
    enu##1%
  @fi%
}%
@gdef@letraenum&##1{% Temos 'enum'
  @ifcat##1a%
    enum##1%
  @else%
    @cor{0 0.5 0.5}{enum}@expandafter##1%    
  @fi%
}%
@gdef@letrael&##1{% Temos 'el'
  @ifcat##1a%
    @letraEL&##1%
  @else%
    el@expandafter##1%    
  @fi%
}%
@gdef@letraEL&##1{% Temos 'el'+letra
  @if##1s%
    @expandafter@expandafter@expandafter@letraels&%
  @else%
    el##1%
  @fi%
}%
@gdef@letraels&##1{% Temos 'els'
  @ifcat##1a%
    @letraELS&##1%
  @else%
    els@expandafter##1%    
  @fi%
}%
@gdef@letraELS&##1{% Temos 'els'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letraelse&%
  @else%
    els##1%
  @fi%
}%
@gdef@letraelse&##1{% Temos 'else'
  @ifcat##1a%
    else##1%
  @else%
    @cor{0 0.5 0.5}{else}@expandafter##1%    
  @fi%
}%
@gdef@letrad&##1{% Temos 'd'
  @ifcat##1a%
    @letraD&##1%
  @else%
    d@expandafter##1%    
  @fi%
}%
@gdef@letraD&##1{% Temos 'd'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrade&%
  @else%
    @if##1o%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrado&%
    @else%
      d##1%
    @fi%
  @fi%
}%
@gdef@letrado&##1{% Temos 'do'
  @ifcat##1a%
    @letraDO&##1%
  @else%
    @cor{0 0.5 0.5}{do}@expandafter##1%    
  @fi%
}%
@gdef@letraDO&##1{% Temos 'do'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letradou&%
  @else%
    do##1%
  @fi%
}%
@gdef@letradou&##1{% Temos 'dou'
  @ifcat##1a%
    @letraDOU&##1%
  @else%
    dou@expandafter##1%    
  @fi%
}%
@gdef@letraDOU&##1{% Temos 'dou'+letra
  @if##1b%
    @expandafter@expandafter@expandafter@letradoub&%
  @else%
    dou##1%
  @fi%
}%
@gdef@letradoub&##1{% Temos 'doub'
  @ifcat##1a%
    @letraDOUB&##1%
  @else%
    doub@expandafter##1%    
  @fi%
}%
@gdef@letraDOUB&##1{% Temos 'doub'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letradoubl&%
  @else%
    doub##1%
  @fi%
}%
@gdef@letradoubl&##1{% Temos 'doubl'
  @ifcat##1a%
    @letraDOUBL&##1%
  @else%
    doubl@expandafter##1%    
  @fi%
}%
@gdef@letraDOUBL&##1{% Temos 'doubl'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letradouble&%
  @else%
    doubl##1%
  @fi%
}%
@gdef@letradouble&##1{% Temos 'double'
  @ifcat##1a%
    double##1%
  @else%
    @cor{0 0.5 0}{double}@expandafter##1%    
  @fi%
}%
@gdef@letrade&##1{% Temos 'de'
  @ifcat##1a%
    @letraDE&##1%
  @else%
    de@expandafter##1%    
  @fi%
}%
@gdef@letraDE&##1{% Temos 'de'+letra
  @if##1f%
    @expandafter@expandafter@expandafter@letradef&%
  @else%
    de##1%
  @fi%
}%
@gdef@letradef&##1{% Temos 'def'
  @ifcat##1a%
    @letraDEF&##1%
  @else%
    def@expandafter##1%    
  @fi%
}%
@gdef@letraDEF&##1{% Temos 'def'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letradefa&%
  @else%
    def##1%
  @fi%
}%
@gdef@letradefa&##1{% Temos 'defa'
  @ifcat##1a%
    @letraDEFA&##1%
  @else%
    defa@expandafter##1%    
  @fi%
}%
@gdef@letraDEFA&##1{% Temos 'defa'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letradefau&%
  @else%
    defa##1%
  @fi%
}%
@gdef@letradefau&##1{% Temos 'defau'
  @ifcat##1a%
    @letraDEFAU&##1%
  @else%
    defau@expandafter##1%    
  @fi%
}%
@gdef@letraDEFAU&##1{% Temos 'defau'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letradefaul&%
  @else%
    defau##1%
  @fi%
}%
@gdef@letradefaul&##1{% Temos 'defaul'
  @ifcat##1a%
    @letraDEFAUL&##1%
  @else%
    defaul@expandafter##1%    
  @fi%
}%
@gdef@letraDEFAUL&##1{% Temos 'defaul'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letradefault&%
  @else%
    defaul##1%
  @fi%
}%
@gdef@letradefault&##1{% Temos 'default'
  @ifcat##1a%
    default##1%
  @else%
    @cor{0 0.5 0.5}{default}@expandafter##1%    
  @fi%
}%
@gdef@letrac&##1{% Temos a letra 'c'
  @ifcat##1a%
    @letraC&##1%
  @else%
    c@expandafter##1%    
  @fi%
}%
@gdef@letraC&##1{% Temos a letra 'c'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letraca&%
  @else%
    @if##1h%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrach&%
    @else%
      @if##1o%
        @expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter@letraco&%
      @else%
        c##1%
      @fi
    @fi%
  @fi%
}%
@gdef@letraco&##1{% Temos 'co'
  @ifcat##1a%
    @letraCO&##1%
  @else%
    co@expandafter##1%    
  @fi%
}%
@gdef@letraCO&##1{% Temos 'co'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letracon&%
  @else%
    @if##1m%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letracom&%
    @else%
      co##1%
    @fi
  @fi%
}%
@gdef@letracom&##1{% Temos 'com'
  @ifcat##1a%
    @letraCOM&##1%
  @else%
    com@expandafter##1%    
  @fi%
}%
@gdef@letraCOM&##1{% Temos 'com'+letra
  @if##1p%
    @expandafter@expandafter@expandafter@letracomp&%
  @else%
    com##1%
  @fi%
}%
@gdef@letracomp&##1{% Temos 'comp'
  @ifcat##1a%
    @letraCOMP&##1%
  @else%
    comp@expandafter##1%    
  @fi%
}%
@gdef@letraCOMP&##1{% Temos 'comp'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letracompl&%
  @else%
    comp##1%
  @fi%
}%
@gdef@letracompl&##1{% Temos 'compl'
  @ifcat##1a%
    @letraCOMPL&##1%
  @else%
    compl@expandafter##1%    
  @fi%
}%
@gdef@letraCOMPL&##1{% Temos 'compl'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letracomple&%
  @else%
    compl##1%
  @fi%
}%
@gdef@letracomple&##1{% Temos 'comple'
  @ifcat##1a%
    @letraCOMPLE&##1%
  @else%
    comple@expandafter##1%    
  @fi%
}%
@gdef@letraCOMPLE&##1{% Temos 'comple'+letra
  @if##1x%
    @expandafter@expandafter@expandafter@letracomplex&%
  @else%
    comple##1%
  @fi%
}%
@gdef@letracomplex&##1{% Temos 'complex'
  @ifcat##1a%
    complex##1%
  @else%
    @cor{0 0.5 0}{complex}@expandafter##1%    
  @fi%
}%
@gdef@letracon&##1{% Temos 'con'
  @ifcat##1a%
    @letraCON&##1%
  @else%
    con@expandafter##1%    
  @fi%
}%
@gdef@letraCON&##1{% Temos 'con'+letra
  @if##1s%
    @expandafter@expandafter@expandafter@letracons&%
  @else%
    @if##1t%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter@expandafter@letracont&%
    @else%
      con##1%
    @fi%
  @fi%
}%
@gdef@letracons&##1{% Temos 'cons'
  @ifcat##1a%
    @letraCONS&##1%
  @else%
    cons@expandafter##1%    
  @fi%
}%
@gdef@letraCONS&##1{% Temos 'cons'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraconst&%
  @else%
    cons##1%
  @fi%
}%
@gdef@letracont&##1{% Temos 'cont'
  @ifcat##1a%
    @letraCONT&##1%
  @else%
    cont@expandafter##1%    
  @fi%
}%
@gdef@letraCONT&##1{% Temos 'cont'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letraconti&%
  @else%
    cont##1%
  @fi%
}%
@gdef@letraconti&##1{% Temos 'conti'
  @ifcat##1a%
    @letraCONTI&##1%
  @else%
    conti@expandafter##1%    
  @fi%
}%
@gdef@letraCONTI&##1{% Temos 'conti'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letracontin&%
  @else%
    conti##1%
  @fi%
}%
@gdef@letracontin&##1{% Temos 'contin'
  @ifcat##1a%
    @letraCONTIN&##1%
  @else%
    contin@expandafter##1%    
  @fi%
}%
@gdef@letraCONTIN&##1{% Temos 'contin'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letracontinu&%
  @else%
    contin##1%
  @fi%
}%
@gdef@letracontinu&##1{% Temos 'continu'
  @ifcat##1a%
    @letraCONTINU&##1%
  @else%
    continu@expandafter##1%    
  @fi%
}%
@gdef@letraCONTINU&##1{% Temos 'continu'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letracontinue&%
  @else%
    continu##1%
  @fi%
}%
@gdef@letracontinue&##1{% Temos 'continue'
  @ifcat##1a%
    continue##1%
  @else%
    @cor{0 0.5 0.5}{continue}@expandafter##1%    
  @fi%
}%
@gdef@letraconst&##1{% Temos 'const'
  @ifcat##1a%
    const##1%
  @else%
    @cor{0 0.5 0.5}{const}@expandafter##1%    
  @fi%
}%
@gdef@letrach&##1{% Temos 'ch'
  @ifcat##1a%
    @letraCH&##1%
  @else%
    ch@expandafter##1%    
  @fi%
}%
@gdef@letraCH&##1{% Temos 'ch'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letracha&%
  @else%
    ch##1%
  @fi%
}%
@gdef@letracha&##1{% Temos 'cha'
  @ifcat##1a%
    @letraCHA&##1%
  @else%
    cha@expandafter##1%    
  @fi%
}%
@gdef@letraCHA&##1{% Temos 'cha'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letrachar&%
  @else%
    cha##1%
  @fi%
}%
@gdef@letrachar&##1{% Temos 'char'
  @ifcat##1a%
    char##1%
  @else%
    @cor{0 0.5 0}{char}@expandafter##1%
  @fi%
}%
@gdef@letraca&##1{% Temos a letra 'ca'
  @ifcat##1a%
    @letraCA&##1%
  @else%
    ca@expandafter##1%    
  @fi%
}%
@gdef@letraCA&##1{% Temos a letra 'ca'+letra
  @if##1s%
    @expandafter@expandafter@expandafter@letracas&%
  @else%
    ca##1%
  @fi%
}%
@gdef@letracas&##1{% Temos 'cas'
  @ifcat##1a%
    @letraCAS&##1%
  @else%
    cas@expandafter##1%    
  @fi%
}%
@gdef@letraCAS&##1{% Temos a letra 'cas'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letracase&%
  @else%
    cas##1%
  @fi%
}%
@gdef@letracase&##1{% Temos 'case'
  @ifcat##1a%
    case##1%
  @else%
    @cor{0 0.5 0.5}{case}@expandafter##1%
  @fi%
}%
@gdef@letrab&##1{% Temos a letra 'b'
  @ifcat##1a%
    @letraB&##1%
  @else%
    b@expandafter##1%    
  @fi%
}%
@gdef@letraB&##1{% Temos a letra 'b'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letrabr&%
  @else%
    @if##1o%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter@expandafter@letrabo&%
    @else%
      b##1%
    @fi%    
  @fi%
}%
@gdef@letrabo&##1{% Temos 'bo'
  @ifcat##1a%
    @letraBO&##1%
  @else%
    bo@expandafter##1%    
  @fi%
}%
@gdef@letraBO&##1{% Temos 'bo'+letra
  @if##1o%
    @expandafter@expandafter@expandafter@letraboo&%
  @else%
    bo##1%
  @fi%
}%
@gdef@letraboo&##1{% Temos 'boo'
  @ifcat##1a%
    @letraBOO&##1%
  @else%
    boo@expandafter##1%    
  @fi%
}%
@gdef@letraBOO&##1{% Temos 'boo'+letra
  @if##1l%
    @expandafter@expandafter@expandafter@letrabool&%
  @else%
    boo##1%
  @fi%
}%
@gdef@letrabool&##1{% Temos 'bool'
  @ifcat##1a%
    bool##1%
  @else%
    @cor{0 0.5 0}{bool}@expandafter##1%
  @fi%
}%
@gdef@letrabr&##1{% Temos 'br'
  @ifcat##1a%
    @letraBR&##1%
  @else%
    br@expandafter##1%    
  @fi%
}%
@gdef@letraBR&##1{% Temos 'br'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrabre&%
  @else%
    br##1%
  @fi%
}%
@gdef@letrabre&##1{% Temos 'bre'
  @ifcat##1a%
    @letraBRE&##1%
  @else%
    bre@expandafter##1%    
  @fi%
}%
@gdef@letraBRE&##1{% Temos 'bre'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letrabrea&%
  @else%
    bre##1%
  @fi%
}%
@gdef@letrabrea&##1{% Temos 'brea'
  @ifcat##1a%
    @letraBREA&##1%
  @else%
    brea@expandafter##1%    
  @fi%
}%
@gdef@letraBREA&##1{% Temos 'brea'+letra
  @if##1k%
    @expandafter@expandafter@expandafter@letrabreak&%
  @else%
    brea##1%
  @fi%
}%
@gdef@letrabreak&##1{% Temos 'break'
  @ifcat##1a%
    break##1%
  @else%
    @cor{0 0.5 0.5}{break}@expandafter##1%    
  @fi%
}%
@gdef@letraa&##1{% Temos a letra 'a'
  @ifcat##1a%
    @letraA&##1%
  @else%
    a@expandafter##1%    
  @fi%
}%
@gdef@letraA&##1{% Temos a letra 'a'+letra
  @if##1u%
    @expandafter@expandafter@expandafter@letraau&%
  @else%
    a##1%
  @fi%
}%
@gdef@letraau&##1{% Temos 'au'
  @ifcat##1a%
    @letraAU&##1%
  @else%
    au@expandafter##1%    
  @fi%
}%
@gdef@letraAU&##1{% Temos 'au'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraaut&%
  @else%
    au##1%
  @fi%
}%
@gdef@letraaut&##1{% Temos 'aut'
  @ifcat##1a%
    @letraAUT&##1%
  @else%
    aut@expandafter##1%
  @fi%
}%
@gdef@letraAUT&##1{% Temos 'aut+letra'
  @if##1o%
    @expandafter@expandafter@expandafter@letraauto&%
  @else%
    aut##1%
  @fi%
}%
@gdef@letraauto&##1{% Temos 'auto'
  @ifcat##1a%
    auto##1%
  @else%
    @cor{0 0.5 0.5}{auto}@expandafter##1%
  @fi%
}%
@gdef@letrai&##1{% Invocada quando a 1a letra é i
  @ifcat##1a%
    @letraI&##1%
  @else%
    i@expandafter##1%
  @fi}%
@gdef@letraI&##1{% Invocada quando a 1a letra é i+letra
  @if##1f%
    @expandafter@expandafter@expandafter@letraif&%
  @else%
    @if##1n%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrain&%
    @else%
      @if##1m%
        @expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter%
        @expandafter@expandafter@expandafter@expandafter@expandafter%
        @letraim&%
      @else%
        i##1%
      @fi%
    @fi%
  @fi%
}%
@gdef@letraif&##1{% Lemos um 'if' e checamos se palavra terminou
  @ifcat##1a%
    if##1%
  @else%
    @cor{0 0.5 0.5}{if}@expandafter##1%
  @fi}%
@gdef@letraim&##1{% Lemos um 'im'
  @ifcat##1a%
    @letraIM&##1%
  @else%
    im@expandafter##1%
  @fi}%
@gdef@letraIM&##1{% Lemos um 'im'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letraima&%
  @else%
    im##1%
  @fi%
}%
@gdef@letraima&##1{% Lemos um 'ima'
  @ifcat##1a%
    @letraIMA&##1%
  @else%
    ima@expandafter##1%
  @fi}%
@gdef@letraIMA&##1{% Lemos um 'ima'+letra
  @if##1g%
    @expandafter@expandafter@expandafter@letraimag&%
  @else%
    ima##1%
  @fi%
}%
@gdef@letraimag&##1{% Lemos um 'imag'
  @ifcat##1a%
    @letraIMAG&##1%
  @else%
    imag@expandafter##1%
  @fi}%
@gdef@letraIMAG&##1{% Lemos um 'imag'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letraimagi&%
  @else%
    imag##1%
  @fi%
}%
@gdef@letraimagi&##1{% Lemos um 'imagi'
  @ifcat##1a%
    @letraIMAGI&##1%
  @else%
    imagi@expandafter##1%
  @fi}%
@gdef@letraIMAGI&##1{% Lemos um 'imagi'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letraimagin&%
  @else%
    imagi##1%
  @fi%
}%
@gdef@letraimagin&##1{% Lemos um 'imagin'
  @ifcat##1a%
    @letraIMAGIN&##1%
  @else%
    imagin@expandafter##1%
  @fi}%
@gdef@letraIMAGIN&##1{% Lemos um 'imagin'+letra
  @if##1a%
    @expandafter@expandafter@expandafter@letraimagina&%
  @else%
    imagin##1%
  @fi%
}%
@gdef@letraimagina&##1{% Lemos um 'imagina'
  @ifcat##1a%
    @letraIMAGINA&##1%
  @else%
    imagina@expandafter##1%
  @fi}%
@gdef@letraIMAGINA&##1{% Lemos um 'imagina'+letra
  @if##1r%
    @expandafter@expandafter@expandafter@letraimaginar&%
  @else%
    imagina##1%
  @fi%
}%
@gdef@letraimaginar&##1{% Lemos um 'imaginar'
  @ifcat##1a%
    @letraIMAGINAR&##1%
  @else%
    imaginar@expandafter##1%
  @fi}%
@gdef@letraIMAGINAR&##1{% Lemos um 'imaginar'+letra
  @if##1y%
    @expandafter@expandafter@expandafter@letraimaginary&%
  @else%
    imaginar##1%
  @fi%
}%
@gdef@letraimaginary&##1{% Lemos um 'imaginary'
  @ifcat##1a%
    imaginary##1%
  @else%
    @cor{0 0.5 0}{imaginary}@expandafter##1%
  @fi}%
@gdef@letrain&##1{% Lemos um 'in'
  @ifcat##1a%
    @letraIN&##1%
  @else%
    in@expandafter##1%
  @fi}%
@gdef@letraIN&##1{% Lemos um 'in'+letra
  @if##1t%
    @expandafter@expandafter@expandafter@letraint&%
  @else%
    @if##1l%
      @expandafter@expandafter@expandafter@expandafter@expandafter@expandafter%
      @expandafter@letrainl&%
    @else%
      in##1%
    @fi
  @fi%
}%
@gdef@letrainl&##1{% Lemos um 'inl'
  @ifcat##1a%
    @letraINL&##1%
  @else%
    inl@expandafter##1%
  @fi}%
@gdef@letraINL&##1{% Lemos um 'inl'+letra
  @if##1i%
    @expandafter@expandafter@expandafter@letrainli&%
  @else%
    inl##1%
  @fi%
}%
@gdef@letrainli&##1{% Lemos um 'inli'
  @ifcat##1a%
    @letraINLI&##1%
  @else%
    inli@expandafter##1%
  @fi}%
@gdef@letraINLI&##1{% Lemos um 'inli'+letra
  @if##1n%
    @expandafter@expandafter@expandafter@letrainlin&%
  @else%
    inli##1%
  @fi%
}%
@gdef@letrainlin&##1{% Lemos um 'inlin'
  @ifcat##1a%
    @letraINLIN&##1%
  @else%
    inlin@expandafter##1%
  @fi}%
@gdef@letraINLIN&##1{% Lemos um 'inlin'+letra
  @if##1e%
    @expandafter@expandafter@expandafter@letrainline&%
  @else%
    inlin##1%
  @fi%
}%
@gdef@letrainline&##1{% Lemos um 'inline'
  @ifcat##1a%
    inline##1%
  @else%
    @cor{0 0.5 0.5}{inline}@expandafter##1%
  @fi}%
@gdef@letraint&##1{% Lemos um 'int'
  @ifcat##1a%
    int##1%
  @else%
    @cor{0 0.5 0}{int}@expandafter##1%
  @fi}%
}
\def\fimsh&{@gdef@sh&{}@everypar{}@catcode`_=8@catcode`0=12@catcode`1=12%
  @catcode`2=12@catcode`3=12@catcode`4=12@catcode`5=12@catcode`6=12%
  @catcode`7=12@catcode`8=12@catcode`9=12@catcode`"=12@catcode`(=12%
  @catcode`:=12  @catcode`|=13@catcode`.=12%
  @if@comentario& 1@special{color pop}@gdef@comentario&{0}@fi%
  @if@macro& 1@special{color pop}@gdef@macro&{0}@fi%
  @gdef@<##1@>##2{%
  @linha@espaco{1mm}@noindent@negrito{Seção: ##1%
  @if##2+
    (continuação)%
  @fi:}%
  @alinhacodigo@vskip1mm@chomp&}@gdef@ {@space&}%
  @gdef|{@gdef|{@fimsh&@alinhanormal&@catcode`\\=0@gdef@cm&{0}@gdef@c&{0} }%
  @ifvmode@indent@fi@alinhaverbatim&@gdef@c&{1}@catcode`\\=12@gdef@cm&{1}@iniciosh&}}

% O @ agora precisa ser usado como comando
\def@@{\char"40}

% Um espaço agora pode terminar a região de código C:
\def\space&{ }


% A região de código C funcionará de modo semelhante ao modo
% verbatim. A diferença é que o '\' passará a ser considerado
% caractere comum. Desta forma, comandos só poderão ser digitados com
% o '@.
\def\alinhacodigo{\linha\alinhaverbatim&\gdef\c&{1}\catcode`\\=12@iniciosh&}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              CÓDIGO INICIAL                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\catcode`&=4 % @ não será mais usado em nomes de sequencias de controle



\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{The Weaver Program}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article describes using literary programming the
  program Weaver. This program is a project manager for the Weaver
  Game Engine. If a user wants to create a new game with the Weaver
  Game Engine, they use this program to create the directory structure
  for a new game project. They also use this program to add new source
  files and shader files to a game project. And to update a project
  with a more recent Weaver version installed in the computer. The
  presenting code in C is cross-platform and should work under
  Windows, Linux, OpenBSD and possibly other Unix variants.}


\secao{1. Introduction}

A game engine is made by a set of libraries and functions that helps a
game creation offering common functionalities for this kind of
development. But besides the libraries and functions, there should
exist a manager responsible for creating some code which uses the
library in a correct way and executes the necessary initializations.


The Weaver Game Engine has very strict prerequisites about how the
directory with a game project should be organized. To follow these
requisites, this program is necessary. It initializesin a correct way
the directory structure in a new project. It adds new source files
with the correct code to ensure the code integration. And controlling
the project in this way, it also knows how to perform updates in the
libraries for more recent versions.

This program usage is by the command line. For example, if a user
types ``{\tt weaver pong}'', a new directory structure like in the
following image will be created.

\imagem{cweb/diagrams/project_dir.eps}

The following sections in this document are organized in the following
way. Section 2 is about this software license. Section 3 lists all the
variables that control its execution. Section 4 defines some macros
used in the program structure. Section 5 lists all the auxiliary
functions defined. Sections 6 is how the variables are
initialized. Section 7 is about the software use cases and how they
are implemented after we have all the variables with the correct
value.

\secao{2. Copyright and licensing}

The software license is the GNU General Public License version 3:

\espaco{5mm}\linha
\alinhaverbatim
Copyright (c) Thiago Leucz Astrizi 2015

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public
License along with this program.  If not, see
<http://www.gnu.org/licenses/>.

\linha\espaco{5mm}

The complete version of the license can be obtained with the source
code or checking the link above.

\secao{3. Variables and software structure}

Weaver execution depends of the following variables:

|inside_weaver_directory|: If the program is invoked inside a Weaver
 project directory.

|argument|: The first argument, or NULL if doesn't exist.

|argument2|: The second argument, or NULL if doesn't exist.

|project_version_major|: If we are in a Weaver project, which is the
 major version number of the program which created the project? For
 example, if wea are in a project created by Weaver 0.5, the major
 version is 0. In tests version, the value is always 0.

|project_version_minor|: If we are in a Weaver project, the minor
 version number of the program which created the project. For example,
 if Weaver 0.5 created the current project, this number is 5. In test
 versions, the value is always 0.

|weaver_version_major|: The major version of this program.

|weaver_version_minor|: The minor version of this program.

|arg_is_path|: If the first argument exists and is an absolute or
 relative path in the filesystem.

|arg_is_valid_project|: If the first argument exists and would be
 considered a valid Weaver project name.

|arg_is_valid_module|: If the first argument exists and would be
 considered a valid module name in a Weaver project.

|arg_is_valid_plugin|: If the second argument exists and would be
 considered a valid plugin name in a Weaver project.

|arg_is_valid_function|: If the second argument exists and if it would
 be considered a valid name for a main loop and for a new file in a
 Weaver project.

|project_path|: If we are inside a Weaver project, which is the path
 for its base directory (where is the Makefile)?

|have_arg|: If the program is invoked with an argument.

|shared_dir|: The path to the directory where are the shared files
 from Weaver installation. The default is ``{\tt
 /usr/local/share/weaver}'' in Unix systems and the ``Program Files''
 folder in Windows. This can be changed in the program building
 defining the macro {\tt WEAVER\_DIR}.

|author_name|,|project_name| and |year|: The name of the user which is
 executing the program, the current project name (if we are inside a
 Weaver project directory) and the current year. This is important for
 copyright messages creation.

|return_value|: If the program is interrupted in this exact moment,
 what the program should return?

The software general structure with all the variables declarations is:


\iniciocodigo
@(src/weaver.c@>=
@<Headers Included in Weaver Program@>
@<Weaver Program Macros@>
@<Weaver Auxiliary Functions@>
int main(int argc, char **argv){@/
  int return_value = 0; /* Return value. */
  bool inside_weaver_directory = false, arg_is_path = false,
    arg_is_valid_project = false, arg_is_valid_module = false,
    have_arg = false, arg_is_valid_plugin = false,
    arg_is_valid_function = false; /* Boolean variables. */
  unsigned int project_version_major = 0, project_version_minor = 0,
    weaver_version_major = 0, weaver_version_minor = 0,
    year = 0;
  /* Strings UTF-8: */
  char *argument = NULL, *project_path = NULL, *shared_dir = NULL,
    *author_name = NULL, *project_name = NULL, *argument2 = NULL;
  @<Initialization@>
  @<Use Case 1: Printing help (create project)@>
  @<Use Case 2: Printing management help@>
  @<Use Case 3: Print version@>
  @<Use Case 4: Updating Weaver project@>
  @<Use Case 5: Create new module@>
  @<Use Case 6: Create new project@>
  @<Use Case 7: Create new plugin@>
  @<Use Case 8: Create new shader@>
  @<Use Case 9: Create new main loop@>
END_OF_PROGRAM:
  @<Finishing@>
  return return_value;
}
@
\fimcodigo

\secao{4. Macros and Headers in Weaver Program}

This program needs some macros. The first one shall store a string
with the program version; This version could be formed just by letters
(if a test version) or by digits followed by a dot and more digits
(without whitespaces) if this is a final version of the program.

For the second macro, observe that in the program structure above,
exists a label called |END_OF_PROGRAM| in the finishing part. We can
reach the label following the program normal execution, if nothing
wrong happens. Otherwise, if an error happens, we can reach that label
by an unconditional jump after printing the error message and
adjusting the program return value. Treating this error condition with
these actions is the second macro responsability.

We also could finish the program prematurely, but not because some
error happened. The third macro will treat this case:

\iniciocodigo
@<Weaver Program Macros@>=
#define VERSION "Alpha"
#define W_ERROR() {perror(NULL); return_value = 1; goto END_OF_PROGRAM;}
#define END() goto END_OF_PROGRAM;
@
\fimcodigo

We are using the library function \monoespaco{perror}, so we need to
include the header \monoespaco{stdio.h}, which will also bring us
other useful functions to print in the screen or in files and to open
and close files. We also should insert support for boolean values and
the standard library with functions like |exit| utilized in the
program structure:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#include <stdio.h> // printf, fprintf, fopen, fclose, fgets, fgetc, perror
#include <stdbool.h> // bool, true, false
#include <stdlib.h> // free, exit, getenv
@
\fimcodigo

\secao{5. Auxiliary Functions}

Here we list some functions which we should use in the program to
facilitate its description.

\subsecao{5.1. path\_up: Manipulating Paths}

To manipulate directory tree paths, we define an auxiliary function
which receives a path and erases the last characters until two ``/''
are erased. So in ``/home/alice/project/dir/'', it returns
``/home/alice/project'', goind one level up in the directory tree.

But in Windows systems, the separator isn't ``/'', but ``\\''. So we
should treat the separator differently according with the Operating
System:

\iniciocodigo
@<Weaver Auxiliary Functions@>=
void path_up(char *path){
#if !defined(_WIN32)
  char separator = '/';
#else
  char separator = '\\';
#endif
  int erased = 0;
  char *p = path;
  while(*p != '\0') p ++; // Vai até o fim
  while(erased < 2 && p != path){
    p --;
    if(*p == separator) erased ++;
    *p = '\0'; // Apaga
  }
}
@
\fimcodigo

Notice that if the function get a string without two separators, we
erase all the string. In this program we will limit this function
usage to strings with path for files outside the root directory, which
are not the root directory themselves and for directories ended by the
separator character. So we should always respect the limit of minimal
two separators in paths. Example: ``/etc/'' and ``/tmp/file.txt''.

\subsecao{5.2. directory\_exists: Arquivo existe e é diretório}

To check if the directory \monoespaco{.weaver} exists, we define
|directory_exist(x)| as a function which gets a file path and returns
1 if |x| is an existing directory, -1 if |x| is an existing file and 0
otherwise. Fist let's create macros to make explicit the meaning of
return values:

\iniciocodigo
@<Weaver Program Macros@>+=
#define DONT_EXIST         0
#define EXISTS_AND_IS_DIR   1
#define EXISTS_AND_IS_FILE -1
@
\fimcodigo

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
int directory_exist(char *dir){
#if !defined(_WIN32)
  // Unix:
  struct stat s; // Stores if the file exists
  int err; // Checagem de erros
  err = stat(dir, &s); // It exists?
  if(err == -1) return DONT_EXIST;
  if(S_ISDIR(s.st_mode)) return EXISTS_AND_IS_DIR;
  return EXISTS_AND_IS_FILE;
#else
  // Windows:
  DWORD dwAttrib = GetFileAttributes(dir);
  if(dwAttrib == INVALID_FILE_ATTRIBUTES) return DONT_EXIST;
  if(!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY)) return EXISTS_AND_IS_FILE;
  else return EXISTS_AND_IS_DIR;
#endif
}
@
\fimcodigo

Depending of the Operating System, we should utilize different
functions and need different headers:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#if !defined(_WIN32)
#include <sys/types.h> // stat, getuid, getpwuid, mkdir
#include <sys/stat.h> // stat, mkdir
#else
#include <windows.h> // GetFileAttributes, ...
#endif
@
\fimcodigo

\subsecao{5.3. concatenate: Concatenate strings}

This function gets an arbitrary number of strings, but the last string
must be |NULL| or the empty string. And it returns the concatenation
of all the strings passed as argument. The function will always
allocate a new string, which should be freed before the program
ending.

Example: |concatenate("tes", " ", "t", "")| returns |"tes t"|.

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
char *concatenate(char *string, ...){
  va_list arguments;
  char *new_string, *current_string = string;
  size_t current_size = strlen(string) + 1;
  char *realloc_return;
  va_start(arguments, string);
  new_string = (char *) malloc(current_size);
  if(new_string == NULL) return NULL;
   // Copy the first string as recommended by the Operating System:
#ifdef __OpenBSD__
  strlcpy(new_string, string, current_size);
#else
  strcpy(new_string, string);
#endif
  while(current_string != NULL && current_string[0] != '\0'){
    current_string = va_arg(arguments, char *);
    current_size += strlen(current_string);
    realloc_return = (char *) realloc(new_string, current_size);
    if(realloc_return == NULL){
      free(new_string);
      return NULL;
    }
    new_string = realloc_return;
     // Copy the string as recommended by the Operating System:
#ifdef __OpenBSD__
    strlcat(new_string, current_string, current_size);
#else
    strcat(new_string, current_string);
#endif
  }
  return new_string;
}
@
\fimcodigo

This is a dangerous function that always should be invoked passing as
last argument an empty string or NULL.

This function usage requires the following headers:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#include <string.h> // strcmp, strcat, strcpy, strncmp
#include <stdarg.h> // va_start, va_arg
@
\fimcodigo

\subsecao{5.4. basename: Get a file name given its path}

This function already exists in Unix systems. Given a complete path
for a file, it returns a string with the file name. It doesn't neet to
allocate a new string, it can just return a pointer for the filename
inside the path string. Let's define it for Windows and other systems
without a |basename| function:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
#if defined(_WIN32)
char *basename(char *path){
  char *p = path;
  char *last_delimiter = NULL;
  while(*p != '\0'){
    if(*p == '\\')
      last_delimiter = p;
    p ++;
  }
  if(last_delimiter != NULL)
    return last_delimiter + 1;
  else
    return path;
}
#endif
@
\fimcodigo


In Unix Systems, we don't need to define this function, we just
include its header:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#if !defined(_WIN32)
#include <libgen.h>
#endif
@
\fimcodigo

\subsecao{5.5. copy\_single\_file: Copy single file to target directory}

The function |copy_single_file| copies the file which path is the
first argument to the target directory which path is the second
argument. It returns 1 if successful or 0 otherwise.

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
int copy_single_file(char *file, char *directory){
  int block_size, bytes_read;
  char *buffer, *file_dst;
  FILE *orig, *dst;
  // Inicializa 'block_size':
  @<Descobre tamanho do bloco do sistema de arquivos@>
  buffer = (char *) malloc(block_size); // Allocating buffer for copy
  if(buffer == NULL) return 0;
  file_dst = concatenate(directory, "/", basename(file), "");
  if(file_dst == NULL) return 0;
  orig = fopen(file, "r"); // Open origin file
  if(orig == NULL){
    free(buffer);
    free(file_dst);
    return 0;
  }
  dst = fopen(file_dst, "w"); // Open destiny file
  if(dst == NULL){
    fclose(orig);
    free(buffer);
    free(file_dst);
    return 0;
  }
  while((bytes_read = fread(buffer, 1, block_size, orig)) > 0){
    fwrite(buffer, 1, bytes_read, dst); // Copy origin to destiny
  }
  fclose(orig);
  fclose(dst);
  free(file_dst);
  free(buffer);
  return 1;
}
@
\fimcodigo

It's more efficient when the buffer used in the copy has the same size
than a block in the filesystem. To get the correct valuem we use this
code in Unix systems:

\iniciocodigo
@<Discover block size@>=
#if !defined(_WIN32)
{
  struct stat s;
  stat(directory, &s);
  block_size = s.st_blksize;
  if(block_size <= 0){
    block_size = 4096;
  }
}
#endif
@
\fimcodigo

In Windows we just assume that the size is 4KB:

\iniciocodigo
@<Discover block size@>+=
#if defined(_WIN32)
  block_size = 4096;
#endif
@
\fimcodigo

\subsecao{5.6. copy\_files: Copy all source files to destiny}

With a function to copy a single file, we need to define a function to
copy all the files inside a directory recursivelly. This requises some
work, as we need to list all the content in a directory to get its
files. How to do this depends of the Operating System.

In Unix systems we use the function |readdir| to read the content of
directories:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
#if !defined(_WIN32)
int copy_files(char *orig, char *dst){
  DIR *d = NULL;
  struct dirent *dir;
  d = opendir(orig);
  if(d){
    while((dir = readdir(d)) != NULL){ // Loop to read each file
      char *file;
      file = concatenate(orig, "/", dir -> d_name, "");
      if(file == NULL){
        return 0;
      }
#if (defined(__linux__) || defined(_BSD_SOURCE)) && defined(DT_DIR)
      // If we support DT_DIR, we don't need the funcion 'stat':
      if(dir -> d_type == DT_DIR){
#else
      struct stat s;
      int err;
      err = stat(file, &s);
      if(err == -1) return 0;
      if(S_ISDIR(s.st_mode)){
#endif
      // If we are dealing with a subdirectory:
        char *new_dst;
        new_dst = concatenate(dst, "/", dir -> d_name, "");
        if(new_dst == NULL){
          return 0;
        }
        if(strcmp(dir -> d_name, ".") && strcmp(dir -> d_name, "..")){
          if(directory_exist(new_dst) == DONT_EXIST) mkdir(new_dst, 0755);
          if(copy_files(file, new_dst) == 0){
            free(new_dst);
            free(file);
            closedir(d);
            return 0;
          }
        }
        free(new_dst);
      }
      else{
        // If we get a regular file:
        if(copy_single_file(file, dst) == 0){
          free(file);
          closedir(d);
          return 0;
        }
      }
    free(file);
    } // End of loop to read each file
    closedir(d);
  }
  return 1;
}
#endif
@
\fimcodigo

And this requires the following headers:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#if !defined(_WIN32)
#include <dirent.h> // readdir, opendir, closedir
#endif
@
\fimcodigo

In Windows we don't need new headers. The function definition becames
the following:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
#if defined(_WIN32)
int copy_files(char *orig, char *dst){
  char *path, *search_path;
  WIN32_FIND_DATA file;
  HANDLE dir = NULL;
  search_path = concatenate(orig, "\\*", "");
  if(search_path == NULL)
    return 0;
  dir = FindFirstFile(search_path, &file);
  if(dir != INVALID_HANDLE_VALUE){
    // The first file shall be '.' and should be safely ignored
    do{
      if(strcmp(file.cFileName, ".") && strcmp(file.cFileName, "..")){
        path = concatenate(orig, "\\", file.cFileName, "");
        if(path == NULL){
	  free(search_path);
          return 0;
        }
        if(file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
          char *dst_path;
          dst_path = concatenate(dst, "\\", file.cFileName, "");
          if(directory_exist(dst_path) == DONT_EXIST)
            CreateDirectoryA(dst_path, NULL);
          if(copy_files(path, dst_path) == 0){
            free(dst_path);
            free(path);
            FindClose(dir);
	    free(search_path);
            return 0;
          }
          free(dst_path);
        }
        else{ // file
          if(copy_single_file(path, dst) == 0){
            free(path);
            FindClose(dir);
	    free(search_path);
            return 0;
          }
        }
        free(path);
      }
    }while(FindNextFile(dir, &file));
  }
  free(search_path);
  FindClose(dir);
  return 1;
}
#endif
@
\fimcodigo

\subsecao{5.7. write\_copyright: Write copyright messages in files}

By default Weaver projects are licensed under GNU GPL 3. As codes
under this license are copied and utilized statically in new projects,
the new projects needs the same license or a compatible one.

The code is very simple and requires just some parameters as the
author name and the current year:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
void write_copyright(FILE *fp, char *author_name, char *project_name, int year){
  char license[] = "/*\nCopyright (c) %s, %d\n\nThis file is part of %s.\n\n%s\
 is free software: you can redistribute it and/or modify\nit under the terms of\
 the GNU Affero General Public License as published by\nthe Free Software\ 
 Foundation, either version 3 of the License, or\n(at your option) any later\
 version.\n\n\
%s is distributed in the hope that it will be useful,\nbut WITHOUT ANY\
  WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS\
  FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more\
  details.\n\nYou should have received a copy of the GNU Affero General Public License\
\nalong with %s. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n";
  fprintf(fp, license, author_name, year, project_name, project_name,
          project_name, project_name);
}
@
\fimcodigo

\subsecao{5.8. create\_dir: Create new directories}

This function is responsible for creating a list of directories. This
is a very simple thing, but should be encapsulated in a function
because of differences between Operating Systems about how to do this
task.

This function must receive as argument a variable number of strings,
but the last argument must be an empty string or NULL. Earch argument
except the last represents a path. The function will create the
directory with the specified path. By default we use
``\monoespaco{/}'' as separator, so the function shall work both in
Unix systems as in Windows. In the later, the
function \monoespaco{CreateDirectoryA} accepts paths represented in
Unix notation.

In Unix systems we need to specify the maximum permissions in the
directory in terms os reading, writing and execution. The Operating
System can then accept our recommended permissions, or ensure more
restrictive ones depending of configuration. In Windows the permission
logic is more hyerarquical, so we just use the same permissions as the
parent directory.

In case of error, we return -1. Otherwise, we return 1.

The function definition is:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
int create_dir(char *string, ...){
  char *current_string;
  va_list arguments;
  va_start(arguments, string);
  int err = 1;
  current_string = string;
  while(current_string != NULL && current_string[0] != '\0' && err != -1){
#if !defined(_WIN32)
    err = mkdir(current_string, S_IRWXU | S_IRWXG | S_IROTH);
#else
    if(!CreateDirectoryA(current_string, NULL))
      err = -1;
#endif
    current_string = va_arg(arguments, char *);
  }
  return err;
}
@
\fimcodigo

\subsecao{5.9. append\_file: Concatenate file contents}

This is an unusual function, it was designed to solve efficiently a
single use case, sacrificing the consistency of its interface and its
ease of use. It gets as argument a pointer for a target file already
opened (usually we want to use this function after we opened a file to
write the copyright notice), as second argument it gets the path of
parent directory of an origin file and as the third argument it gets
the origin file name.

Its definition is:

\iniciocodigo
@<Weaver Auxiliary Functions@>+=
int append_file(FILE *fp, char *dir, char *file){
  int block_size, bytes_read;
  char *buffer, *directory = ".";
  char *path = concatenate(dir, file, "");
  if(path == NULL) return 0;
  FILE *origin;
  @<Discover block size@>
  buffer = (char *) malloc(block_size);
  if(buffer == NULL){
    free(path);
    return 0;
  }
  origin = fopen(path, "r");
  if(origin == NULL){
    free(buffer);
    free(path);
    return 0;
  }
  while((bytes_read = fread(buffer, 1, block_size, origin)) > 0){
    fwrite(buffer, 1, bytes_read, fp);
  }
  fclose(origin);
  free(buffer);
  free(path);
  return 1;
}
@
\fimcodigo

\secao{6. Variable Initialization}

\subsecao{6.1. inside\_weaver\_directory e project\_path: Where we are}

The first variable is |inside_weaver_directory|, which stores |false|
if the program was invoked outside a Weaver project directory and
|true| otherwise.

How should we detect if we are in a Weaver project directory? It's
simple. They are directories which contains in them or in an ancestor
directory a hidden directory named \monoespaco{.weaver}. If we find
this directory, we can also adjust the variable |project_path| to
point to where is this directory. If we don't find it, we are outside
a Weaver directory and we don't need to change these variables default
value, which are |false| and |NULL|.

In short, we need a loop with the following characteristics:

\negrito{Invariant}: The variable |complete_path| must always store
the complete path of the directory \monoespaco{.weaver} if this
file hypothetically existed in the current directory.

\negrito{Initialization:} We initialize |complete_path| to be valid
when we are in or initial current directory.

\negrito{Maintenance:} In each iteration we check if we found a
termination condition. If not, we change to the current directory
parent, always updating the variables to keep valid the invariant.

\negrito{Termination}: We terminate the loop if one of the following
3 conditions occur:

a) |complete_path == "/.weaver"|: We can't go to a parent directory
because we are already in the root of the filesystem. It means that we
aren't in a Weaver directory.

b) |complete_path == "C:\\.weaver"|: In fact, the initial letter could
be ``D'', ``E'' or any other letter, not just ``C''. It also could be
``\\.weaver''. This means that we are in the root of a Windows
filesystem (the last case without a drive letter represents a network
directory) and we aren't in a Weaver directory.

c) |complete_path == "./.weaver"| and this file exists and is a
directory: In this case, we were inside a Weaver directory. We can
also update |project_path| to store the current path.

The initialization of these variables is then:

\iniciocodigo
@<Initialization@>=
char *path = NULL, *complete_path = NULL;
#if !defined(_WIN32)
path = getcwd(NULL, 0); // Unix
#else
{ // Windows
  DWORD bsize;
  bsize = GetCurrentDirectory(0, NULL);
  path = (char *) malloc(bsize);
  GetCurrentDirectory(bsize, path);
}
#endif
if(path == NULL) W_ERROR();
complete_path = concatenate(path, "/.weaver", "");
free(path);
if(complete_path == NULL) W_ERROR();
@
\fimcodigo

To get the current directory, we need the header:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#if !defined(_WIN32)
#include <unistd.h> // get_current_dir_name, getcwd, stat, chdir, getuid
#endif
@
\fimcodigo

Now we define the described loop:

\iniciocodigo
@<Initialization@>+=
{
  size_t tmp_size = strlen(complete_path);
  // Testa se chegamos ao fim:
  while(strcmp(complete_path, "/.weaver") &&
	strcmp(complete_path, "\\.weaver") &&
	strcmp(complete_path + 1, ":\\.weaver")){
    if(directory_exist(complete_path) == EXISTS_AND_IS_DIR){
      inside_weaver_directory = true;
      complete_path[strlen(complete_path) - 7] = '\0'; // Apaga o '.weaver'
      project_path = concatenate(complete_path, "");
      if(project_path == NULL){ free(complete_path); W_ERROR(); }
      break;
    }
    else{
      path_up(complete_path);
#ifdef __OpenBSD__
      strlcat(complete_path, "/.weaver", tmp_size);
#else
      strcat(complete_path, "/.weaver");
#endif
    }
  }
  free(complete_path);
}
@
\fimcodigo

We allocated memory to |project_path|, so in the end of program we
need to free this memory:

\iniciocodigo
@<Finishing@>=
if(project_path != NULL) free(project_path);
@
\fimcodigo

\subsecao{6.2. weaver\_version\_major e weaver\_version\_minor: Versão do Programa}

Para descobrirmos a versão atual do Weaver que temos, basta consultar
o valor presente na macro |VERSION|. Então, obtemos o número de versão
maior e menor que estão separados por um ponto (se existirem). Note
que se não houver um ponto no nome da versão, então ela é uma versão
de testes. Mesmo neste caso o código abaixo vai funcionar, pois a
função |atoi| iria retornar 0 nas duas invocações por encontrar
respectivamente uma string sem dígito algum e um fim de string sem
conteúdo:

\iniciocodigo
@<Initialization@>+=
{
  char *p = VERSION;
  while(*p != '.' && *p != '\0') p ++;
  if(*p == '.') p ++;
  weaver_version_major = atoi(VERSION);
  weaver_version_minor = atoi(p);
}
@
\fimcodigo

\subsecao{6.3. project\_version\_major e project\_version\_minor: Versão do Projeto}

Se estamos dentro de um projeto Weaver, temos que inicializar
informação sobre qual versão do Weaver foi usada para atualizá-lo pela
última vez. Isso pode ser obtido lendo o arquivo
\italico{.weaver/version} localizado dentro do diretório Weaver. Se não
estamos em um diretório Weaver, não precisamos inicializar tais
valores. O número de versão maior e menor é separado por um ponto.

\iniciocodigo
@<Initialization@>+=
if(inside_weaver_directory){
  FILE *fp;
  char *p, version[10];
  char *file_path = concatenate(project_path, ".weaver/version", "");
  if(file_path == NULL) W_ERROR();
  fp = fopen(file_path, "r");
  free(file_path);
  if(fp == NULL) W_ERROR();
  p = fgets(version, 10, fp);
  if(p == NULL){ fclose(fp); W_ERROR(); }
  while(*p != '.' && *p != '\0') p ++;
  if(*p == '.') p ++;
  project_version_major = atoi(version);
  project_version_minor = atoi(p);
  fclose(fp);
}
@
\fimcodigo

\subsecao{6.4. have\_arg, argument e argument2: Argumentos de Invocação}

Uma das variáveis mais fáceis e triviais de se inicializar. Basta
consultar |argc| e |argv|.

\iniciocodigo
@<Initialization@>+=
have_arg = (argc > 1);
if(have_arg) argument = argv[1];
if(argc > 2) argument2 = argv[2];
@
\fimcodigo

\subsecao{6.5. arg\_is\_path: Se argumento é diretório}

Agora temos que verificar se no caso de termos um argumento, se ele é
um caminho para um projeto Weaver existente ou não. Para isso,
checamos se ao concatenarmos \monoespaco{/.weaver} no argumento
encontramos o caminho de um diretório existente ou não.

\iniciocodigo
@<Initialization@>+=
if(have_arg){
  char *buffer = concatenate(argument, "/.weaver", "");
  if(buffer == NULL) W_ERROR();
  if(directory_exist(buffer) == EXISTS_AND_IS_DIR){
    arg_is_path = 1;
  }
  free(buffer);
}
@
\fimcodigo

\subsecao{6.6. shared\_dir: Onde arquivos estão instalados}

A variável |shared_dir| deverá conter onde estão os arquivos
compartilhados da instalação de Weaver. Tais arquivos são as próprias
bibliotecas a serem inseridas estaticamente e modelos de código
fonte. Se existir a macro passada durante a
compilação \monoespaco{WEAVER\_DIR}, este será o caminho em que estão
os arquivos. Caso contrário, assumiremos o valor padrão
de \monoespaco{/usr/local/share/weaver} em sistemas baseados em Unix e
o local apontado pela variável de ambiente ProgramFiles em ambientes
Windows.

@<Initialization@>+=
{
#ifdef WEAVER_DIR
  shared_dir = concatenate(WEAVER_DIR, "");
#else
#if !defined(_WIN32)
  shared_dir = concatenate("/usr/local/share/weaver/", ""); // Unix
#else
  { // Windows
    char *temp_buf = NULL;
    DWORD bsize = GetEnvironmentVariable("ProgramFiles", temp_buf, 0);
    temp_buf = (char *) malloc(bsize);
    GetEnvironmentVariable("ProgramFiles", temp_buf, bsize);
    shared_dir = concatenate(temp_buf, "\\weaver\\", "");
    free(temp_buf);
  }
#endif
#endif
  if(shared_dir == NULL) W_ERROR();
}
@
\fimcodigo

Com isso damos poder durante a compilação para determinar onde os
dados do motor Weaver serão armazenados no sistema. Algo mais comum de
ser alterado em sistemas Unix que no Windows, onde espera-se que os
programas sejam armazenados no mesmo lugar.

No Windows o código é mais longo principalmente por termos que
determinar manualmente o nome do local padrão de se armazenar os
programas. O endereço pode variar de acordo com o idioma do sistema,
com a unidade de volume em que ele está ou com o fato do programa ter
sido compilado em máquina com 32 ou 64 bits.

No fim do programa devemos desalocar a memória alocada para
|shared_dir|:

\iniciocodigo
@<Finishing@>+=
if(shared_dir != NULL) free(shared_dir);
@
\fimcodigo

\subsecao{6.7. arg\_is\_valid\_project: Se o argumento é um nome de projeto}

A próxima questão que deve ser averiguada é se o que recebemos como
argumento, caso haja argumento, pode ser o nome de um projeto Weaver
válido ou não. Para isso, três condições precisam ser
satisfeitas:

1) O nome base do projeto deve ser formado somente por caracteres
alfanuméricos e underline (embora uma barra possa aparecer para passar
o caminho completo de um projeto).

2) Não pode existir um arquivo com o mesmo nome do projeto no local
indicado para a criação.

3) O projeto não pode ter o nome de nenhum arquivo que costuma ficar
no diretório base de um projeto Weaver (como ``Makefile''). Do
contrário, na hora da compilação comandos como ``\monoespaco{gcc
game.c -o Makefile}'' poderiam ser executados e sobrescreveriam
arquivos importantes.

Para isso, usamos o seguinte código:

\iniciocodigo
@<Initialization@>+=
if(have_arg && !arg_is_path){
  char *buffer;
  char *base = basename(argument);
  int size = strlen(base);
  int i;
  // Checando caracteres inválidos no nome:
  for(i = 0; i < size; i ++){
    if(!isalnum(base[i]) && base[i] != '_'){
      goto NOT_VALID;
    }
  }
  // Checando se arquivo existe:
  if(directory_exist(argument) != DONT_EXIST){
    goto NOT_VALID;
  }
  // Checando se conflita com arquivos de compilação:
  buffer = concatenate(shared_dir, "project/", base, "");
  if(buffer == NULL) W_ERROR();
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID;
  }
  free(buffer);
  arg_is_valid_project = true;
}
NOT_VALID:
@
\fimcodigo

Para podermos checar se um caractere é alfanumérico, incluimos a
seguinte biblioteca:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#include <ctype.h> // isalnum
@
\fimcodigo

\subsecao{6.8. arg\_is\_valid\_module: Se o argumento pode ser um nome de módulo}

Checar se o argumento que recebemos pode ser um nome válido para um
módulo só faz sentido se estivermos dentro de um diretório Weaver e se
um argumento estiver sendo passado. Neste caso, o argumento é um nome
válido se ele contiver apenas caracteres alfanuméricos, underline e se
não existir no projeto um arquivo \monoespaco{.c} ou \monoespaco{.h}
em
\monoespaco{src/} que tenha o mesmo nome do argumento passado:

\iniciocodigo
@<Initialization@>+=
if(have_arg && inside_weaver_directory){
  char *buffer;
  int i, size;
  size = strlen(argument);
  // Checando caracteres inválidos no nome:
  for(i = 0; i < size; i ++){
    if(!isalnum(argument[i]) && argument[i] != '_'){
      goto NOT_VALID_MODULE;
    }
  }
  // Checando por conflito de nomes:
  buffer = concatenate(project_path, "src/", argument, ".c", "");
  if(buffer == NULL) W_ERROR();
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID_MODULE;
  }
  buffer[strlen(buffer) - 1] = 'h';
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID_MODULE;
  }
  free(buffer);
  arg_is_valid_module = true;
}
NOT_VALID_MODULE:
@
\fimcodigo

\subsecao{6.9. arg\_is\_valid\_plugin: Se o argumento pode ser um nome de plugin}

Para que um argumento seja um nome válido para plugin, ele deve ser
composto só por caracteres alfanuméricos ou underline e não existir no
diretório
\monoespaco{plugin} um arquivo com a extensão \monoespaco{.c} de mesmo
nome. Também precisamos estar naturalmente, em um diretório Weaver.

\iniciocodigo
@<Initialization@>+=
if(argument2 != NULL && inside_weaver_directory){
  int i, size;
  char *buffer;
  size = strlen(argument2);
  // Checando caracteres inválidos no nome:
  for(i = 0; i < size; i ++){
    if(!isalnum(argument2[i]) && argument2[i] != '_'){
      goto NOT_VALID_PLUGIN;
    }
  }
  // Checando se já existe plugin com mesmo nome:
  buffer = concatenate(project_path, "plugins/", argument2, ".c", "");
  if(buffer == NULL) W_ERROR();
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID_PLUGIN;
  }
  free(buffer);
  arg_is_valid_plugin = true;
}
NOT_VALID_PLUGIN:
@
\fimcodigo

\subsecao{6.10. arg\_is\_valid\_function: Se o argumento pode ser um nome de função de loop principal}

Para que essa variável seja verdadeira, é preciso existir um segundo
argumento e ele deve ser formado somente por caracteres alfanuméricos
ou underline. Além disso, o primeiro caractere precisa ser uma letra e
ele não pode ter o mesmo nome de alguma palavra reservada em C.

\iniciocodigo
@<Initialization@>+=
if(argument2 != NULL && inside_weaver_directory &&
   !strcmp(argument, "--loop")){
  int i, size;
  char *buffer;
  // Primeiro caractere não pode ser dígito
  if(isdigit(argument2[0]))
    goto NOT_VALID_FUNCTION;
  size = strlen(argument2);
  // Checando caracteres inválidos no nome:
  for(i = 0; i < size; i ++){
    if(!isalnum(argument2[i]) && argument2[i] != '_'){
      goto NOT_VALID_PLUGIN;
    }
  }
  // Checando se existem arquivos com o nome indicado:
  buffer = concatenate(project_path, "src/", argument2, ".c", "");
  if(buffer == NULL) W_ERROR();
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID_FUNCTION;
  }
  buffer[strlen(buffer)-1] = 'h';
  if(directory_exist(buffer) != DONT_EXIST){
    free(buffer);
    goto NOT_VALID_FUNCTION;
  }
  free(buffer);
  // Checando se recebemos como argumento uma palavra reservada em C:
  if(!strcmp(argument2, "auto") || !strcmp(argument2, "break") ||
     !strcmp(argument2, "case") || !strcmp(argument2, "char") ||
     !strcmp(argument2, "const") || !strcmp(argument2, "continue") ||
     !strcmp(argument2, "default") || !strcmp(argument2, "do") ||
     !strcmp(argument2, "int") || !strcmp(argument2, "long") ||
     !strcmp(argument2, "register") || !strcmp(argument2, "return") ||
     !strcmp(argument2, "short") || !strcmp(argument2, "signed") ||
     !strcmp(argument2, "sizeof") || !strcmp(argument2, "static") ||
     !strcmp(argument2, "struct") || !strcmp(argument2, "switch") ||
     !strcmp(argument2, "typedef") || !strcmp(argument2, "union") ||
     !strcmp(argument2, "unsigned") || !strcmp(argument2, "void") ||
     !strcmp(argument2, "volatile") || !strcmp(argument2, "while") ||
     !strcmp(argument2, "double") || !strcmp(argument2, "else") ||
     !strcmp(argument2, "enum") || !strcmp(argument2, "extern") ||
     !strcmp(argument2, "float") || !strcmp(argument2, "for") ||
     !strcmp(argument2, "goto") || !strcmp(argument2, "if"))
    goto NOT_VALID_FUNCTION;
  arg_is_valid_function = true;
}
NOT_VALID_FUNCTION:
@

\subsecao{6.11. author\_name: Nome do criador do código}

A variável |author_name| deve conter o nome do usuário que está
invocando o programa. Esta informação é útil para gerar uma mensagem
de Copyright nos arquivos de código fonte de novos módulos.

Isso será feito de maneira diferente em sistemas Unix e Windows. Em
sistemas Unix, começamos obtendo o seu UID. De posse dele, obtemos
todas as informações de login com um |getpwuid|. Se o usuário tiver
registrado um nome em \monoespaco{/etc/passwd}, obtemos tal nome na
estrutura retornada pela função. Caso contrário, assumiremos o login
como sendo o nome:

\iniciocodigo
@<Initialization@>+=
#if !defined(_WIN32)
{
  struct passwd *login;
  int size;
  char *string_to_copy;
  login = getpwuid(getuid()); // Obtém dados de usuário
  if(login == NULL) W_ERROR();
  size = strlen(login -> pw_gecos);
  if(size > 0)
    string_to_copy = login -> pw_gecos;
  else
    string_to_copy = login -> pw_name;
  size = strlen(string_to_copy);
  author_name = (char *) malloc(size + 1);
  if(author_name == NULL) W_ERROR();
#ifdef __OpenBSD__
  strlcpy(author_name, string_to_copy, size + 1);
#else
  strcpy(author_name, string_to_copy);
#endif
}
#endif
@
\fimcodigo

No Windows, o nome pode ser obtido com a função |GetUserNameExA|. Na
primeira invocação tentamos obter o tamanho do buffer necessário para
armazenarmos o nome e na segunda obtemos o nome em si. Em caso de
erro, usamos a função mais antiga |GetUserNameA| que vai retornar um
nome de usuário simples ao invés de tentar obter o nome completo, e
para isso alocamos um espaço para o maior nome de usuário válido no
sistema.

\iniciocodigo
@<Initialization@>+=
#if defined(_WIN32)
{
  int size = 0;
  GetUserNameExA(NameDisplay, author_name, &size);
  if(GetLastError() == ERROR_MORE_DATA){
    if(size == 0)
      size = 64;
    author_name = (char *) malloc(size);
    if(GetUserNameExA(NameDisplay, author_name, &size) == 0){
      size = UNLEN + 1;
      author_name = (char *) malloc(size);
      GetUserNameA(author_name, &size);
    }
  }
  else{
    size = UNLEN + 1;
    author_name = (char *) malloc(size);
    GetUserNameA(author_name, &size);
  }
}
#endif
@
\fimcodigo

Depois, precisaremos desalocar a memória ocupada por |author_name|:

\iniciocodigo
@<Finishing@>+=
if(author_name != NULL) free(author_name);
@
\fimcodigo

Para que o código funcione, devemos inserir uma biblioteca diferente
dependendo de estarmos em sistemas Unix (para
ter \monoespaco{getpwuid}) ou em sistemas Windows (para obtermos uma
enumeração com diferentes formatos de nomes):

@<Headers Included in Weaver Program@>=
#if !defined(_WIN32)
#include <pwd.h> // getpwuid
#else
#define SECURITY_WIN32
#include <Security.h>
#include <Lmcons.h>
#endif
@

\subsecao{6.12. project\_name: Nome do projeto}

Só faz sendido falarmos no nome do projeto se estivermos dentro de um
projeto Weaver. Neste caso, o nome do projeto pode ser encontrado em
um dos arquivos do diretório base de tal projeto em
\monoespaco{.weaver/name}:

\iniciocodigo
@<Initialization@>+=
if(inside_weaver_directory){
  FILE *fp;
  char *c;
#if !defined(_WIN32)
  char *filename = concatenate(project_path, ".weaver/name", "");
#else
  char *filename = concatenate(project_path, ".weaver\name", "");
#endif
  if(filename == NULL) W_ERROR();
  project_name = (char *) malloc(256);
  if(project_name == NULL){
    free(filename);
    W_ERROR();
  }
  fp = fopen(filename, "r");
  if(fp == NULL){
    free(filename);
    W_ERROR();
  }
  c = fgets(project_name, 256, fp);
  fclose(fp);
  free(filename);
  if(c == NULL) W_ERROR();
  project_name[strlen(project_name)-1] = '\0';
  project_name = realloc(project_name, strlen(project_name) + 1);
  if(project_name == NULL) W_ERROR();
}
@
\fimcodigo

Depois, precisaremos desalocar a memória ocupada por |project_name|:

\iniciocodigo
@<Finishing@>+=
if(project_name != NULL) free(project_name);
@
\fimcodigo

\subsecao{6.13. year: Ano atual}

O ano atual é trivial de descobrir usando a função |localtime|,
independente do sistema operacional:

\iniciocodigo
@<Initialization@>+=
{
  time_t current_time;
  struct tm *date;
  time(&current_time);
  date = localtime(&current_time);
  year = date -> tm_year + 1900;
}
@
\fimcodigo

O único pré-requisito é incluirmos antes a biblioteca com funções de
tempo:

\iniciocodigo
@<Headers Included in Weaver Program@>=
#include <time.h> // localtime, time
@
\fimcodigo

\secao{7. Casos de Uso}

\subsecao{7.1. Imprimir ajuda de criação de projeto}

O primeiro caso de uso sempre ocorre quando Weaver é invocado fora de
um diretório de projeto e a invocação é sem argumentos ou com
argumento \monoespaco{--help}. Nesse caso assumimos que o usuário não sabe
bem como usar o programa e imprimimos uma mensagem de ajuda. A mensagem
de ajuda terá uma forma semelhante a esta:

\alinhaverbatim
    .  .   You are outside a Weaver Directory.
   ./  \\.  The following command uses are available:
   \\\\  //
   \\\\()//  weaver
   .={}=.      Print this message and exits.
  / /`'\\ \\
  ` \\  / '  weaver PROJECT_NAME
     `'        Creates a new Weaver Directory with a new
               project.
\alinhanormal

O que é feito com o código abaixo:


\iniciocodigo
@<Use Case 1: Printing help (create project)@>=
if(!inside_weaver_directory && (!have_arg || !strcmp(argument, "--help"))){
  printf("    .  .     You are outside a Weaver Directory.\n"
  "   .|  |.    The following command uses are available:\n"
  "   ||  ||\n"
  "   \\\\()//  weaver\n"
  "   .={}=.      Print this message and exits.\n"
  "  / /`'\\ \\\n"
  "  ` \\  / '  weaver PROJECT_NAME\n"
  "     `'        Creates a new Weaver Directory with a new\n"
  "               project.\n");
  END();
}
@
\fimcodigo


\subsecao{7.2. Imprimir ajuda de gerenciamento}

O segundo caso de uso também é bastante simples. Ele é invocado quando
já estamos dentro de um projeto Weaver e invocamos Weaver sem
argumentos ou com um \monoespaco{--help}. Assumimos neste caso que o
usuário quer instruções sobre a criação de um novo módulo. A mensagem
que imprimiremos é semelhante à esta:

\alinhaverbatim
       \\              You are inside a Weaver Directory.
        \\______/      The following command uses are available:
        /\\____/\\
       / /\\__/\\ \\       weaver
    __/_/_/\\/\\_\\_\\___     Prints this message and exits.
      \\ \\ \\/\\/ / /
       \\ \\/__\\/ /       weaver NAME
        \\/____\\/          Creates NAME.c and NAME.h, updating
        /      \\          the Makefile and headers
       /
                          weaver --loop NAME
                           Creates a new main loop in a new file src/NAME.c

                          weaver --plugin NAME
                           Creates new plugin in plugin/NAME.c

                          weaver --shader NAME
                           Creates a new shader directory in shaders/
\alinhanormal

O que é obtido com o código:

\iniciocodigo
@<Use Case 2: Printing management help@>=
if(inside_weaver_directory && (!have_arg || !strcmp(argument, "--help"))){
  printf("       \\                You are inside a Weaver Directory.\n"
  "        \\______/        The following command uses are available:\n"
  "        /\\____/\\\n"
  "       / /\\__/\\ \\       weaver\n"
  "    __/_/_/\\/\\_\\_\\___     Prints this message and exits.\n"
  "      \\ \\ \\/\\/ / /\n"
  "       \\ \\/__\\/ /       weaver NAME\n"
  "        \\/____\\/          Creates NAME.c and NAME.h, updating\n"
  "        /      \\          the Makefile and headers\n"
  "       /\n"
  "                        weaver --loop NAME\n"
  "                         Creates a new main loop in a new file src/NAME.c\n\n"
  "                        weaver --plugin NAME\n"
  "                         Creates a new plugin in plugin/NAME.c\n\n"
  "                        weaver --shader NAME\n"
  "                         Creates a new shader directory in shaders/\n");
  END();
}
@
\fimcodigo

\subsecao{7.3. Mostrar a versão instalada de Weaver}

Um caso de uso ainda mais simples. Ocorrerá toda vez que o usuário
invocar Weaver com o argumento \monoespaco{--version}:

\iniciocodigo
@<Use Case 3: Print version@>=
if(have_arg && !strcmp(argument, "--version")){
  printf("Weaver\t%s\n", VERSION);
  END();
}
@
\fimcodigo

\subsecao{7.4. Atualizar projetos Weaver já existentes}

Este caso de uso ocorre quando o usuário passar como argumento para
Weaver um caminho absoluto ou relativo para um diretório Weaver
existente. Assumimos então que ele deseja atualizar o projeto passado
como argumento. Talvez o projeto tenha sido feito com uma versão muito
antiga do motor e ele deseja que ele passe a usar uma versão mais
nova da API.

Naturalmente, isso só será feito caso a versão de Weaver instalada
seja superior à versão do projeto ou se a versão de Weaver instalada
for uma versão instável para testes. Entende-se neste caso que o
usuário deseja testar a versão experimental de Weaver no projeto. Fora
isso, não é possível fazer \italico{downgrades} de projetos, passando
da versão 0.2 para 0.1, por exemplo.

Versões experimentais sempre são identificadas como tendo um nome
formado somente por caracteres alfabéticos. Versões estáveis serão
sempre formadas por um ou mais dígitos, um ponto e um ou mais dígitos
(o número de versão maior e menor). Como o número de versão é
interpretado com um |atoi|, isso significa que se estamos usando uma
versão experimental, então o número de versão maior e menor serão
sempre identificados como zero.

Projetos em versões experimentais de Weaver sempre serão atualizados,
independente da versão ser mais antiga ou mais nova.

Uma atualização consiste em copiar todos os arquivos que estão no
diretório de arquivos compartilhados Weaver dentro de
\monoespaco{project/src/weaver} para o diretório \monoespaco{src/weaver}
do projeto em questão. Para isso podemos contar com as funções de
cópia de arquivos definidos na seção de funções auxiliares.

\iniciocodigo
@<Use Case 4: Updating Weaver project@>=
if(arg_is_path){
  if((weaver_version_major == 0 && weaver_version_minor == 0) ||
     (weaver_version_major > project_version_major) ||
     (weaver_version_major == project_version_major &&
      weaver_version_minor > project_version_minor)){
    char *buffer, *buffer2;
    // |buffer| <- SHARED_DIR/project/src/weaver
    buffer = concatenate(shared_dir, "project/src/weaver/", "");
    if(buffer == NULL) W_ERROR();
    // |buffer2| <- PROJECT_DIR/src/weaver/
    buffer2 = concatenate(argument, "/src/weaver/", "");
    if(buffer2 == NULL){
      free(buffer);
      W_ERROR();
    }
    if(copy_files(buffer, buffer2) == 0){
      free(buffer);
      free(buffer2);
      W_ERROR();
    }
    free(buffer);
    free(buffer2);
  }
  END();
}
@
\fimcodigo

\subsecao{7.5. Adicionando um módulo ao projeto Weaver}

Se estamos dentro de um diretório de projeto Weaver, e o programa
recebeu um argumento, então estamos inserindo um novo módulo no nosso
jogo. Se o argumento é um nome válido, podemos fazer isso. Caso
contrário,devemos imprimir uma mensagem de erro e sair.

Criar um módulo basicamente envolve:


a) Criar arquivos \monoespaco{.c} e \monoespaco{.h} base, deixando seus
nomes iguais ao nome do módulo criado.

b) Adicionar em ambos um código com copyright e licenciamento com o
nome do autor, do projeto e ano.

c) Adicionar no \monoespaco{.h} código de macro simples para evitar que
o cabeçalho seja inserido mais de uma vez e fazer com que o
\monoespaco{.c} inclua o \monoespaco{.h} dentro de si.

d) Fazer com que o \monoespaco{.h} gerado seja inserido
em \monoespaco{src/includes.h} e assim suas estruturas sejam
acessíveis de todos os outros módulos do jogo.

O código para isso é:

\iniciocodigo
@<Use Case 5: Create new module@>=
if(inside_weaver_directory && have_arg &&
   strcmp(argument, "--plugin") && strcmp(argument, "--shader") &&
   strcmp(argument, "--loop")){
  if(arg_is_valid_module){
    char *filename;
    FILE *fp;
    // Criando modulo.c
    filename = concatenate(project_path, "src/", argument, ".c", "");
    if(filename == NULL) W_ERROR();
    fp = fopen(filename, "w");
    if(fp == NULL){
      free(filename);
      W_ERROR();
    }
    write_copyright(fp, author_name, project_name, year);
    fprintf(fp, "#include \"%s.h\"", argument);
    fclose(fp);
    filename[strlen(filename)-1] = 'h'; // Criando modulo.h
    fp = fopen(filename, "w");
    if(fp == NULL){
      free(filename);
      W_ERROR();
    }
    write_copyright(fp, author_name, project_name, year);
    fprintf(fp, "#ifndef _%s_h_\n", argument);
    fprintf(fp, "#define _%s_h_\n\n#include \"weaver/weaver.h\"\n",
            argument);
    fprintf(fp, "#include \"includes.h\"\n\n#endif");
    fclose(fp);
    free(filename);

    // Atualizando src/includes.h para inserir modulo.h:
    fp = fopen("src/includes.h", "a");
    fprintf(fp, "#include \"%s.h\"\n", argument);
    fclose(fp);
  }
  else{
    fprintf(stderr, "ERROR: This module name is invalid.\n");
    return_value = 1;
  }
  END();
}
@
\fimcodigo

\subsecao{7.6. Criar novo projeto}

Criar um novo projeto Weaver consiste em criar um novo diretório com o
nome do projeto, copiar para lá tudo o que está no diretório
\monoespaco{project} do diretório de arquivos compartilhados e criar um
diretório \monoespaco{.weaver} com os dados do projeto. Além disso,
criamos um \monoespaco{src/game.c} e \monoespaco{src/game.h} adicionando o
comentário de Copyright neles e copiando a estrutura básica dos
arquivos do diretório compartilhado \monoespaco{basefile.c} e
\monoespaco{basefile.h}. Também criamos um
\monoespaco{src/includes.h} que por hora estará vazio, mas será modificado
na criação de futuros módulos.

\iniciocodigo
@<Use Case 6: Create new project@>=
if(! inside_weaver_directory && have_arg){
  if(arg_is_valid_project){
    int err;
    char *dir_name;
    FILE *fp;
    err = create_dir(argument, NULL);
    if(err == -1) W_ERROR();
#if !defined(_WIN32) //cd
    err = chdir(argument);
#else
    err = _chdir(argument);
#endif
    if(err == -1) W_ERROR();
    err = create_dir(".weaver", "conf", "tex", "src", "src/weaver",
                     "fonts", "image", "sound", "models", "music",
                     "plugins", "src/misc", "src/misc/sqlite",
                     "compiled_plugins", "shaders", "");
    if(err == -1) W_ERROR();
    dir_name = concatenate(shared_dir, "project", "");
    if(dir_name == NULL) W_ERROR();
    if(copy_files(dir_name, ".") == 0){
      free(dir_name);
      W_ERROR();
    }
    free(dir_name); //Criando arquivo com número de versão:
    fp = fopen(".weaver/version", "w");
    fprintf(fp, "%s\n", VERSION);
    fclose(fp); // Criando arquivo com nome de projeto:
    fp = fopen(".weaver/name", "w");
    fprintf(fp, "%s\n", basename(argv[1]));
    fclose(fp);
    fp = fopen("src/game.c", "w");
    if(fp == NULL) W_ERROR();
    write_copyright(fp, author_name, argument, year);
    if(append_file(fp, shared_dir, "basefile.c") == 0) W_ERROR();
    fclose(fp);
    fp = fopen("src/game.h", "w");
    if(fp == NULL) W_ERROR();
    write_copyright(fp, author_name, argument, year);
    if(append_file(fp, shared_dir, "basefile.h") == 0) W_ERROR();
    fclose(fp);
    fp = fopen("src/includes.h", "w");
    write_copyright(fp, author_name, argument, year);
    fprintf(fp, "\n#include \"weaver/weaver.h\"\n");
    fprintf(fp, "\n#include \"game.h\"\n");
    fclose(fp);
  }
  else{
    fprintf(stderr, "ERROR: %s is not a valid project name.", argument);
    return_value = 1;
  }
  END();
}
@
\fimcodigo

\subsecao{7.7. Criar novo plugin}

Este aso de uso é invocado quando temos dois argumentos, o primeiro é
|"--plugin"| e o segundo é o nome de um novo plugin, o qual deve ser
um nome único, sem conflitar com qualquer outro dentro de
\monoespaco{plugins/}. Devemos estar em um diretório Weaver para fazer
isso.

\iniciocodigo
@<Use Case 7: Create new plugin@>=
if(inside_weaver_directory && have_arg && !strcmp(argument, "--plugin") &&
   arg_is_valid_plugin){
  char *buffer;
  FILE *fp;
  /* Criando o arquivo: */
  buffer = concatenate("plugins/", argument2, ".c", "");
  if(buffer == NULL) W_ERROR();
  fp = fopen(buffer, "w");
  if(fp == NULL) W_ERROR();
  write_copyright(fp, author_name, project_name, year);
  fprintf(fp, "#include \"../src/weaver/weaver.h\"\n\n");
  fprintf(fp, "void _init_plugin_%s(W_PLUGIN){\n\n}\n\n", argument2);
  fprintf(fp, "void _fini_plugin_%s(W_PLUGIN){\n\n}\n\n", argument2);
  fprintf(fp, "void _run_plugin_%s(W_PLUGIN){\n\n}\n\n", argument2);
  fprintf(fp, "void _enable_plugin_%s(W_PLUGIN){\n\n}\n\n", argument2);
  fprintf(fp, "void _disable_plugin_%s(W_PLUGIN){\n\n}\n", argument2);
  fclose(fp);
  free(buffer);
  END();
}
@
\fimcodigo

\subsecao{7.8. Criar novo shader}

Este caso de uso é similar ao anterior, mas possui algumas
diferenças. Todo shader será um novo arquivo no formato GLSL dentro do
diretório \monoespaco{shaders}. E além disso, seu nome terá sempre o
formato dado pela expressão regular \monoespaco{[0-9][0-9]*-.*}. O(s)
dígito(s) na primeira parte do nome deve ser único para cada shader de
um mesmo projeto. E os números representados por tais dígitos devem
ser sempre sequenciais, começando no 1 e incrementando-o a cada novo
shader.

Este caso de uso será invocado somente quando o nosso primeiro
argumento for |``--shader''| e o segundo for um nome qualquer. Não
precisamos realmente forçar uma restrição nos nomes dos shaders, pois
sua convenção numérica garante que cada um terá um nome único e
não-conflitante.

Para garantir isso, o código deverá contar quantos arquivos com
extensão GLSL existem no diretório dos shaders e criar um novo shader
com nome \monoespaco{DD-XX.glsl}, onde \monoespaco{DD} é o número de
arquivos que existia mais 1 e \monoespaco{XX} é o nome escolhido
passado como segundo argumento para o programa. Mas se existirem
lacunas na numeração de shaders, por exemplo existir um shader 1 e um
3 sem existir o 2, daremos preferência para cobrir a lacuna. O
conteúdo base de um shader será obtido de um arquivo onde o programa
Weaver está instalado.

Depois de descobrir a numeração do novo shader, basta criarmos ele
como um arquivo vazio e depois copiarmos o conteúdo de um modelo já
existente em nosso diretório de instalação.

O código deste caso de uso é então:

\iniciocodigo
@<Use Case 8: Create new shader@>=
if(inside_weaver_directory && have_arg && !strcmp(argument, "--shader") &&
   argument2 != NULL){
    FILE *fp;
    size_t tmp_size, number = 0;
    int shader_number;
    char *buffer;
    @<Shader: Conta número de arquivos e obtém número do shader@>
    // Criando o shader:
    tmp_size = number / 10 + 7 + strlen(argument2);
    buffer = (char *) malloc(tmp_size);
    if(buffer == NULL) W_ERROR();
    buffer[0] = '\0';
    snprintf(buffer, tmp_size, "%d-%s.glsl", (int) number, argument2);
    fp = fopen(buffer, "w");
    if(fp == NULL){
        free(buffer);
        W_ERROR();
    }
    if(append_file(fp, shared_dir, "shader.glsl") == 0) W_ERROR();
    fclose(fp);
    free(buffer);
    END();
}
@
\fimcodigo

A parte de contar onter o número do novo shader ocorre de maneira
diferente no Unix e no Windows devido à API diferente para lidar com o
sistema de arquivos. Tirando as particularidades de como iterar sobre
arquivos em um diretório, o que faremos é iterar em cada arquivo no
diretório \monoespaco{shaders} de nosso projeto que não seja um
diretório, tenha extensão GLSL e tenha seu nome começado com um número
positivo. Chamaremos tal número de \monoespaco{number}. Teremos um
vetor booleano inicialmente marcado inteiramente como falso. Ao chegar
em cada um destes arquivos, marcamos no vetor booleano a informação de
que o shader de número \monoespaco{number} existe colocando o valor
verdadeiro na posição do vetor reservada para ele. Depois de iterarmos
sobre cada um dos arquivos, acharemos a primeira posição do vetor que
ainda está marcada como falsa. Sua posição indica qual número de shadr
ainda não foi usado e é o número que escolheremos.

Complexidades adicionais neste código envolvem apenas tomarmos o
cuidado para que o nosso vetor booleano sempre tenha um tamanho
adequado. Para isso tentamos alocar ele inicialmente com 128 espaços,
mas se acharmos shaders com números altos o bastante, o realocaremos
para lidar com o número maior.

O código para isso no Linux será:

\iniciocodigo
@<Shader: Conta número de arquivos e obtém número do shader@>=
#if !defined(_WIN32)
{
  size_t i, max_number = 0;
  DIR *shader_dir;
  struct dirent *dp;
  char *p;
  bool *exists;
  size_t exists_size = 128;
  shader_dir = opendir("shaders/");
  if(shader_dir == NULL)
    W_ERROR();
  exists = (bool *) malloc(sizeof(bool) * exists_size);
  if(exists == NULL){
    closedir(shader_dir);
    W_ERROR();
  }
  for(i = 0; i < exists_size; i ++)
    exists[i] = false;
  while((dp = readdir(shader_dir)) != NULL){
    if(dp -> d_name == NULL) continue;
    if(dp -> d_name[0] == '.') continue;
    if(dp -> d_name[0] == '\0') continue;
    buffer = concatenate("shaders/", dp -> d_name, "");
    if(buffer == NULL) W_ERROR();
    if(directory_exist(buffer) != EXISTS_AND_IS_FILE){
      free(buffer);
      continue;
    }
    for(p = buffer; *p != '\0'; p ++);
    p -= 5;
    if(strcmp(p, ".glsl") && strcmp(p, ".GLSL")){
      free(buffer);
      continue;
    }
    number = atoi(buffer);
    if(number == 0){
      free(buffer);
      continue;
    }
    if(number > max_number)
      max_number = number;
    if(number > exists_size){
      if(number > exists_size * 2)
        exists_size = number;
      else
        exists_size *= 2;
      exists = (bool *) realloc(exists, exists_size * sizeof(bool));
      if(exists == NULL){
        free(buffer);
        closedir(shader_dir);
        W_ERROR();
      }
      for(i = exists_size / 2; i < exists_size; i ++)
        exists[i] = false;
    }
    exists[number - 1] = true;
    free(buffer);
  }
  closedir(shader_dir);
  for(i = 0; i <= max_number; i ++)
    if(exists[i] == false){
      shader_number = i + 1;
      break;
    }
  free(exists);
}
#endif
@
\fimcodigo

No Windows, o código para iterar sobre arquivos é diferente, mas o
restante não muda:

\iniciocodigo
@<Shader: Conta número de arquivos e obtém número do shader@>=
#if defined(_WIN32)
{
  int i;
  char *p;
  bool *exists;
  size_t exists_size = 128;
  int number, max_number = 0;
  WIN32_FIND_DATA file;
  HANDLE shader_dir = NULL;
  shader_dir = FindFirstFile("shaders\\", &file);
  if(shader_dir == INVALID_HANDLE_VALUE)
    W_ERROR();
  exists = (bool *) malloc(sizeof(bool) * exists_size);
  if(exists == NULL){
    FindClose(shader_dir);
    W_ERROR();
  }
  for(i = 0; i < exists_size; i ++)
    exists[i] = false;
  do{
    if(file.cFileName == NULL) continue;
    if(file.cFileName[0] == '.') continue;
    if(file.cFileName[0] == '\0') continue;
    buffer = concatenate("shaders\\", file.cFileName, "");
    if(buffer == NULL) W_ERROR();
    if(directory_exist(buffer) != EXISTS_AND_IS_FILE){
      free(buffer);
      continue;
    }
    for(p = buffer; *p != '\0'; p ++);
    p -= 5;
    if(strcmp(p, ".glsl") && strcmp(p, ".GLSL")){
      free(buffer);
      continue;
    }
    number = atoi(buffer);
    if(number == 0){
      free(buffer);
      continue;
    }
    if(number > max_number)
      max_number = number;
    if(number > exists_size){
      if(number > exists_size * 2)
        exists_size = number;
      else
        exists_size *= 2;
      exists = (bool *) realloc(exists, exists_size * sizeof(bool));
      if(exists == NULL){
        free(buffer);
        FindClose(shader_dir);
        W_ERROR();
      }
      for(i = exists_size / 2; i < exists_size; i ++)
        exists[i] = false;
    }
    exists[number - 1] = true;
    free(buffer);
  }while(FindNextFile(shader_dir, &file) != 0);
  FindClose(shader_dir);
  for(i = 0; i <= max_number; i ++)
  if(exists[i] == false){
    shader_number = i + 1;
    break;
  }
  free(exists);
}
#endif
@
\fimcodigo

\subsecao{7.9. Criar novo loop principal}

Este caso de uso ocorre quando o segundo argumento é
\monoespaco{--loop} e quando o próximo argumento for um nome válido
para uma função. Se não for, imprimimos uma mensagem de erro para
avisar.

Neste caso não podemos apenas copiar o conteúdo de um arquivo base
para formar o arquivo com um novo módulo do projeto Weaver, pois esse
novo arquivo terá definida uma função com um nome fornecido pelo
usuário. Então apenas criamos e preenchemos o arquivo na hora com
conteúdo defiido no próprio código abaixo.

\iniciocodigo
@<Use Case 9: Create new main loop@>=
if(inside_weaver_directory && !strcmp(argument, "--loop")){
  if(!arg_is_valid_function){
    if(argument2 == NULL)
      fprintf(stderr,
              "ERROR: You should pass a name for your new loop.\n");
    else
      fprintf(stderr, "ERROR: %s not a valid loop name.\n", argument2);
    W_ERROR();
  }
  char *filename;
  FILE *fp;
  // Criando LOOP_NAME.c
  filename = concatenate(project_path, "src/", argument2, ".c", "");
  if(filename == NULL) W_ERROR();
  fp = fopen(filename, "w");
  if(fp == NULL){
    free(filename);
    W_ERROR();
  }
  write_copyright(fp, author_name, project_name, year);
  fprintf(fp, "#include \"%s.h\"\n\n", argument2);
  fprintf(fp, "MAIN_LOOP %s(void){\n", argument2);
  fprintf(fp, " LOOP_INIT:\n\n");
  fprintf(fp, " LOOP_BODY:\n");
  fprintf(fp, "  if(W.keyboard[W_ANY])\n");
  fprintf(fp, "    Wexit_loop();\n");
  fprintf(fp, " LOOP_END:\n");
  fprintf(fp, "  return;\n");
  fprintf(fp, "}\n");
  fclose(fp);
  // Criando LOOP_NAME.h
  filename[strlen(filename)-1] = 'h';
  fp = fopen(filename, "w");
  if(fp == NULL){
    free(filename);
    W_ERROR();
  }
  write_copyright(fp, author_name, project_name, year);
  fprintf(fp, "#ifndef _%s_h_\n", argument2);
  fprintf(fp, "#define _%s_h_\n#include \"weaver/weaver.h\"\n\n", argument2);
  fprintf(fp, "#include \"includes.h\"\n\n");
  fprintf(fp, "MAIN_LOOP %s(void);\n\n", argument2);
  fprintf(fp, "#endif\n");
  fclose(fp);
  free(filename);
  // Atualizando src/includes.h
  fp = fopen("src/includes.h", "a");
  fprintf(fp, "#include \"%s.h\"\n", argument2);
  fclose(fp);  
}
@
\fimcodigo

\secao{8. Conclusão}

Isso finaliza todo o código necessário para que o programa Weaver
possa gerenciar projetos de jogos feitos com o motor Weaver.

O programa apresentado aqui ainda não representa todo o gerenciamento
de um projeto. Uma parte não retratada aqui é um instalador que em
sistemas Unix é representado por um \monoespaco{Makefile} responsável
por instalar o motor Weaver no local adequado e em sistemas Windows
tem a forma de um pacote MSIX.

Além disso, o código das bibliotecas em si também fazem parte do motor
Weaver, mas terão o seu código descrito em outros artigos.

Alguns códigos como o código-base para shaders e novos projetos podem
ser encontrados junto com o código-fonte de Weaver, no
diretório \monoespaco{project}.

Por fim, em sistemas Unix há um Makefile para cada projeto, que também
realiza muito do desenvolvimento. No Windows, se utiliza-se o Visual
Studio ao invés de ferramentas Unix, esta parte do gerenciamento será
feita por um conjunto de regras.

\fim
