\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver Memory Manager}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article describes using literary programming a memory
manager written for Weaver Game Engine. It aims to be a very simple
and fast memory manager for programs where memory is allocated and
freed in a stack-based order and we know the maximum ammount of memory
that the program will need. It allows users creating markings during
the program execution that after allows them to free at once all the
memory allocated after the last marking. After the memory manager
creation, we also run some benchmarks comparing its performance
against malloc from standard library running at Linux, Windows and
in a web browser using Web Assembly.}


\secao{1. Introduction}

\subsecao{1.1. Memory Managers in Game Engines}

Many game engines run custom memory managers instead of using the
system's library to obtain more memory dinamically. According with
[Gregory 2019], this happens because implementations
like \italico{malloc} and \italico{free} could be relatively slow when
used in games compared with custom memory managers. Custom memory
managers also can deal with memory fragmentation.

Gregory identifies five design pattern for managing memory in games:

\negrito{Stack-based Allocators:} These allocators always return sequential
regions of memory and deallocations must happen in reverse order than
allocation. The implementation is very simple and it is easy to ensure
spatial locality of used memory regions. All the memory allocatyed
since some specific time of execution could be rapidly deallocated
with a single function call.

\negrito{Pool Allocators:} This technique can be used when we know that we
will need at most $n$ elements, all with the same size. We can
allocate previously the memory for these elements and keep their
memory region always at disposal using variables to store when a given
region is occupied by an element and when we can treat it as free
memory.

\negrito{Alligned Allocations:} Different types of data and computer architectures
can have different alignment restrictions for
memory. In \itelico{Playstation 3}, for example, any memory position
passed using DMA (\italico{Direct Memory Access}) must be 128-bit
aligned. This means that its address must be a multiple of 128 bits.

\negrito{Single Frame and Double-Buffered Memory Allocators:} A game engine
runs all its computations in frames, and in each frame a new image is
sent to the screen. Some allocated variables must have a lifetime of
only one or two frames, and could be deallocated automatically after
this time.

\negrito{Memory Defragmenter:} When memory is allocated and freed
in unpredictable order, small unused memory regions could
accumulate. Sometimes they are too small to be useful, and they are
many and so they waste considerable ammounts of memory. To avoid this,
instead ofusing pointers for allocated objects, we could use indexes
which indentifies the pointers. This way, allocated memory could be
moved incrementally and peridically to avoid fragmentation and their
pointers can be updated.

This article objective is to define a stack-based allocator with
support for memory alignment and which can store two stacks in its
memory region. Manage which stack to use is user's
responsability. This technique is described in [Ranck, 2000] which
shows how it was used in the game \italico{Hydro Thunder} made
by \italico{Midway}.

Pool allocators won't be supported here, but they can easily be built
using the allocator defined here. The fragmentation problem also won't
be addressed, as stack-based allocators usually do not have memory
fragmentation when correctly used.

\subsecao{1.2. Executon Environments}

In this article we will focus in creating functions which to run in
four different environments: Windows 10, MacOS Sierra, Linux and Web
Assembly. The three first are operating systems for personal
computers. Thelast one is a virtual machine specification specialized
in run a optimized subset of javascript. It permits the execution of
complex computer programs in environments like web browsers. Its
development started as a method proposed by [Zakai, 2011] who
presented a novel way to compile code in C and C++ for javascript with
advanced optimization techniques.

To develop portable code in all four environments, we will use
conditional macros and different methods of obtaining memory in all
different systems will be compared.

\subsecao{1.3. Literary Programming and this Article Notation}

This article utilizes the technique of ``Literary Programming'' in the
development of the memory manager. This technique was presented in
[Knuth, 1984] and consists in a philosophy of software development
where the programmer develop the software writting and explaining
didatically all the necessary code, focusing in writting a clear
explanation for people reading the explanation. Automatic tools are
employed to extract the code from the explanation, change the order of
the code when necessary and produce an executable program from the
extracted code.

For example, in this article will be defined two different files:
\monoespaco{memory.c} and \monoespaco{memory.h}, both could be statically
included in any project, or compiled as a shared library. What the file
\monoespaco{memory.h} contains is:

\iniciocodigo
@(src/memory.h@>=
#ifndef WEAVER_MEMORY_MANAGER
#define WEAVER_MEMORY_MANAGER
#ifdef __cplusplus
extern "C" {
#endif
@<Memory Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are security macros to avoid that
functions and variables declared there be included more than once,
even if an user includes this header file more than once using include
macros. The other lines contains macros to check if we are compiling
using C++ instead of C. In this case we declare all functions in this
file as C style functions to warn the compiler that they are not
modifiable by operator overloading and because of this is not
necessary to store additional information besides the function name to
recognize them.

In the code above, we use the red letters to indicate that in the
future we will insert new code there called ``Memory Declarations'',
with all the necessary function declaraions. Searching in this
article, you can find in the next pages another pieces of code where
the title is not \monoespaco{memory.h} as above, but ``Memory
Declarations''. These pieces of code will be inserted in the code
above. And could be more than one piece of code with he same title. In
this case, to produce functional code for the compiler, we should
concatenate all these pieces of code with the same title and put in
the part marked as red in the source code. his allow us to introduce
function declarations as we explain them in the article, not needing
to declare all them once just because they are part of the same piece
of code.

\subsecao{1.4. Functions to be Defined}

Our memory manager will define a total of 6 new functions. The first
one receives a size in bytes and return a new contiguous region of
memory to be managed. We call this region a ``arena'':

\iniciocodigo
@<Memory Declarations@>=
#include <stdlib.h> // Include 'size_t'
void *Wcreate_arena(size_t size);
@
\fimcodigo

The second function receives an arena created by the first function
and free all the reserved memory. If that arena had not deallocated
elements, we return false (a program could print a warning to the user
if the function return false) and otherwise the function returns true:

\iniciocodigo
@<Memory Declarations@>+=
#include <stdbool.h> // Include 'bool'
bool Wdestroy_arena(void *);
@
\fimcodigo

The third one is equivalent to \monoespaco{malloc} and receives an
arena, a number which should be a power of two or zero representing a
bit alignment which should be respected, another number which selects
if we should allocate in ther left (0) or right (1) stack, and finally
a size in bytes. The function always returns an address multiple of
the alignment if a power of two was passed. And it
returns \monoespaco{NULL} in case of no enough memory in the arena:

\iniciocodigo
@<Memory Declarations@>+=
void *Walloc(void *arena, unsigned alignment, int right, size_t size);
@
\fimcodigo

The fourth function puts a marking, which we will call ``memory
point'' in our arena. This marking can be used to determine which
allocations happened before and after the marking. The last argument
also selects if we should put the marking in the left (0) or right (1)
stack. We also specify an aligment like in the previous allocation
function. The function returns if this was sucessful or not:

\iniciocodigo
@<Memory Declarations@>+=
bool Wmempoint(void *arena, unsigned alignment, int region);
@
\fimcodigo

The last function use the marking of the previous function and
deallocate all the allocated memory since the last marking was
created. It receives a flag to know if this should be done with the
left (0) or right (1) stack.

\iniciocodigo
@<Memory Declarations@>+=
void Wtrash(void *arena, int region);
@
\fimcodigo

\secao{2. Implementation}

\subsecao{2.1. Obtaining a Beginning Region of Memory}

In a general purpose memory manager we don't need to know the maximum
ammount of memory needed in our program. But in a game memory manager,
it is essential to estabilish a maximum limit for memory usage. In
this case we are more interested in ensuring a continuous performance
instead of getting a precise result for some computation. We want to
avoid at all costs the subit performance decrease when a supported
machine don't have more memory and needs to use memory swap. In some
architectures, we do not even have a disk to use swap memory and
consuming all RAM can make the game crash. Because of this, in games
we can allocate during initialization the maximum ammount of needed
memory and never use more memory than what was allocated in this
moment.

How we obtain this initial memory varies according with the execution
environment. We could use a simple \monoespaco{malloc} for this, but
we will prefer alternatives with less waste of memory. Ideally a
function which returns a raw region of memory, without aditional
informations or data structures.

Both in Unix systems (Linux, OpenBSD, MacOS) as in Web Assembly
compiled usng Emscripten, the more economical choice is
using \monoespaco{mmap}. It is a very customizable function which can
map to memory anithing, from disk files to new allocated regions.

To use  \monoespaco{mmap}, we need the following headers:

\iniciocodigo
@<Incluir Cabeçalhos Necessários@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
#include <sys/mman.h>
#endif
@
\fimcodigo

After defining the headers, to allocate a region of $M$ bytes not
associated with any file, which can be read and written, we invoke the
function with the following arguments:

\iniciocodigo
@<Allocate in 'arena' region of 'M' bytes@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
arena = mmap(NULL, M, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON,
             -1, 0);
#endif
@
\fimcodigo

The null, zero and -1 arguments are just the ones not necessary in
this usage of \monoespaco{mmap}.

As we can create a new region of memory, we can also destroy that
region, deallocating it. In this case, we should
use \monoespaco{munmap}:

\iniciocodigo
@<Deallocate 'arena' of size 'M' bytes@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
munmap(arena, M);
#endif
@
\fimcodigo

In Windows environments, the equivalent function is 
\monoespaco{CreateFileMapping}, with the difference that it returns
a handle which needs another function to give us a pointer to the
allocated region. Fortunately, according with Windows API
documentation, we can close that handle with \monoespaco{CloseHandle}
before deallocate and undo the reserver region. Thanks for this, we
can keep the simmetry between Windows and other platform's code, as we
can close the handle in this code without needing to memorize it in
some additional structure:

\iniciocodigo
@<Allocate in 'arena' region of 'M' bytes@>+=
#if defined(_WIN32)
{
  HANDLE handle;
  handle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
                              PAGE_READWRITE,
                              (DWORD) ((DWORDLONG) M) / ((DWORDLONG) 4294967296),
                              (DWORD) ((DWORDLONG) M) % ((DWORDLONG) 4294967296),
                              NULL);
  arena = MapViewOfFile(handle, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
  CloseHandle(handle);
}
#endif
@
\fimcodigo


To deallocate the region in Windows, we
use \monoespaco{UnmapViewOfFile}:

\iniciocodigo
@<Deallocate 'arena' of size 'M' bytes@>+=
#if defined(_WIN32)
UnmapViewOfFile(arena);
#endif
@
\fimcodigo

Using the previous functions require the following headers:

\iniciocodigo
@<Include Headers@>+=
#if defined(_WIN32)
#include <windows.h>  // Include 'CreateFileMapping', 'MapViewOfFIle',
#include <memoryapi.h> // 'UnmapViewOfFile', 'CloseHandle'
#endif
@
\fimcodigo

\subsecao{2.2. Obtaining Page Size}

In a real computer, contrasting with some virtual machines, when a
program asks for memory for the Operating System, it always receive
memory in multiples of the page size used internally by the
machine. Tipically the page size is 4 KiB. In this case, it's useless
asking for non-multiples of KiB. If we ask for just 2 KiB, we keep
receiving 4 KiB. If we ask for 5 KiB, we receive 8KiB.

It's important that in these environments, our memory manager be aware
of this and even if the user asks for a non-multiple of page size
ammount of memory, it always should adjust the requested size for a
multiple of page size, avoiding the waste of memory.

In the majority of Unix systems, if they are POSIX compatible, we can
get the page size using the function \monoespaco{sysconf}:

\iniciocodigo
@<Get page size `p'@>=
#if defined(__unix__)
p = sysconf(_SC_PAGESIZE);
#endif
@
\fimcodigo

In MacOS, while its documentation says that the system is POSIX
compatible, it also recommends using the BSD
function \monoespaco{getpagesize} to get this information. So to
follow the documentation guidelines, we use this code:

\iniciocodigo
@<Get page size `p'@>+=
#if defined(__APPLE__)
p = getpagesize();
#endif
@
\fimcodigo

Both the BSD function as the POSIX function are defined in the same header:

\iniciocodigo
@<Include Headers@>+=
#if defined(__APPLE__) || defined(__unix__)
#include <unistd.h>
#endif
@
\fimcodigo

In Windows, we can get the page size using the more
complex \monoespaco{GetSystemInfo}, which also returns a series of
additional information about the system, which we don't need to keep
at the moment.

\iniciocodigo
@<Get page size `p'@>+=
#if defined(_WIN32)
{
  SYSTEM_INFO info;
  GetSystemInfo(&info);
  p = info.dwPageSize;
}
#endif
@
\fimcodigo

To use this function, the documentation recommends to include
directly \monoespaco{windows.h} header:

\iniciocodigo
@<Include Headers@>+=
#if defined(_WIN32)
#include <windows.h> // Include 'GetSystemInfo'
#endif
@
\fimcodigo

Finally the Web Assembly environment. Here the dynamically allocated
memory is obtained from a contiguous region of memory which starts
with a fixed size and can grow calling the
operator \monoespaco{grow\_memory}, which also is configured with a
maximum size. Anyway, here the memory is also allocaten in multiples
of a fixed value. But the value is always 64 KiB:

\iniciocodigo
@<Get page size `p'@>+=
#if defined(__EMSCRIPTEN__)
p = 64 * 1024; // 64 KiB
#endif
@
\fimcodigo

\subsecao{2.3. Running in Multiple Threads}

It's important to ensure that he code defined here works even when
invoked simultaneously in different parts of code. For this we will
need mutexes to ensure that the same region of memory won't be
accessed by more than one thread at same time. If more than one thread
wants toallocate memory, probably will be more efficient give to each
one its own arena to avoid that each thread block the others in the
process.

Not all environments supports threads. n the virtual machne Web
Assembl, at least in the version implemented in web browsers at the
time of this writting, don't support threads except in experimental
versions. In Windows we also would prefer to use ``critical sections''
instead of a mutex. The main reason is avoiding a system call to the
kernel when a mutex is not blocked. The critical sections ensure this
with the rrelevant drawback of not being able to be shared between
different programs. Besides that, the critical sections are equivalent
to mutexes.

In Unix based systems, we include the POSIX header ``pthreads''. In
Windows, the relevant heraders are already included in
\monoespaco{windows.h}.

\iniciocodigo
@<Include Headers@>+=
#if defined(__unix__) || defined(__APPLE__)
#include <pthread.h>
#endif
@
\fimcodigo

A mutex is declared with the following code:

\iniciocodigo
@<Declaração de Mutex@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_t mutex;
#endif
#if defined(_WIN32)
CRITICAL_SECTION mutex;
#endif
@
\fimcodigo

When the mutex is initialized, we store in a boolean
variable \monoespaco{error} if some problem happened. In the case of
the library \italico{pthreads}, its initialization function already
returns a non-null value if some problem happened. In Windows, the
operating system ensures that the function never fails. In both cases
we assume that we have a generic pointer for our mutex:

\iniciocodigo
@<Initialize `*mutex'@>=
#if defined(__unix__) || defined(__APPLE__)
error = pthread_mutex_init((pthread_mutex_t *) mutex, NULL);
#endif
#if defined(_WIN32)
InitializeCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

The code to destroy the mutex is below. In this case we don't need to
care about errors:

\iniciocodigo
@<Ending `*mutex'@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_destroy((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
DeleteCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

The classical operation of \italico{wait} when a thread try to enter a
critical section protected by mutexes:

\iniciocodigo
@<`*mutex':WAIT()@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_lock((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
EnterCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

And this is the function \italico{signal} to free a mutex resedved by
the thread:

\iniciocodigo
@<`*mutex':SIGNAL()@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_unlock((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
LeaveCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

\subsecao{2.3. Memory Arena Header}

After allocating a region of memory (or ``arena''), the first
requirement to initialize it is reserving the initial byes to store
general informations abou the region. The necessary informations are:
remaining size in bytes (\monoespaco{remaining\_space}), arena total
size (\monoespaco{total\_size}) and pointers to the beginning of the
next free region in the left and right stack
(\monoespaco{left\_free}, \monoespaco{right\_free}).
In \monoespaco{right\_allocations} we store the quantity in bytes
allocated in right stack and in \monoespaco{left\_allocations} the
quantity in bytes of memory allocated in the left stack.

We also need a mutex to protect the arena header of being manipulated
by two threads at same time.

Another information useful during debugging is the maximum ammount of
memory that our arena allocated during its lifetime. This is useful
because after deallocating the arena we can check if we gave too much
memory to it that in the end wasn't used. In this case, we could want
to lower the ammount os memory reserved to it. We will obtain this
information wih the variable \monoespaco{smallest\_remaining\_space}
that store the minimum value of remaining space during the arena
lifetime. This variable will be defined only if the
macro \monoespaco{W\_DEBUG\_MEMORY} is defined. We prefer to store the
minimum ammount of remaining space instead of the maximum ammount of
used space because is usually easier to read values which should be
small, close to zero, instead of values which usually should be big,
close to the total arena size.

We will also have two other pointers: \monoespaco{left\_point}
and \monoespaco{right\_point}. They are pointers for ``memory
points'', information about the arena status during a specific moment
which permit us to restore the arena to that given status. These
memory points will be better defined at section 2.9.

The header in our memory arena have the following format:

\iniciocodigo
@<Arena Header@>=
struct arena_header{
  @<Declaração de Mutex@>
  void *left_free, *right_free;
  void *left_point, *right_point;
  size_t remaining_space, total_size, right_allocations, left_allocations;
#if defined(W_DEBUG_MEMORY)
  size_t smallest_remaining_space;
#endif
};
@
\fimcodigo

Let's assume that we have a pointer for a non-initialized arena, which
we call \monoespaco{arena} and that we know as \monoespaco{M} the
arena size in bytes. With these information we can initialize the
arena header with the fllowing code. To compute the next empty
positions where we could store data, we convert the arena pointer for
a characere pointer. Doing his we ensure that the pointer arithmetic
will work with multiples of 1 byte. The next free space in the left
stack is the first byte after the header. And the next free space in
the right stack is the last byte in the arena.

\iniciocodigo
@<Initialize header in `arena' with size `M'@>=
{
  struct arena_header *header = (struct arena_header *) arena;
  header -> right_free = ((char *) header) + M - 1;
  header -> left_free = ((char *) header) + sizeof(struct arena_header);
  header -> remaining_space = M - sizeof(struct arena_header);
  header -> right_allocations = 0;
  header -> left_allocations = 0;
  header -> total_size = M;
  header -> left_point = NULL;
  header -> right_point = NULL;
#if defined(W_DEBUG_MEMORY)
  header ->  smallest_remaining_space = header -> remaining_space;
#endif
  { // Mutex initialization
    void *mutex = &(header -> mutex);
    @<Initialize `*mutex'@>
  }
}
@
\fimcodigo

\subsecao{2.4. Allocating New Arena}

With the previously defined code we already can define the
function \monoespaco{Wcreate\_arena}. This function is responsible for
the following 6 operations:

1. Get from the user a size \monoespaco{t} in bytes to allocate.

2. Discover the page size \monoespaco{p} in our environment.

3. Get \monoespaco{M}, as the lesser multiple of
\monoespaco{p} greater than \monoespaco{t}. If \monoespaco{M} is
smaller than the arena header size, it becomes equal the lesser
multiple than \monoespaco{p} greater than header size.

4. Allocate a new arena of size \monoespaco{M}.

5. Initialize its header.

6. Return a pointer for the beginning of arena, where its header is
stored, or \monoespaco{NULL} in case of problems.

The code to do this is:

\iniciocodigo
@<Definition for `Wcreate\_arena'@>=
void *Wcreate_arena(size_t t){
  bool error = false;
  void *arena;
  size_t p, M, header_size = sizeof(struct arena_header);
  // Operation 2:
  @<Get page size `p'@>
  // Operation 3:
  M = (((t - 1) / p) + 1) * p;
  if(M < header_size)
    M = (((header_size - 1) / p) + 1) * p;
  // Operation 4:
  @<Allocate in 'arena' region of 'M' bytes@>
  // Operation 5:
  @<Initialize header in `arena' with size `M'@>
  // Operation 6:
  if(error) return NULL;
  return arena;
}
@
\fimcodigo

\subsecao{2.5. The function ``Wdestroy\_arena''}

Uma vez que fornecemos uma forma de criar novas arenas, vamos definir
também a função que irá finalizá-las. Esta é uma função mais simples
que fará quatro coisas:

1. Destruirá o mutex associado à arena.

2. Imprimirá um aviso na tela se existe alguma coisa ainda alocada na
arena.

3. Se estamos em modo de depuração, imprimirá a quantidade de memória
que nunca chegou a ser usada pela arena.

4. Devolverá para o Sistema Operacional a memória que ele pediu para a
arena.

\iniciocodigo
@<Definição de `Wdestroy\_arena'@>=
bool Wdestroy_arena(void *arena){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  size_t M = header -> total_size;
  bool ret = true;
  @<Ending `*mutex'@>
  if(header -> total_size != header -> remaining_space +
     sizeof(struct arena_header))
    ret = false;
#if defined(W_DEBUG_MEMORY)
  printf("Unused memory: %zu/%zu (%f%%)\n",
         header -> smallest_remaining_space, header -> total_size,
         100.0 *
         ((float) header -> smallest_remaining_space) / header -> total_size);
#endif
  @<Deallocate 'arena' of size 'M' bytes@>
  return ret;
}
@
\fimcodigo

Embora isso nos faça ter que incluir o cabeçalho das funções de
entrada e saída padrão se estivermos em modo de depuração:

\iniciocodigo
@<Include Headers@>+=
#if defined(W_DEBUG_MEMORY)
#include <stdio.h>
#endif
@
\fimcodigo

\subsecao{2.6. Mantendo o Alinhamento em Memória Alocada}

Quando vamos alocar uma nova memória começamos com um endereço $p$ que
está disponível no qual iremos colocar nossa memória alocada. Mas
devemos respeitar o alinhamento $a$, o qual é uma potência de 2 ou o
número zero (que significa ``qualquer alinhamento''). O modo de fazer
isso depende se estamos na pilha esquerda (posição inicial da memória
na arena) ou direita (posição final da memória na arena). Pois uma das
pilhas de memória cresce para posições maiores e outra para menores.

No caso da memória da pilha esquerda, vamos querer colocar nossa
alocação em um endereço $p$, mas podemos ter que deslocar $p$ um pouco
mais para os próximos endereços para poder alinhar a memória. Fazemos
isso considerando que $a-1$ representa tanto o pior caso de quantidade de
posições que vamos deslocar $p$ como uma máscara de bits que devem ser
nulos para que o endereço seja válido, pelo fato de $a$ ser uma potência de
dois. Sendo assim, nosso código de alinhamento é:

\iniciocodigo
@<Alinha `p' e marca `offset' de acordo com `a' (esquerda)@>=
offset = 0;
if (a > 1){
  void *new_p = ((char *) p) + (a - 1);
  new_p = (void *) (((uintptr_t) new_p) & (~((uintptr_t) a - 1)));
  offset = ((char *) new_p) - ((char *) p);
  p = new_p;
}
@
\fimcodigo

Para podermos usar o tipo \monoespaco{uintptr\_t} usamos a biblioteca
abaixo. Esse tipo é a maneira portável de podermos usar operações
bit-a-bit em ponteiros.

\iniciocodigo
@<Include Headers@>+=
#include <stdint.h>
@
\fimcodigo


Já na pilha direita, vamos querer alocar em um endereço $p$, mas
possivelmente teremos que dimminuir o endereço inicial para mantê-lo
alinhado ao invés de aumentá-lo. Com isso não é necessário somar
o endereço inicial com o valor de pior caso $a-1$, basta remover
diretamente os bits finais que forem necessários para o alinhamento:

\iniciocodigo
@<Alinha `p' e marca `offset' de acordo com `a' (direita)@>=
offset = 0;
if (a > 1){
  void *new_p = (void *) (((uintptr_t) p) & (~((uintptr_t) a - 1)));
  offset = ((char *) p) - ((char *) new_p);
  p = new_p;
}
@
\fimcodigo

\subsecao{2.7. Alocando Memória}

Antes de alocar memória, temos que verificar se existe espaço
disponível. Fazemos isso checando os valores do cabeçalho da arena
e comparando com o valor que temos que alocar, considerando o pior
caso de alinhamento, onde precisaremos de um espaço adicional de
$a-1$. Se não houver espaço, o valor $p$ a ser retornado terá que ser
\monoespaco{NULL}.

Se vamos alocar na pilha esquerda, o nosso endereço alocado será a
próxima posição depois desse cabeçalho após passar por uma correção de
alinhamento. Também vamos atualizar o quanto está sendo alocado na
variável \monoespaco{left\_allocations}.

Se vamos alocar na pilha direita, obtemos o valor do endereço alocado
indo para a próxima região livre marcada no cabeçalho da arena e
subtraímos do endereço o tamanho que queremos alocar sem o cabeçalho,
somando 1 ao resultado. Assim teremos à nossa direita a quantidade
certa de memória que precisamos retornar ao usuário. Mas antes disso,
novamente fazemos a correção necessária de alinhamento. E como é a
pilha direita, armazenamos quanto foi alocado no cabeçalho da arena na
variável \monoespaco{right\_allocations}.

Uma vez que isso foi feito, basta atualizarmos o cabeçalho da arena
com as próximas posições livres, já que a anterior acabamos de ocupar,
e também calculando um novo valor para o espaço livre que ainda
temos.Feito isso,
\monoespaco{p} está pronto para ser retornado.

\iniciocodigo
@<Alocação de `p', tamanho `t' em `arena', alinhamento `a'@>=
{
  int offset;
  struct arena_header *header = (struct arena_header *) arena;
  if(header -> remaining_space >= t + ((a == 0)?(0):(a - 1))){
    if(right){
      p = ((char *) header -> right_free) - t + 1;
      @<Alinha `p' e marca `offset' de acordo com `a' (direita)@>
      header -> right_free = (char *) p - 1;
      header -> right_allocations += (t + offset);
    }
    else{
      p = header -> left_free;
      @<Alinha `p' e marca `offset' de acordo com `a' (esquerda)@>
      header -> left_free = (char *) p + t;
      header -> left_allocations += (t + offset);
    }
    header -> remaining_space -= (t + offset);
#if defined(W_DEBUG_MEMORY)
    if(header -> remaining_space < header -> smallest_remaining_space)
      header -> smallest_remaining_space = header -> remaining_space;
#endif
  }
}
@
\fimcodigo

\subsecao{2.8. A Função Walloc}

Podemos agora juntar as peças para definir a função de alocação. Ela
irá receber \monoespaco{arena} (arena onde o usuário deseja alocar),
\monoespaco{a} (o alinhamento), \monoespaco{right} (1 se desejamos
alocar na pilha direita e 0 na esquerda) e \monoespaco{t} (tamanho que
o usuário deseja alocar).

A primeira coisa a fazer é dar um ``wait'' no mutex da arena. Depois
fazemos a alocação e então damos um ``signal'' no mutex. Será preciso
termos também uma variável \monoespaco{p} que é o que iremos retornar
e apontará para a região de memória requisitada pelo usuário.


\iniciocodigo
@<Definição de `Walloc'@>=
void *Walloc(void *arena, unsigned a, int right, size_t t){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  void *p = NULL;
  @<`*mutex':WAIT()@>
  @<Alocação de `p', tamanho `t' em `arena', alinhamento `a'@>
  @<`*mutex':SIGNAL()@>
  return p;
}
@
\fimcodigo

\subsecao{2.9. Definição dos Pontos de Memória}

Caso tenhamos uma arena que já foi usada e tem armazenada regiões
alocadas, mas queiramos nos livrar de todas as alocações e começar de
novo, para isso basta reiniciarmos os valores armazenados no cabeçalho
da arena. Os ponteiros para a próxima posição livre e o espaço livre
disponível precisa ser atualizado para ficar igual ao valor inicial.

Mas estamos mais interessados não em reiniciar uma arena inteira, mas
somente as suas alocações na pilha esquerda ou na direita. Na pilha
direita ou esquerda nós sabemos exatamente quanto foi alocado graças à
variável \monoespaco{right\_allocations}
ou \monoespaco{left\_allocations} que armazenamos no cabeçalho da
arena. Então reiniciamos os valores facilmente para esvaziar somente a
pilha na qual estamos interessados:

\iniciocodigo
@<Reinicia memória de pilha em `arena'@>=
{
  struct arena_header *header = arena;
  if(right){
    header -> right_free = ((char *) arena) + header -> total_size - 1;
    header -> remaining_space += header -> right_allocations;
    header -> right_allocations = 0;
  }
  else{
    header -> left_free = ((char *) arena) + sizeof(struct arena_header);
    header -> remaining_space += header -> left_allocations;
    header -> left_allocations = 0;
  }
}
@
\fimcodigo

Mas e se quisermos salvar na arena de memória as informações de
alocação atuais para restaurar mais tarde (chamamos tais informações
de ``ponto de memória'')? A única informação que precisamos armazenar
é o conteúdo de \monoespaco{left\_allocations} no caso da pilha
esquerda e \monoespaco{right\_allocations} na pilha direita.

O ponteiro para a próxima região livre \monoespaco{left\_free}
ou \monoespaco{right\_free} pode ser atualizado movendo ele um número
de posições igual à diferença entre a quantidade de alocações atuais e
a alocação armazenada. O novo valor para a quantidade de espaço livre
pode ser obtida somando o valor atual à esta mesma diferença entre
valores de alocações.

Entretanto, queremos poder armazenar não um único ponto de memória,
mas uma lista de qualquer tamanho deles. Queremos que eles formem uma
lista encadeada simples. Sendo assim, um ponto de memória é definido
pelo seguinte cabeçalho:

\iniciocodigo
@<Cabeçalho de Ponto de Memória@>=
struct memory_point{
  size_t allocations; // Left or right
  struct memory_point *last_memory_point;
};
@
\fimcodigo

\subsecao{2.10. Criação de Ponto de Memória}

Criar um novo ponto de memória significa enviar um sinal
de \italico{wait} para o mutex, alocar memória para o ponto de
memória, inicializá-lo e atualizar informações na arena sobre qual o
último ponto de memória, levando em conta se colocamos ele na memória
esquerda ou direita. Em seguida podemos liberar o mutex com
um \italico{signal}:

\iniciocodigo
@<Definição de `Wmempoint'@>=
bool Wmempoint(void *arena, unsigned a, int right){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  char *p = NULL;
  struct memory_point *point;
  size_t allocations, t = sizeof(struct memory_point);
  @<`*mutex':WAIT()@>
  if(right)
    allocations = header -> right_allocations;
  else
    allocations = header -> left_allocations;
  @<Alocação de `p', tamanho `t' em `arena', alinhamento `a'@>
  point = (struct memory_point *) p;
  if(point != NULL){
    point -> allocations = allocations;
    if(right){
      point -> last_memory_point = header -> right_point;
      header -> right_point = point;
    }
    else{
      point -> last_memory_point = header -> left_point;
      header -> left_point = point;
    }
  }
  @<`*mutex':SIGNAL()@>
  if(point == NULL)
    return false;
  return true;
}
@
\fimcodigo

\subsecao{2.10. Restauração de Ponto de Memória}

Restaurar o ponto de memória anterior significa mudar o estado da
pilha de memória (esquerda ou direita) exatamente como era antes do
ponto de memória ser salvo pela última vez. Se ele nunca foi salvo,
esvaziamos toda a pilha de memória. A função que fará isso será
a \monoespaco{Wtrash}:

\iniciocodigo
@<Definição de `Wtrash'@>+=
void Wtrash(void *arena, int right){
  struct arena_header *head = (struct arena_header *) arena;
  void *mutex = (void *) &(head -> mutex);
  struct memory_point *point;
  @<`*mutex':WAIT()@>
  if(right){
    point = head -> right_point;
  }
  else{
    point = head -> left_point;
  }
  if(point == NULL){
    @<Reinicia memória de pilha em `arena'@>
  }
  else{
    if(right){
      head -> remaining_space += (head -> right_allocations -
                                  point -> allocations);
      head -> right_point = point -> last_memory_point;
      head -> right_allocations = point -> allocations;
    }
    else{
      head -> remaining_space += (head -> left_allocations -
                                  point -> allocations);
      head -> left_point = point -> last_memory_point;
      head -> left_allocations = point -> allocations;
    }
  }
  @<`*mutex':SIGNAL()@>
}
@
\fimcodigo


\subsecao{2.11. Organização Final do Arquivo-Fonte}

Salvaremos todo o código de definição de funções que fizemos no
arquivo abaixo que poderá então ser compilado:

\iniciocodigo
@(src/memory.c@>=
@<Include Headers@>
#include "memory.h"
@<Arena Header@>
@<Cabeçalho de Ponto de Memória@>
@<Definition for `Wcreate\_arena'@>
@<Definição de `Wdestroy\_arena'@>
@<Definição de `Walloc'@>
@<Definição de `Wmempoint'@>
@<Definição de `Wtrash'@>
@
\fimcodigo

\secao{3. Desempenho}

Para medir o desempenho deste código, foi escrito um programa que
executa cada uma das funções definidas aqui cem mil vezes e obtém
a média e o desvio padrão, comparando tais medidas com as
funções \monoespaco{malloc} e \monoespaco{free} do sistema. Execuções
do programa com desvio padrão mais altos foram descartados por assumir
que o Sistema Operacional estava realizando tarefas não-relacionadas à
execução da função e que isso prejudicou a medida.

Em todas as alocações, escolhemos o valor de 5 KiB para que assim
evitar que as implementações de \monoespaco{malloc} tenham que lidar
com problemas de alinhamento de memória e assim serem penalizadas. Mas
o valor também permite que observemos o custo que estas funções tem de
pedirem mais memória para o Sistema Operacional, pois é um valor
relativamente alto, maior que o tamanho de uma página na máquina
usada. Na função \monoespaco{Walloc}, optamos por pedir qualquer
alinhamento e por sempre usar a pilha esquerda para as alocações, pois
é a pilha que teria o melhor desempenho devido à localidade espacial
das alocações.

É importante notar que embora as funçõe aqui definidas tenham sido
projetadas para executar sempre em tempo constante, independente do
tamanho do espaço de memória alocado, as funções \monoespaco{malloc}
e \monoespaco{free} de cada um dos sistemas nem sempre segue esta
mesma filosofia. Durante as medições, a quantidade de memória alocada
e foi mudada para verificar se isso alterava os tempos de
execução. Quando detectamos que uma função não executa em tempo
constante, nossa maior preocupação foi checar para quais valores a
função tem um desempenho equivalente e para quais tem um desempenho
pior no computador usado nos testes. Não arriscamos previsões muito
precisas quanto ao comportamento da função sem uma análise de sua
implementação.

\subsecao{3.1. OpenBSD}

No OpenBSD a função \monoespaco{free} não parece executar em tempo
constante para diferentes tamanhos de memórias liberadas. O tempo de
execução dela parece crescer linearmente à medida que a quantidade a
ser liberada cresce exponencialmente, o que parece indicar uma
complexicade logarítmica. Na máquina usada nos testes, o desempenho
dela ficou próximo somente quando o espaço a ser desalocado tinha na
ordem de 100 bytes. O desempenho mostrado abaixo é para o teste
particular de alocações de 5 KiB repetidas por cem mil vezes.

Da mesma forma, para valores pequenos, a função \monoespaco{malloc}
demonstra um desempenho equivalente à \monoespaco{Walloc}, indicando
que o desempenho menor mostrado no gráfico abaixo se deve ao custo de
pedir mais memória por meio de uma chamada de sistema ao Sistema
Operacional.

% OpenBSD:
% Malloc:     6.30530874us +- 25.124535168us
% Free:      22.00978538us +- 12.809965439us
% Walloc:     2.50560902us +-  0.228082461us
% Wmempoint:  2.26598656us +-  0.505975457us
% Wtrash:     2.22814472us +-  0.166606876us

% Linux
% Malloc:     2.71246735us +-  0.801445880us
% Free:       0.87757830us +-  0.141186377us
% Walloc:     0.76750440us +-  0.218803555us
% Wmempoint:  0.75614315us +-  0.155982817us
% Wtrash:     0.75579410us +-  0.066124620us

% Windows 10
% Malloc:    1.59881us +- 11.466939064us
% Free:      0.57427us +-  9.402517112us
% Walloc:    0.00003us +-  0.005477171us
% Wmempoint: 0.00515us +-  0.233332428us
% Wtrash:    0.00045us +-  0.097825831us

% Web Assembly (Firefox Quantum 67.04)
% Malloc:    2.399475651us +-  48.931141529us
% Free:      0.489213791us +-  22.130980751us
% Walloc:    0.394548569us +-  19.744325980us
% Wmempoint: 0.451152325us +-  21.208728454us
% Wtrash:    0.398001614us +-  19.744481718us


\secao{Referências}

\referencia{Gregory, J. (2019) ``Game Engine Architecture'', CRC Press, terceira
edição.}

\referencia{Zakai, A. (2011) ``Emscripten: an LLVM-to-JavaScript compiler'',
Proceedings of the ACM international conference companion on Object
oriented programming systems languages and applications companion,
p. 301--312.}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer Journal,
volume 27, edição 2, p. 97--111}

\referencia{Ranck, S. (2000) ``Game Programming Gems'', Charles River Media,
volume 1, edição 1, p. 92--100}


\fim
