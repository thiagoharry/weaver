\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver Memory Manager}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article describes using literary programming a memory
manager written for Weaver Game Engine. It aims to be a very simple
and fast memory manager for programs where memory is allocated and
freed in a stack-based order and we know the maximum ammount of memory
that the program will need. It allows users creating markings during
the program execution that after allows them to free at once all the
memory allocated after the last marking. After the memory manager
creation, we also run some benchmarks comparing its performance
against malloc from standard library running at Linux, Windows and
in a web browser using Web Assembly.}


\secao{1. Introduction}

\subsecao{1.1. Memory Managers in Game Engines}

Many game engines run custom memory managers instead of using the
system's library to obtain more memory dinamically. According with
[Gregory 2019], this happens because implementations
like \italico{malloc} and \italico{free} could be relatively slow when
used in games compared with custom memory managers. Custom memory
managers also can deal with memory fragmentation.

Gregory identifies five design pattern for managing memory in games:

\negrito{Stack-based Allocators:} These allocators always return sequential
regions of memory and deallocations must happen in reverse order than
allocation. The implementation is very simple and it is easy to ensure
spatial locality of used memory regions. All the memory allocatyed
since some specific time of execution could be rapidly deallocated
with a single function call.

\negrito{Pool Allocators:} This technique can be used when we know that we
will need at most $n$ elements, all with the same size. We can
allocate previously the memory for these elements and keep their
memory region always at disposal using variables to store when a given
region is occupied by an element and when we can treat it as free
memory.

\negrito{Alligned Allocations:} Different types of data and computer architectures
can have different alignment restrictions for
memory. In \itelico{Playstation 3}, for example, any memory position
passed using DMA (\italico{Direct Memory Access}) must be 128-bit
aligned. This means that its address must be a multiple of 128 bits.

\negrito{Single Frame and Double-Buffered Memory Allocators:} A game engine
runs all its computations in frames, and in each frame a new image is
sent to the screen. Some allocated variables must have a lifetime of
only one or two frames, and could be deallocated automatically after
this time.

\negrito{Memory Defragmenter:} When memory is allocated and freed
in unpredictable order, small unused memory regions could
accumulate. Sometimes they are too small to be useful, and they are
many and so they waste considerable ammounts of memory. To avoid this,
instead ofusing pointers for allocated objects, we could use indexes
which indentifies the pointers. This way, allocated memory could be
moved incrementally and peridically to avoid fragmentation and their
pointers can be updated.

This article objective is to define a stack-based allocator with
support for memory alignment and which can store two stacks in its
memory region. Manage which stack to use is user's
responsability. This technique is described in [Ranck, 2000] which
shows how it was used in the game \italico{Hydro Thunder} made
by \italico{Midway}.

Pool allocators won't be supported here, but they can easily be built
using the allocator defined here. The fragmentation problem also won't
be addressed, as stack-based allocators usually do not have memory
fragmentation when correctly used.

\subsecao{1.2. Executon Environments}

In this article we will focus in creating functions which to run in
four different environments: Windows 10, MacOS Sierra, Linux and Web
Assembly. The three first are operating systems for personal
computers. Thelast one is a virtual machine specification specialized
in run a optimized subset of javascript. It permits the execution of
complex computer programs in environments like web browsers. Its
development started as a method proposed by [Zakai, 2011] who
presented a novel way to compile code in C and C++ for javascript with
advanced optimization techniques.

To develop portable code in all four environments, we will use
conditional macros and different methods of obtaining memory in all
different systems will be compared.

\subsecao{1.3. Literary Programming and this Article Notation}

This article utilizes the technique of ``Literary Programming'' in the
development of the memory manager. This technique was presented in
[Knuth, 1984] and consists in a philosophy of software development
where the programmer develop the software writting and explaining
didatically all the necessary code, focusing in writting a clear
explanation for people reading the explanation. Automatic tools are
employed to extract the code from the explanation, change the order of
the code when necessary and produce an executable program from the
extracted code.

For example, in this article will be defined two different files:
\monoespaco{memory.c} and \monoespaco{memory.h}, both could be statically
included in any project, or compiled as a shared library. What the file
\monoespaco{memory.h} contains is:

\iniciocodigo
@(src/memory.h@>=
#ifndef WEAVER_MEMORY_MANAGER
#define WEAVER_MEMORY_MANAGER
#ifdef __cplusplus
extern "C" {
#endif
@<Memory Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are security macros to avoid that
functions and variables declared there be included more than once,
even if an user includes this header file more than once using include
macros. The other lines contains macros to check if we are compiling
using C++ instead of C. In this case we declare all functions in this
file as C style functions to warn the compiler that they are not
modifiable by operator overloading and because of this is not
necessary to store additional information besides the function name to
recognize them.

In the code above, we use the red letters to indicate that in the
future we will insert new code there called ``Memory Declarations'',
with all the necessary function declaraions. Searching in this
article, you can find in the next pages another pieces of code where
the title is not \monoespaco{memory.h} as above, but ``Memory
Declarations''. These pieces of code will be inserted in the code
above. And could be more than one piece of code with he same title. In
this case, to produce functional code for the compiler, we should
concatenate all these pieces of code with the same title and put in
the part marked as red in the source code. his allow us to introduce
function declarations as we explain them in the article, not needing
to declare all them once just because they are part of the same piece
of code.

\subsecao{1.4. Functions to be Defined}

Our memory manager will define a total of 6 new functions. The first
one receives a size in bytes and return a new contiguous region of
memory to be managed. We call this region a ``arena'':

\iniciocodigo
@<Memory Declarations@>=
#include <stdlib.h> // Include 'size_t'
void *Wcreate_arena(size_t size);
@
\fimcodigo

The second function receives an arena created by the first function
and free all the reserved memory. If that arena had not deallocated
elements, we return false (a program could print a warning to the user
if the function return false) and otherwise the function returns true:

\iniciocodigo
@<Memory Declarations@>+=
#include <stdbool.h> // Include 'bool'
bool Wdestroy_arena(void *);
@
\fimcodigo

The third one is equivalent to \monoespaco{malloc} and receives an
arena, a number which should be a power of two or zero representing a
bit alignment which should be respected, another number which selects
if we should allocate in ther left (0) or right (1) stack, and finally
a size in bytes. The function always returns an address multiple of
the alignment if a power of two was passed. And it
returns \monoespaco{NULL} in case of no enough memory in the arena:

\iniciocodigo
@<Memory Declarations@>+=
void *Walloc(void *arena, unsigned alignment, int right, size_t size);
@
\fimcodigo

The fourth function puts a marking, which we will call ``memory
point'' in our arena. This marking can be used to determine which
allocations happened before and after the marking. The last argument
also selects if we should put the marking in the left (0) or right (1)
stack. We also specify an aligment like in the previous allocation
function. The function returns if this was sucessful or not:

\iniciocodigo
@<Memory Declarations@>+=
bool Wmempoint(void *arena, unsigned alignment, int region);
@
\fimcodigo

The last function use the marking of the previous function and
deallocate all the allocated memory since the last marking was
created. It receives a flag to know if this should be done with the
left (0) or right (1) stack.

\iniciocodigo
@<Memory Declarations@>+=
void Wtrash(void *arena, int region);
@
\fimcodigo

\secao{2. Implementation}

\subsecao{2.1. Obtaining a Beginning Region of Memory}

In a general purpose memory manager we don't need to know the maximum
ammount of memory needed in our program. But in a game memory manager,
it is essential to estabilish a maximum limit for memory usage. In
this case we are more interested in ensuring a continuous performance
instead of getting a precise result for some computation. We want to
avoid at all costs the subit performance decrease when a supported
machine don't have more memory and needs to use memory swap. In some
architectures, we do not even have a disk to use swap memory and
consuming all RAM can make the game crash. Because of this, in games
we can allocate during initialization the maximum ammount of needed
memory and never use more memory than what was allocated in this
moment.

How we obtain this initial memory varies according with the execution
environment. We could use a simple \monoespaco{malloc} for this, but
we will prefer alternatives with less waste of memory. Ideally a
function which returns a raw region of memory, without aditional
informations or data structures.

Both in Unix systems (Linux, OpenBSD, MacOS) as in Web Assembly
compiled usng Emscripten, the more economical choice is
using \monoespaco{mmap}. It is a very customizable function which can
map to memory anithing, from disk files to new allocated regions.

To use  \monoespaco{mmap}, we need the following headers:

\iniciocodigo
@<Incluir Cabeçalhos Necessários@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
#include <sys/mman.h>
#endif
@
\fimcodigo

After defining the headers, to allocate a region of $M$ bytes not
associated with any file, which can be read and written, we invoke the
function with the following arguments:

\iniciocodigo
@<Allocate in 'arena' region of 'M' bytes@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
arena = mmap(NULL, M, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON,
             -1, 0);
#endif
@
\fimcodigo

The null, zero and -1 arguments are just the ones not necessary in
this usage of \monoespaco{mmap}.

As we can create a new region of memory, we can also destroy that
region, deallocating it. In this case, we should
use \monoespaco{munmap}:

\iniciocodigo
@<Deallocate 'arena' of size 'M' bytes@>=
#if defined(__EMSCRIPTEN__) || defined(__unix__) || defined(__APPLE__)
munmap(arena, M);
#endif
@
\fimcodigo

In Windows environments, the equivalent function is 
\monoespaco{CreateFileMapping}, with the difference that it returns
a handle which needs another function to give us a pointer to the
allocated region. Fortunately, according with Windows API
documentation, we can close that handle with \monoespaco{CloseHandle}
before deallocate and undo the reserver region. Thanks for this, we
can keep the simmetry between Windows and other platform's code, as we
can close the handle in this code without needing to memorize it in
some additional structure:

\iniciocodigo
@<Allocate in 'arena' region of 'M' bytes@>+=
#if defined(_WIN32)
{
  HANDLE handle;
  handle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
                              PAGE_READWRITE,
                              (DWORD) ((DWORDLONG) M) / ((DWORDLONG) 4294967296),
                              (DWORD) ((DWORDLONG) M) % ((DWORDLONG) 4294967296),
                              NULL);
  arena = MapViewOfFile(handle, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
  CloseHandle(handle);
}
#endif
@
\fimcodigo


To deallocate the region in Windows, we
use \monoespaco{UnmapViewOfFile}:

\iniciocodigo
@<Deallocate 'arena' of size 'M' bytes@>+=
#if defined(_WIN32)
UnmapViewOfFile(arena);
#endif
@
\fimcodigo

Using the previous functions require the following headers:

\iniciocodigo
@<Include Headers@>+=
#if defined(_WIN32)
#include <windows.h>  // Include 'CreateFileMapping', 'MapViewOfFIle',
#include <memoryapi.h> // 'UnmapViewOfFile', 'CloseHandle'
#endif
@
\fimcodigo

\subsecao{2.2. Obtaining Page Size}

In a real computer, contrasting with some virtual machines, when a
program asks for memory for the Operating System, it always receive
memory in multiples of the page size used internally by the
machine. Tipically the page size is 4 KiB. In this case, it's useless
asking for non-multiples of KiB. If we ask for just 2 KiB, we keep
receiving 4 KiB. If we ask for 5 KiB, we receive 8KiB.

It's important that in these environments, our memory manager be aware
of this and even if the user asks for a non-multiple of page size
ammount of memory, it always should adjust the requested size for a
multiple of page size, avoiding the waste of memory.

In the majority of Unix systems, if they are POSIX compatible, we can
get the page size using the function \monoespaco{sysconf}:

\iniciocodigo
@<Get page size `p'@>=
#if defined(__unix__)
p = sysconf(_SC_PAGESIZE);
#endif
@
\fimcodigo

In MacOS, while its documentation says that the system is POSIX
compatible, it also recommends using the BSD
function \monoespaco{getpagesize} to get this information. So to
follow the documentation guidelines, we use this code:

\iniciocodigo
@<Get page size `p'@>+=
#if defined(__APPLE__)
p = getpagesize();
#endif
@
\fimcodigo

Both the BSD function as the POSIX function are defined in the same header:

\iniciocodigo
@<Include Headers@>+=
#if defined(__APPLE__) || defined(__unix__)
#include <unistd.h>
#endif
@
\fimcodigo

In Windows, we can get the page size using the more
complex \monoespaco{GetSystemInfo}, which also returns a series of
additional information about the system, which we don't need to keep
at the moment.

\iniciocodigo
@<Get page size `p'@>+=
#if defined(_WIN32)
{
  SYSTEM_INFO info;
  GetSystemInfo(&info);
  p = info.dwPageSize;
}
#endif
@
\fimcodigo

To use this function, the documentation recommends to include
directly \monoespaco{windows.h} header:

\iniciocodigo
@<Include Headers@>+=
#if defined(_WIN32)
#include <windows.h> // Include 'GetSystemInfo'
#endif
@
\fimcodigo

Finally the Web Assembly environment. Here the dynamically allocated
memory is obtained from a contiguous region of memory which starts
with a fixed size and can grow calling the
operator \monoespaco{grow\_memory}, which also is configured with a
maximum size. Anyway, here the memory is also allocaten in multiples
of a fixed value. But the value is always 64 KiB:

\iniciocodigo
@<Get page size `p'@>+=
#if defined(__EMSCRIPTEN__)
p = 64 * 1024; // 64 KiB
#endif
@
\fimcodigo

\subsecao{2.3. Running in Multiple Threads}

It's important to ensure that he code defined here works even when
invoked simultaneously in different parts of code. For this we will
need mutexes to ensure that the same region of memory won't be
accessed by more than one thread at same time. If more than one thread
wants toallocate memory, probably will be more efficient give to each
one its own arena to avoid that each thread block the others in the
process.

Not all environments supports threads. n the virtual machne Web
Assembl, at least in the version implemented in web browsers at the
time of this writting, don't support threads except in experimental
versions. In Windows we also would prefer to use ``critical sections''
instead of a mutex. The main reason is avoiding a system call to the
kernel when a mutex is not blocked. The critical sections ensure this
with the rrelevant drawback of not being able to be shared between
different programs. Besides that, the critical sections are equivalent
to mutexes.

In Unix based systems, we include the POSIX header ``pthreads''. In
Windows, the relevant heraders are already included in
\monoespaco{windows.h}.

\iniciocodigo
@<Include Headers@>+=
#if defined(__unix__) || defined(__APPLE__)
#include <pthread.h>
#endif
@
\fimcodigo

A mutex is declared with the following code:

\iniciocodigo
@<Declaração de Mutex@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_t mutex;
#endif
#if defined(_WIN32)
CRITICAL_SECTION mutex;
#endif
@
\fimcodigo

When the mutex is initialized, we store in a boolean
variable \monoespaco{error} if some problem happened. In the case of
the library \italico{pthreads}, its initialization function already
returns a non-null value if some problem happened. In Windows, the
operating system ensures that the function never fails. In both cases
we assume that we have a generic pointer for our mutex:

\iniciocodigo
@<Initialize `*mutex'@>=
#if defined(__unix__) || defined(__APPLE__)
error = pthread_mutex_init((pthread_mutex_t *) mutex, NULL);
#endif
#if defined(_WIN32)
InitializeCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

The code to destroy the mutex is below. In this case we don't need to
care about errors:

\iniciocodigo
@<Ending `*mutex'@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_destroy((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
DeleteCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

The classical operation of \italico{wait} when a thread try to enter a
critical section protected by mutexes:

\iniciocodigo
@<`*mutex':WAIT()@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_lock((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
EnterCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

And this is the function \italico{signal} to free a mutex resedved by
the thread:

\iniciocodigo
@<`*mutex':SIGNAL()@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_unlock((pthread_mutex_t *) mutex);
#endif
#if defined(_WIN32)
LeaveCriticalSection((CRITICAL_SECTION *) mutex);
#endif
@
\fimcodigo

\subsecao{2.3. Memory Arena Header}

After allocating a region of memory (or ``arena''), the first
requirement to initialize it is reserving the initial byes to store
general informations abou the region. The necessary informations are:
remaining size in bytes (\monoespaco{remaining\_space}), arena total
size (\monoespaco{total\_size}) and pointers to the beginning of the
next free region in the left and right stack
(\monoespaco{left\_free}, \monoespaco{right\_free}).
In \monoespaco{right\_allocations} we store the quantity in bytes
allocated in right stack and in \monoespaco{left\_allocations} the
quantity in bytes of memory allocated in the left stack.

We also need a mutex to protect the arena header of being manipulated
by two threads at same time.

Another information useful during debugging is the maximum ammount of
memory that our arena allocated during its lifetime. This is useful
because after deallocating the arena we can check if we gave too much
memory to it that in the end wasn't used. In this case, we could want
to lower the ammount os memory reserved to it. We will obtain this
information wih the variable \monoespaco{smallest\_remaining\_space}
that store the minimum value of remaining space during the arena
lifetime. This variable will be defined only if the
macro \monoespaco{W\_DEBUG\_MEMORY} is defined. We prefer to store the
minimum ammount of remaining space instead of the maximum ammount of
used space because is usually easier to read values which should be
small, close to zero, instead of values which usually should be big,
close to the total arena size.

We will also have two other pointers: \monoespaco{left\_point}
and \monoespaco{right\_point}. They are pointers for ``memory
points'', information about the arena status during a specific moment
which permit us to restore the arena to that given status. These
memory points will be better defined at section 2.9.

The header in our memory arena have the following format:

\iniciocodigo
@<Arena Header@>=
struct arena_header{
  @<Declaração de Mutex@>
  void *left_free, *right_free;
  void *left_point, *right_point;
  size_t remaining_space, total_size, right_allocations, left_allocations;
#if defined(W_DEBUG_MEMORY)
  size_t smallest_remaining_space;
#endif
};
@
\fimcodigo

Let's assume that we have a pointer for a non-initialized arena, which
we call \monoespaco{arena} and that we know as \monoespaco{M} the
arena size in bytes. With these information we can initialize the
arena header with the fllowing code. To compute the next empty
positions where we could store data, we convert the arena pointer for
a characere pointer. Doing his we ensure that the pointer arithmetic
will work with multiples of 1 byte. The next free space in the left
stack is the first byte after the header. And the next free space in
the right stack is the last byte in the arena.

\iniciocodigo
@<Initialize header in `arena' with size `M'@>=
{
  struct arena_header *header = (struct arena_header *) arena;
  header -> right_free = ((char *) header) + M - 1;
  header -> left_free = ((char *) header) + sizeof(struct arena_header);
  header -> remaining_space = M - sizeof(struct arena_header);
  header -> right_allocations = 0;
  header -> left_allocations = 0;
  header -> total_size = M;
  header -> left_point = NULL;
  header -> right_point = NULL;
#if defined(W_DEBUG_MEMORY)
  header ->  smallest_remaining_space = header -> remaining_space;
#endif
  { // Mutex initialization
    void *mutex = &(header -> mutex);
    @<Initialize `*mutex'@>
  }
}
@
\fimcodigo

\subsecao{2.4. Allocating New Arena}

With the previously defined code we already can define the
function \monoespaco{Wcreate\_arena}. This function is responsible for
the following 6 operations:

1. Get from the user a size \monoespaco{t} in bytes to allocate.

2. Discover the page size \monoespaco{p} in our environment.

3. Get \monoespaco{M}, as the lesser multiple of
\monoespaco{p} greater than \monoespaco{t}. If \monoespaco{M} is
smaller than the arena header size, it becomes equal the lesser
multiple than \monoespaco{p} greater than header size.

4. Allocate a new arena of size \monoespaco{M}.

5. Initialize its header.

6. Return a pointer for the beginning of arena, where its header is
stored, or \monoespaco{NULL} in case of problems.

The code to do this is:

\iniciocodigo
@<Definition for `Wcreate\_arena'@>=
void *Wcreate_arena(size_t t){
  bool error = false;
  void *arena;
  size_t p, M, header_size = sizeof(struct arena_header);
  // Operation 2:
  @<Get page size `p'@>
  // Operation 3:
  M = (((t - 1) / p) + 1) * p;
  if(M < header_size)
    M = (((header_size - 1) / p) + 1) * p;
  // Operation 4:
  @<Allocate in 'arena' region of 'M' bytes@>
  // Operation 5:
  @<Initialize header in `arena' with size `M'@>
  // Operation 6:
  if(error) return NULL;
  return arena;
}
@
\fimcodigo

\subsecao{2.5. The function ``Wdestroy\_arena''}

Once we provided a function to create new arenas, we need to define a
function to destroy and deallocate them. This is a simpler function to
do four things:

1. Destroy the arena mutex.

2. Print a warning if there are still allocated memory in the arena.

3. If we are in debug mode, print the ammount of memory which never
was used int he arena.

4. Free to the operating system the arena memory.

\iniciocodigo
@<Definition for `Wdestroy\_arena'@>=
bool Wdestroy_arena(void *arena){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  size_t M = header -> total_size;
  bool ret = true;
  @<Ending `*mutex'@>
  if(header -> total_size != header -> remaining_space +
     sizeof(struct arena_header))
    ret = false;
#if defined(W_DEBUG_MEMORY)
  printf("Unused memory: %zu/%zu (%f%%)\n",
         header -> smallest_remaining_space, header -> total_size,
         100.0 *
         ((float) header -> smallest_remaining_space) / header -> total_size);
#endif
  @<Deallocate 'arena' of size 'M' bytes@>
  return ret;
}
@
\fimcodigo

If we are in debug mode, we need to include the correct header to
print messages in the screen:

\iniciocodigo
@<Include Headers@>+=
#if defined(W_DEBUG_MEMORY)
#include <stdio.h>
#endif
@
\fimcodigo

\subsecao{2.6. Keeping Memory Alignment in Allocations}

When we allocate new memory, we begin with an available address $p$ in
which we will put our allocated memory. But we should respect the
alignment $a$: a power of two or the number zero (meaning ``any
alignment''). How to do this depends if we are in the left stack
(initial positions in the arena) or right stack (ending positions in
the arena). One of the stacks grows from lesser to greater addresses
and the other grows form greater to lesser addresses.

In the left stack, we want to put our allocation in the address $p$,
but we may need to shift $p$ by some positions to respect the
alignment. We consider that $a-1$ is the worst case of how many bytes
we need to shift. As $a$ is a power of two, $a-1$ is also a bitmask of
what bits should be zero in the final address. Using these
informations, we can ensure memory alignment with:

\iniciocodigo
@<Align `p' and store `offset' according with `a' (left)@>=
offset = 0;
if (a > 1){
  void *new_p = ((char *) p) + (a - 1);
  new_p = (void *) (((uintptr_t) new_p) & (~((uintptr_t) a - 1)));
  offset = ((char *) new_p) - ((char *) p);
  p = new_p;
}
@
\fimcodigo

We need the casting to \monoespaco{uintptr\_t} because we want to do
bit-to-bit operations in pointers. So we need the header below:

\iniciocodigo
@<Include Headers@>+=
#include <stdint.h>
@
\fimcodigo

In the right stack, we will try to allocate in address $p$, but we
probably need to lower the initial address to keep the alignment. So
we don't need to sum the initial address with the worst case value
$a-1$. We can just remove directly the ending bits of using bit
mask $a-1$:

\iniciocodigo
@<Align `p' and store `offset' according with `a' (right)@>=
offset = 0;
if (a > 1){
  void *new_p = (void *) (((uintptr_t) p) & (~((uintptr_t) a - 1)));
  offset = ((char *) p) - ((char *) new_p);
  p = new_p;
}
@
\fimcodigo

\subsecao{2.7. Allocating Memmory}

Before memory allocation, we need to check if we have enough space in
the arena. We just need to read values from arena header and compare
them with the value which we need to allocate, considering the worst
case in alignment, where we need additional $a-1$ bytes. If we don't
have enough space, we need to return \monoespaco{NULL}.

f we are allocating in the left stack, our allocation address will be
the next position after the header and previously allocated blocks
after passing for alignment correction. We also need to update how
many bytes are already allocated in
variable \monoespaco{left\_allocations}.

If we are allocating in the right stack, we check the next free region
stored in the header and subtract from the address the size of the new
allocation minus 1. This ensure that the allocated region have he
right size and that the found address can be returned to the user. Of
course, before returning we also need to do the alignment
correction. And as we are updating the right stack, we store the new
allocation size in the variable \monoespaco{right\_allocations}.

Once this is done, we only need to update in the arena header what are
the next free regions, as we occupied the previous one. We also need
to compute a newvalue for variable \monoespaco{remaining\_space}. Only
after this we can return \monoespaco{p}.

\iniciocodigo
@<Allocating `p' with size `t' in `arena', alignment `a'@>=
{
  int offset;
  struct arena_header *header = (struct arena_header *) arena;
  if(header -> remaining_space >= t + ((a == 0)?(0):(a - 1))){
    if(right){
      p = ((char *) header -> right_free) - t + 1;
      @<Align `p' and store `offset' according with `a' (right)@>
      header -> right_free = (char *) p - 1;
      header -> right_allocations += (t + offset);
    }
    else{
      p = header -> left_free;
      @<Align `p' and store `offset' according with `a' (left)@>
      header -> left_free = (char *) p + t;
      header -> left_allocations += (t + offset);
    }
    header -> remaining_space -= (t + offset);
#if defined(W_DEBUG_MEMORY)
    if(header -> remaining_space < header -> smallest_remaining_space)
      header -> smallest_remaining_space = header -> remaining_space;
#endif
  }
}
@
\fimcodigo

\subsecao{2.8. The Walloc Function}

We can combine the previous code to define the allocation function. It
will get \monoespaco{arena} (the arena where we will allocate),
\monoespaco{a} (the alignment), \monoespaco{right} (1 if we should
allocate in the right stack and 0 if we should allocate in the left
stack) and \monoespaco{t} (size in bytes for the region to be
allocated).

First we use a ``wait'' in the arena mutex. After we do the allocation
and then use a ``signal'' to free the mutex. We also need a
variable \monoespaco{p} to be returned and tha should point to the
newly allocated memory.

\iniciocodigo
@<Definition for `Walloc'@>=
void *Walloc(void *arena, unsigned a, int right, size_t t){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  void *p = NULL;
  @<`*mutex':WAIT()@>
  @<Allocating `p' with size `t' in `arena', alignment `a'@>
  @<`*mutex':SIGNAL()@>
  return p;
}
@
\fimcodigo

\subsecao{2.9. Definition for Memory Points}

If we have an arena that is being utilized and is storing allocated
regions, but we want to free at once all allocations and restart the
arena, we could do this just restarting the values stored in arena
header. The pointers for the next free regions and the variable with
the remaining free space should also be reset to the initial values.

If we are interested not in restart all the arena, but just the left
of right stack, we can just check how many bytes were allocated in the
corresponding stack thanks for the
variables \monoespaco{right\_allocations}
and \monoespaco{left\_allocations} stored in arena header. These
values can be easily reseted and this empties only the corresponding
stack:


\iniciocodigo
@<Restart memory in stack from `arena'@>=
{
  struct arena_header *header = arena;
  if(right){
    header -> right_free = ((char *) arena) + header -> total_size - 1;
    header -> remaining_space += header -> right_allocations;
    header -> right_allocations = 0;
  }
  else{
    header -> left_free = ((char *) arena) + sizeof(struct arena_header);
    header -> remaining_space += header -> left_allocations;
    header -> left_allocations = 0;
  }
}
@
\fimcodigo

But what if instead of resetting all allocations we were interested in
restore the state to a previous one saved in the past? We call the
previous state a ``memory point''. To save the state, we need only to
store the content of variables \monoespaco{left\_allocations} for the
left stack and \monoespaco{right\_allocations} for the right stack.

The pointer for the next free region \monoespaco{left\_free}
or \monoespaco{right\_free} can be updated moving it a number of
positions equal to the difference between the current quantity of
allocated memory and the quantity from a previous memory point.

Howeber, we want to store not a single one memory point, but a list of
them. We can organize all stored memory points as a linked list. So we
can define a memory point with the following header:

\iniciocodigo
@<Memory Point Header@>=
struct memory_point{
  size_t allocations; // Left or right
  struct memory_point *last_memory_point;
};
@
\fimcodigo

\subsecao{2.10. Creating a Memory Point}

Creating memory points means calling \italico{wait} for the mutex,
allocate memory for the memory point, initialize it and update
information in the arena about what is the last memory point, noting
if we stored it in the left or right stack. Finally we free the mutex
with \italico{signal}:

\iniciocodigo
@<Definition for `Wmempoint'@>=
bool Wmempoint(void *arena, unsigned a, int right){
  struct arena_header *header = (struct arena_header *) arena;
  void *mutex = (void *) &(header -> mutex);
  char *p = NULL;
  struct memory_point *point;
  size_t allocations, t = sizeof(struct memory_point);
  @<`*mutex':WAIT()@>
  if(right)
    allocations = header -> right_allocations;
  else
    allocations = header -> left_allocations;
  @<Allocating `p' with size `t' in `arena', alignment `a'@>
  point = (struct memory_point *) p;
  if(point != NULL){
    point -> allocations = allocations;
    if(right){
      point -> last_memory_point = header -> right_point;
      header -> right_point = point;
    }
    else{
      point -> last_memory_point = header -> left_point;
      header -> left_point = point;
    }
  }
  @<`*mutex':SIGNAL()@>
  if(point == NULL)
    return false;
  return true;
}
@
\fimcodigo

\subsecao{2.10. Restoring a Memory Point}

Restore a memory point means restoring the state of the memory stack
(at left or right) exactly as it was before saving the last memory
point. If here is no memory point saved, we empty all the memory
stack. For this we use the function \monoespaco{Wtrash}:

\iniciocodigo
@<Definition for `Wtrash'@>+=
void Wtrash(void *arena, int right){
  struct arena_header *head = (struct arena_header *) arena;
  void *mutex = (void *) &(head -> mutex);
  struct memory_point *point;
  @<`*mutex':WAIT()@>
  if(right){
    point = head -> right_point;
  }
  else{
    point = head -> left_point;
  }
  if(point == NULL){
    @<Restart memory in stack from `arena'@>
  }
  else{
    if(right){
      head -> remaining_space += (head -> right_allocations -
                                  point -> allocations);
      head -> right_point = point -> last_memory_point;
      head -> right_allocations = point -> allocations;
    }
    else{
      head -> remaining_space += (head -> left_allocations -
                                  point -> allocations);
      head -> left_point = point -> last_memory_point;
      head -> left_allocations = point -> allocations;
    }
  }
  @<`*mutex':SIGNAL()@>
}
@
\fimcodigo


\subsecao{2.11. Final Organization of Source File}

We save all the code for function definition in the file below to be
compiled:

\iniciocodigo
@(src/memory.c@>=
@<Include Headers@>
#include "memory.h"
@<Arena Header@>
@<Memory Point Header@>
@<Definition for `Wcreate\_arena'@>
@<Definition for `Wdestroy\_arena'@>
@<Definition for `Walloc'@>
@<Definition for `Wmempoint'@>
@<Definition for `Wtrash'@>
@
\fimcodigo

\secao{3. Performance}

We measure the performance of this code with a prgram which runs the
functions defined here one hundred thousand times and we measure the
mean and standard deviation comparing our measures with measures for
the functions \monoespaco{malloc} and \monoespaco{free} from the
standard system library. Measures with higher standard deviations
were discarded and not considered as we assumed that in these cases
the Operating System probably was running jobs not related with our
functions and these parallel jobs interferred with the measures.

In all these allocations, we choosed the value of 5 KiB expecting that
with this size we avoid penalties for some \monoespaco{malloc}
implementations with problems with memory alignment. At the same time
this was expected to be higher enough to make \monoespaco{malloc}
implementations ask for more memory to the Operating System, as this
value is higher than the page system in the tested system. In the
function \monoespaco{Walloc}, we opted for always use the left stack,
as this should be the faster stack benefiting from spatial locality.

It's important to notice that while the functions defined here in this
document were desgned to run in constant time, independent of
allocation size, the \monoespaco{malloc} and \monoespaco{free}
functions of operating systems not always follow the same
philosophy. During our measures, the allocation size was increased to
check if this affected execution times. When a function don't run in
constant time, we measured for which values the function has an
equivalent performance and for which the performance was worst. But we
didn't risked more precise predictions about its behaviour, as this
would require analysis of its implementation.


\subsecao{3.1. OpenBSD}

In OpenBSD 6.4 the function \monoespaco{free} don't appear to run in
constant time for different allocations size. The running time appears
to grow linearlly when the allocaton size grows exponentially, which
implies a logarithmic complexity. In the machine where the tests were
performed, we got equivalent performance with our implementations only
when the deallocated space had a size of about 100 bytes. With
allocations of 5 KiB repeated a hundres thousand times, the result is
shown below.

For small values, the function \monoespaco{malloc} shows a performance
equivalent than \monoespaco{\_Walloc}, indicating that the lesser
performance shown in this table is because of the coast for asking
more memory for the Operating System with a system call. Contrary to
function \monoespaco{free}, in \monoespaco{malloc} we didn't find a
growth in running time when we increased the allocated size.

% http://gnuplot.sourceforge.net/demo/transparent.html

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth OpenBSD Function\hidewidth&&\omit\hidewidth
Mean ($\mu$s)\hidewidth&&
\omit\hidewidth Standard Deviation ($\mu$s)\hidewidth&\cr\linha
&&\monoespaco{malloc}&&6,30530874&&25,124535168&\cr\linha
&&\monoespaco{free}&&22,00978538&&12,809965439&\cr\linha
&&\monoespaco{\_Walloc}&&2,50560902&&0,228082461&\cr\linha
&&\monoespaco{\_Wmempoint}&&2,26598656&&0,505975457&\cr\linha
&&\monoespaco{\_Wtrash}&&2,22814472&&0,166606876&\cr\linha}}

We can observe the difference between the functions in the graphic
below which shows the probability density for each funcion above
running in a given interval in microseconds according with the above
data:

\imagem{images/openbsd.eps}

Our functions almost always run in less than 3 microseconds while the
native functions running time distribution is next to linear between 0
and a maximum value. The standard deviation here is relevant, as it
interfere with the worst case observed and this should be taken in
consideration evaluating the performance of this function.

\subsecao{3.2. Linux (Ubuntu 19.04)}

Ao contrário do OpenBSD que implementa medidas adicionais no alocador
de memória para randomizar os endereços obtidos e que sempre retorna
imediatamente a memória liberada para o kernel, o Linux tem suas
funções mais orientadas a ter um desempenho maior, mesmo que com menos
medidas de segurança. Todas as funções estadas demonstram executar em
tempo constante no Linux. Os dados obtidos são:

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Função Linux\hidewidth&&\omit\hidewidth
Média ($\mu$s)\hidewidth&&
\omit\hidewidth Desvio Padrão ($\mu$s)\hidewidth&\cr\linha
&&\monoespaco{malloc}&&2,71246735&&0,801445880&\cr\linha
&&\monoespaco{free}&&0,87757830&&0,141186377&\cr\linha
&&\monoespaco{\_Walloc}&&0,76750440&&0,218803555&\cr\linha
&&\monoespaco{\_Wmempoint}&&0,75614315&&0,155982817&\cr\linha
&&\monoespaco{\_Wtrash}&&0,75579410&&0,066124620&\cr\linha}}

Todas as funções então apresentam um desempenho bastante semelhante,
pró\-xi\-mo de 1 microssegundo de tempo. Só a
função \monoespaco{malloc} da biblioteca padrão que apresenta um
desempenho pior e com maior variação. Comparando os piores casos, a
nossa função \monoespaco{\_Walloc} executa cerca de quatro vezes mais
rápido.

\imagem{images/linux.eps}

\subsecao{3.3. Windows 10}

O Windows 10 se destaca por ter tempos médios relativamente baixos em
suas funções, mas desvios padrão altos, o que indica que embora o
desempenho seja alto, ocasionalmente pode-se ter azar e ter que passar
por uma espera maior para que a chamada de sistema termine devolvendo
a memória pedida. Apesar dos tempos baixos de execução das funções de
gerenciamento de memória, nossa implementação conseguiu tempos ainda
menores e sem o problema do desvio padrão alto.

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Função Windows\hidewidth&&\omit\hidewidth
Média ($\mu$s)\hidewidth&&
\omit\hidewidth Desvio Padrão ($\mu$s)\hidewidth&\cr\linha
&&\monoespaco{malloc}&&1,59881&&11,466939064&\cr\linha
&&\monoespaco{free}&&0,57427&&9.402517112&\cr\linha
&&\monoespaco{\_Walloc}&&0,00003&&0.005477171&\cr\linha
&&\monoespaco{\_Wmempoint}&&0,00515&&0,233332428&\cr\linha
&&\monoespaco{\_Wtrash}&&0,00045&&0,097825831&\cr\linha}}

O comportamento das funções no Windows parece indicar uma diferença de
filosofia na implementação comparada à implementação Linux. No Windows
a prioridade parece ser deixar o tempo médio das funções menor, mesmo
que para isso tenha-se que lidar com um pior caso muito ruim, mas que
dificilmente acontece. No Linux a prioridade era evitar surpresas
ruins com o pior caso, mesmo que para isso o tempo médio de execução
fique um pouco maior.

\imagem{images/windows.eps}

\subsecao{3.4. Web Assembly (Firefox Quantum 67.04)}

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Web Assembly
(Firefox)\hidewidth&&\omit\hidewidth Média ($\mu$s)\hidewidth&&
\omit\hidewidth Desvio Padrão ($\mu$s)\hidewidth&\cr\linha
&&\monoespaco{malloc}&&2,399475651&&48.931141529&\cr\linha
&&\monoespaco{free}&&0,489213791&&22,130980751&\cr\linha
&&\monoespaco{\_Walloc}&&0,394548569&&19,744325980&\cr\linha
&&\monoespaco{\_Wmempoint}&&0,451152325&&21,208728454&\cr\linha
&&\monoespaco{\_Wtrash}&&0,398001614&&19,744481718&\cr\linha}}

\imagem{images/web_firefox.eps}

Executando em um ambiente Web Assembly em um navegador de Internet,
compreensivelmente todas as funções passaram a ter desvio padrão
maior. A surpresa é que o tempo médio muitas vezes foi menor comparado
ao do Sistema Operacional (os testes de Web Assembly foram feitos no
Linux) e as nossas funções, ainda demonstraram desvio menor que as
funções da biblioteca do sistema.

No gráfico não é possível distinguir as funções \monoespaco{\_Walloc}
e \monoespaco{\_Wtrash}, já que ambas tiveram comportamento praticamente
idêntico nos testes.

\subsecao{3.5. Web Assembly (Microsoft Edge 40.15254.369)}

Executando o código em Web Assembly no Microsoft Edge do Windows 10
tivemos um desempenho semelhante ao Web Assembly do Firefox. A
diferença é que as funções tendem a gastar um tempo um pouco mais
previsível, com um desvio padrão menor. O tempo médio ficou apenas
ligeiramente menor. Aqui o \monoespaco{malloc} sendo executado no
navegador de Internet teve um desempenho médio melhor que
o \monoespaco{malloc} executando nativamente.

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Web Assembly
(Edge)\hidewidth&&\omit\hidewidth Média ($\mu$s)\hidewidth&&
\omit\hidewidth Desvio Padrão ($\mu$s)\hidewidth&\cr\linha
&&\monoespaco{malloc}&&1,075476093&&36,039479231&\cr\linha
&&\monoespaco{free}&&0,620922375&&24,892216258&\cr\linha
&&\monoespaco{\_Walloc}&&0,366360054&&18,970295969&\cr\linha
&&\monoespaco{\_Wmempoint}&&0,346548996&&19,232215457&\cr\linha
&&\monoespaco{\_Wtrash}&&0,302235565&&17,317682053&\cr\linha}}

O gráfico abaixo está exatamente na mesma escala que o anterior do
desempenho no Firefox.

\imagem{images/web_edge.eps}

\secao{4. Conclusão}

Em todos os casos de teste, as funções que desenvolvemos apresentaram
um desempenho de tempo melhor e mais previsível em comparação às
funções de gerenciamento de memória nativas. O desempenho ocorre
principalmente devido a não precisarmos realizar chamadas de sistema
para alocar mais memória, uma chamada de sistema ocorre na
inicialização e depois disso apenas gerenciamos esta mesma memória
alocada.

Isso traz a desvantagem de termos que especificar logo no começo da
execução de um programa qual a quantidade máxima de memória que ele
poderá usar. Outra desvantagem existente é não termos mais acesso à
uma função \monoespaco{free}. Toda a desalocação deve ocorrer em
blocos. Em aplicações que podem se adaptar à este esquema, elas podem
obter melhoras de desempenho ainda maiores, pois sucessivas chamadas
de uma função \monoespaco{free} podem ser substituídas por uma só
chamada de função \monoespaco{\_Wtrash}.

Em alguns casos, pode-se usar em
sequência \monoespaco{\_Wmempoint}, \monoespaco{\_Walloc}
e \monoespaco{\_Wtrash} para simular um uso de \monoespaco{malloc}
seguido de \monoespaco{free} para quando quer se alocar algo
temporariamente para ser desalocado em seguida. Para este caso, em
todos os sistemas testados chamar as três primeiras funções é mais
rápido que chamar as duas últimas e o desempenho continua melhor.

Todas as desvantagens expostas não são um problema em algumas
aplicações como o desenvolvimento de jogos. Neles de qualquer forma
não se deve usar mais recursos do que o que é especificado de antemão
e a estrutura de um jogo se adapta à um gerenciador de memória baseado
em pilhas de alocação. O uso das funções definidas aqui pode então
trazer vantagens como diminuição de tempo de carregamento de recursos
graças à alocações mais rápidas, que em um jogo tipicamente ocorrem na
inicialização de um novo cenário ou fase do jogo.

\secao{Referências}

\referencia{Gregory, J. (2019) ``Game Engine Architecture'', CRC Press, terceira
edição.}

\referencia{Zakai, A. (2011) ``Emscripten: an LLVM-to-JavaScript compiler'',
Proceedings of the ACM international conference companion on Object
oriented programming systems languages and applications companion,
p. 301--312.}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer Journal,
volume 27, edição 2, p. 97--111}

\referencia{Ranck, S. (2000) ``Game Programming Gems'', Charles River Media,
volume 1, edição 1, p. 92--100}





\fim
