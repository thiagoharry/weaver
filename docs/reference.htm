<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Weaver Reference Guide</title>
    <link rel="stylesheet" href="weaver.css">
  </head>
  <body>
    <header>
      <h1><a href="index.htm">Weaver: A Game Engine for GNU/Linux</a></h1>
      <span class="menu">
        <a href="documentation.htm">Documentation</a>
        <a href="tutorial.htm">Tutorial</a>
        <a href="examples.htm">Examples</a>
        <a href="download.htm">Download</a>
      </span>
    </header>
    <div class="docs">
      <h2>Weaver Reference Guide</h2>
      <p>
        This page lists all functions and data structures defined in
        Weaver API. We use the following icons to help you check some
        properties of the variables in Weaver API:
      </p>
      <ul>
        <li><img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only">: This variable is
          read-only. Never try to change it's value.</li>
        <li>
          <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only">: This variable or
               function should be run or read only inside a main
               loop.
        </li>
        <li>
          <img class="icon" src="images/not_thread.png" width="25px"
               height="25px" title="Not thread-safe">: This function
               is not thread-safe.
        </li>
      </ul>
      <h3>Index</h3>
      <ol>
        <li><a href="#basic">Basic Functions and Variables</a></li>
        <ol>
          <li><a href="#basic_variable">Variables</a></li>
          <ol>
            <li><a href="#W">W</a></li>
            <li><a href="#game">W.game</a></li>
            <li><a href="#t">W.t</a></li>
            <li><a href="#dt">W.dt</a></li>
          </ol>
          <li><a href="#basic_functions">Functions</a></li>
          <ol>
            <li><a href="#Walloc">Walloc</a></li>
            <li><a href="#Wexit">Wexit</a></li>
            <li><a href="#Wexit_loop">Wexit_loop</a></li>
            <li><a href="#Wfree">Wfree</a></li>
            <li><a href="#Winit">Winit</a></li>
            <li><a href="#Wloop">Wloop</a></li>
            <li><a href="#Wsubloop">Wsubloop</a></li>
          </ol>
        </ol>
        <li><a href="#numeric">Numeric Functions and
            Variables</a></li>
        <ol>
          <li><a href="#numeric_functions">Functions</a>
            <ol>
              <li><a href="#random">W.random</a>
            </ol>
        </ol>
        <li><a href="#window">Window and Screen</a></li>
        <ol>
          <li><a href="#window_variables">Variables</a></li>
          <ol>
            <li><a href="#framerate">W.framerate</a></li>
            <li><a href="#width">W.height</a></li>
            <li><a href="#resolution_x">W.resolution_x</a></li>
            <li><a href="#resolution_y">W.resolution_y</a></li>
            <li><a href="#width">W.width</a></li>
            <li><a href="#x">W.x</a></li>
            <li><a href="#y">W.y</a></li>
          </ol>
          <li><a href="#window_functions">Functions</a></li>
          <ol>
            <li><a href="#move_window">W.move_window</a></li>
            <li><a href="#resize_window">W.resize_window</a></li>
          </ol>
        </ol>
        <li><a href="#input">User Input</a></li>
        <ol>
          <li><a href="#input_variables">Variables</a></li>
          <ol>
            <li><a href="#keyboard">W.keyboard</a></li>
            <li><a href="#mouse">W.mouse</a></li>
          </ol>
          <li><a href="#input_functions">Functions</a></li>
          <ol>
            <li><a href="#hide_cursor">W.hide_cursor</a></li>
          </ol>
        </ol>
        <li><a href="#scheduling">Scheduling</a></li>
        <ol>
          <li><a href="#scheduling_functions">Scheduling
              Functions</a></li>
          <ol>
            <li><a href="#cancel">W.cancel</a></li>
            <li><a href="#period">W.period</a></li>
            <li><a href="#run_futurelly">W.run_futurelly</a></li>
            <li><a href="#run_periodically">W.run_periodically</a></li>
          </ol>
        </ol>
        <li><a href="#plugins">Plugins</a></li>
        <ol>
          <li><a href="#plugins_functions">Plugin Functions</a></li>
          <ol>
            <li><a href="#disable_plugin">W.disable_plugin</a></li>
            <li><a href="#enable_plugin">W.enable_plugin</a></li>
            <li><a href="#get_plugin">W.get_plugin</a></li>
            <li><a href="#get_plugin_data">W.get_plugin_data</a></li>
            <li><a href="#is_plugin_enabled">W.is_plugin_enabled</a></li>
            <li><a href="#reload_all_plugins">W.reload_all_plugins</a></li>
            <li><a href="#reload_plugin">W.reload_plugin</a></li>
            <li><a href="#set_plugin_data">W.set_plugin_data</a></li>
          </ol>
        </ol>
        <li><a href="#interfaces">Interfaces</a></li>
        <ol>
          <li><a href="#interfaces_records">Records</a></li>
          <ol>
            <li><a href="#struct_interface">struct interface</a></li>
          </ol>
          <li><a href="#interface_functions">Interface
              Functions</a></li>
          <ol>
            <li><a href="#copy_interface">W.copy_interface</a></li>
            <li><a href="#destroy_interface">W.destroy_interface</a></li>
            <li><a href="#move_interface">W.move_interface</a></li>
            <li><a href="#new_interface">W.new_interface</a></li>
            <li><a href="#resize_interface">W.resize_interface</a></li>
            <li><a href="#rotate_interface">W.rotate_interface</a></li>
          </ol>
        </ol>
        <li><a href="#shader">Shaders</a></li>
        <ol>
          <li><a href="#shader_variables">Shader Variables</a></li>
          <ol>
            <li><a href="#final_shader_integer">W.final_shader_integer</a></li>
          </ol>
          <li><a href="#shader_functions">Shader Functions</a></li>
          <ol>
            <li><a href="#change_final_shader">W.change_final_shader</a></li>
          </ol>
        </ol>
        <li><a href="#sound">Sound</a></li>
        <ol>
          <li><a href="#sound_records">Sound Records</a></li>
          <ol>
            <li><a href="#struct_sound">struct sound</a></li>
          </ol>
          <li><a href="#sound_variables">Sound Variables</a></li>
          <li><a href="#sound_functions">Sound Functions</a></li>
        </ol>
      </ol>
      <h3 id="#basic">Basic Functions and Variables</h3>
      <h4 id="basic_variable">Variables</h4>
      <h5 id="W">struct W <img class="icon" src="images/read_only.png"
             width="25px" height="25px" title="Read-only"></h5>
      <p>
        The <tt>W</tt> struct is a struct where you can find almost
        all the variables and functions defined by Weaver API. It's
        main function is act as a namespace, avoiding conflicts
        between user variable names and the API names. Almost all
        variables and functions listed in this page is
        inside <tt>W</tt>.
      </p>
      <p>
        Another advantage of defining almost all variables and
        functions inside this struct it's that we can pass the struct
        to plugins and then they can have access to all Weaver
        functions and variables.
      </p>
      <p>
        Usually you shouldn't worry about the <tt>W</tt> struct and
        never should need to pass it directly to some function. You
        just invoke it's functions and access it's variables.
      </p>
      <h5 id="game">struct _game_struct *W.game</h5>
      <p>
        This is just a pointer to the struct defined
        at <tt>src/game.h</tt> in your project. You decide which
        variables you create and define in this struct. This
        user-defined struct is a way to store your game's global
        variables and also where you put data that should be
        accessible for plugins.
      </p>
      <h5 id="t">unsigned long long W.t <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This variable hold the times in microseconds since the
        program's initialization. A microsecond is 0.000001 second. So
        if you wish to know the value in seconds, you should divide it
        by 1,000,000.
      </p>
      <p>
        As this value is at least 64-bits long, this would overflow
        only after more than 500,000 years.
      </p>
      <h5 id="dt">unsigned long long W.dt <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This variable holds the time in microseconds between the
        current main loop iteration and the previous loop
        iteration. As Weaver uses a fixed time step to run C code in
        the game loop, it's value should always be about 40,000, wich
        means that your C-code is running at 25 frames per second (but
        the game probably is rendering at a higher rate).
      </p>
      <p>
        If you check this value and it has a value much higher than
        40,000, it means that your game is running slowly. You should
        then do something like render less things, lower the
        resolution or the ammount of calculations in each frame.
      </p>
      <h4 id="basic_functions">Functions</h4>
      <h5 id="Walloc">void *Walloc(size_t size)</h5>
      <p>
        This function is like <tt>malloc</tt>, but the memory
        allocated is handled by Weaver's memory manager and usually
        don't need to be manually freed. The gargage collector
        will take away the memory allocated when you exit the current
        main loop.
      </p>
      <p>
        You should free the memory only if you use this function
        outside a main loop. Or if you just allocated the memory but
        won't need it anymore. In this case, use
        the <a href="#Wfree">Wfree</a> function.
      </p>
      <p>
        Weaver garbage collector runs when you call the functions
        <a href="#Wloop">Wloop</a> (except in the first invocation)
        and <a href="#Wexit_loop">Wexit_loop</a>.
      </p>
      <p>
        <b>Tip:</b> Avoid calling <tt>Walloc</tt> in a main loop
        body. This leads to memory leaks. It's better to allocate a
        pool of objects in the loop initialization and then in the
        loop body you check which objects in the pool are initialized
        and should be handled.
      </p>
      <h5 id="Wexit">void Wexit(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
               title="Not thread-safe"></h5>
      <p>
        This function exits the game immediately. The game window is
        closed and the program exits if applicable. You can't access
        any variable or function listed here after
        calling <tt>Wexit</tt>.
      </p>
      <h5 id="Wexit_loop">void Wexit_loop(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                               title="Not
                                                      thread-safe">
      <img class="icon" src="images/loop.png" width="25px"
             height="25px" title="Main loop only"></h5>
      <p>
        This function exits the current main loop, remove it from the
        stack and resume the execution of the next main loop in the
        stack. If there's just one main loop in the stack when this
        function is called, then it just exits the game.
      </p>
      <p>
        The garbage collector frees all the memory allocated in a loop
        when you call this function. To know more about main loops,
        please check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Wfree">void Wfree(void *memory)</h5>
      <p>
        This function frees the memory allocated
        with <a href="#Walloc">Walloc</a>. Call this only if the
        memory was allocated outside a main loop or it was allocated
        in the same main loop where we currently are. Otherwise, you
        risk calling the function in a memory already freed by the
        garbage collector.
      </p>
      <p>
        When in doubt, don't use <tt>Wfree</tt>. Just let the garbage
        collector do the work. If your
        macro <a href="configuration.htm#W_DEBUG_LEVEL">W_DEBUG_LEVEL</a>
        is greater than 0, then Weaver will print a warning in the
        screen if it detects a memory leak while exiting the game.
      </p>
      <p>
        To check how the garbage collector and the memory in Weaver
        works, check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Winit">void Winit(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                          title="Not thread-safe"></h5>
      <p>
        This is the first function you should call in a Weaver
        program. Only after calling this function you can call any
        other function listed here or read any Weaver variable.
      </p>
      <p>
        This is the function who creates a new window according with
        the configurations in <tt>conf/conf.h</tt>.
      </p>
      <h5 id="Wloop">void Wloop(MAIN_LOOP (*loop)(void))<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                          title="Not
                                                 thread-safe"></h5>
      <p>
        If this function is called outside a main loop, it puts the
        loop received as argument in the loop stack and executes it.
        If this function is called inside a main loop, it stops the
        execution of the current loop, removes it from the stack, put
        the received loop in the stack and executes it. In other
        words, it substitute the current loop by the loop passed as
        argument.
      </p>
      <p>
        A main loop is where a game spends almost all the time, where
        we can get player's input and update the screen showing the
        objects created.
      </p>
      <p>
        To know more how main loops work in Weaver,
        check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Wsubloop">void Wsubloop(MAIN_LOOP
               (*loop)(void))<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
               title="Not thread-safe"><img class="icon"
               src="images/loop.png" width="25px" height="25px"
                                            title="Main loop only"></h5>
      <p>
        This function pauses the execution of the current main loop,
        put the loop received as argument in the loop stack and
        executes it.
      </p>
      <p>
        It doesn't destroy the previous loop. So the garbage collector
        won't free the memory allocated in that loop.
      </p>
      <p>
        To know more how main loops work in Weaver,
        check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h3 id="numeric">Numeric Variables and Functions</h3>
      <h4 id="numeric_functions">Numeric Functions</h4>
      <h5 id="random">unsigned long W.random(void)</h5>
      <p>
        This function uses a variation of the Mersenne Twister
        algorithm to generate a 32-bits pseudo-random number. If you
        want your game to always use the same seed, set the
        macro <a href="configuration.htm#W_SEED">W_SEED</a>
        at <tt>conf/conf.h</tt>, otherwise Weaver tries to use an
        unpredictable seed, as a value read from <tt>/dev/urandom</tt>
        or the current time in milisseconds.
      </p>
      <h3 id="window">Window and Screen</h3>
      <h4 id="window_variables">Window and Screen Variables</h4>
      <h5 id="framerate">int W.framerate <img class="icon"
                                       src="images/read_only.png"
                                       width="25px" height="25px"
                                              title="Read-only"></h5>
      <p>
        This variable holds the screen frame rate, the frequency at
        which consecutive images are displayed in your screen. Usually
        it's value is 60, which means that your screen is updated once
        each 0.017 second. Of course there are machines where this
        value can be different.
      </p>
      <p>
        Don't trust in this variable f your game was compiled to a web
        browser. There's no reliable way to discover the frame rate
        inside a web browser and so Weaver just guesses the value as
        60.
      </p>
      <h5 id="width">int W.height <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                       title="Read-only"></h5>
      <p>
        This variable holds the height your game have in pixels. It
        starts with the value defined in
        macro <a href="configuration.htm#W_HEIGHT">W_HEIGHT</a>. The
        value will keep updated if your window changes the size
        (either because the user resized the window or because you
        called the
        function <a href="#resize_window">W.resize_window</a>).
      </p>
      <p>
        If your game was compiled to a Web Browser, this variable
        holds the height of the canvas where your game is being drawn.
      </p>
      <h5 id="resolution_x">int W.resolution_x <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                             title="Read-only"></h5>
      <p>
        This variable holds your screen horizontal resolution. The
        width a full screen window would have in the screen. If your
        program is running in a web browser, this variable holds the
        width of the web browser window excluding toolbars and
        scrollbars (the same value present in
        Javascript's <tt>window.innerWidth</tt>).
      </p>
      <h5 id="resolution_y">int W.resolution_y <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                             title="Read-only"></h5>
      <p>
        This variable holds your screen vertical resolution. The
        height a full screen window would have in the screen. If your
        program is running in a web browser, this variable holds the
        height of the web browser window excluding toolbars and
        scrollbars (the same value present in
        Javascript's <tt>window.innerHeight</tt>).
      </p>
      <h5 id="width">int W.width <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                      title="Read-only"></h5>
      <p>
        This variable holds the width your game have in pixels. It
        starts with the value defined in
        macro <a href="configuration.htm#W_WIDTH">W_WIDTH</a>.  The
        value will keep updated if your window changes the size
        (either because the user resized the window or because you
        called the
        function <a href="#resize_window">W.resize_window</a>).
      </p>
      <p>
        If your game was compiled to a Web Browser, this variable
        holds the widtht of the canvas where your game is being drawn.
      </p>
      <h5 id="x">int W.x <img class="icon" src="images/read_only.png"
                              width="25px" height="25px"
                              title="Read-only"></h5>
      <p>
        This variable holds the horizontal position of your game
        window in the screen. This position is defined as the column
        where the pixel in the center of your window is. The leftmost
        column is the column 0 and the rightmost colummn has the
        number
        <a href="#resolution_x">W.resolution_x</a>-1.
      </p>
      <p>
        Inside a web browser, your game canvas can't move, so this
        variable is always assumed to have the value
        <a href="#resolution_x">W.resolution_x</a>/2 (Weaver assumes
        that the game canvas is centralized).
      </p>
      <p>
        Don't change this variable. If you want to move your window,
        call the function <a href="#move_window">W.move_window</a>.
      </p>
      <h5 id="y">int W.y <img class="icon" src="images/read_only.png"
                              width="25px" height="25px"
                              title="Read-only"></h5>
      <p>
        This variable holds the vertical position of your game window
        in the screen. This position is defined as the line where the
        pixel in the center of your window is. The bottom line is the
        line 0 and the top lline has the number
        <a href="#resolution_x">W.resolution_y</a>-1.
      </p>
      <p>
        Inside a web browser, your game canvas can't move, so this
        variable is always assumed to have the value
        <a href="#resolution_x">W.resolution_y</a>/2 (Weaver assumes
        that the game canvas is centralized).
      </p>
      <p>
        Don't change this variable. If you want to move your window,
        call the function <a href="#move_window">W.move_window</a>.
      </p>
      <h4 id="window_functions">Window Functions</h4>
      <h5 id="move_window">void W.move_window(int x, int y)</h5>
      <p>
        This function moves your game window for the giver
        coordinate. The position x and y are in pixels and the
        position (0, 0) is in the left lower part of your screen while
        the coordinate (<a href="#resolution_x">W.resolution.x</a>-1,
        <a href="#resolution_y">W.resolution.y</a>-1) is the right upper
        part of your screen.
      </p>
      <p>
        Moving a window to a coordinate means placing it's center in
        this coordinate.
      </p>
      <p>
        This function does nothing in a game compiled to a web
        browser.
      </p>
      <h5 id="resize_window">void W.resize_window(int width, int
        height)</h5>
      <p>
        This function resizes your game window. The width and height
        passed as arguments are in pixels. In a game compiled to a web
        browser, the function changes the size of the canvas where the
        game is drawn.
      </p>
      <h3 id="input">User Input</h3>
      <h4 id="input_variables">User Input Variables</h4>
      <h5 id="keyboard">long W.keyboard[] <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This array stores information about the user interaction with
        the keyboard. Each key has it's own position in the
        array. There's a set of macros created to help finding the
        right position in the array. To check if the key "A" is
        pressed, for example.  check <tt>W.keyboard[W_A]</tt>.
      </p>
      <p>
        Besides <tt>W_A</tt>, you can check also
        for <tt>W_B</tt>, <tt>W_C</tt>, and all other letters, you can
        also check the digits <tt>W_0</tt>, <tt>W_1</tt> and
        others. The keys F1, F2, F3 and others
        are <tt>W_F1</tt>, <tt>W_F2</tt>, <tt>W_F3</tt> and so on. The
        arrow keys
        are <tt>W_UP</tt>, <tt>W_RIGHT</tt>, <tt>W_LEFT</tt>
        and <tt>W_DOWN</tt>. The Esc key is <tt>W_ESC</tt>. The Enter
        key is <tt>W_ENTER</tt>, the spacebar is <tt>W_SPACEBAR</tt>
        and the backspace is <tt>W_BACKSPACE</tt>. You also
        have <tt>W_TAB</tt>, <tt>W_PAUSE</tt>, <tt>W_DELETE</tt>, <tt>W_SCROLL_LOCK</tt>, <tt>W_HOME</tt>, <tt>W_PAGE_UP</tt>, <tt>W_PAGE_DOWN</tt>, <tt>W_END</tt>,
        <tt>W_INSERT</tt> and <tt>W_NUM_LOCK</tt> for keys Tab, Home,
        Page Up, Page Down, End, Insert and Num Lock. And there's
        the <tt>W_PLUS</tt> for "+" and <tt>W_MINUS</tt> for "-".
      </p>
      <p>
        The keys Shift, Ctrl and Alt are a little different because
        they have a left and a right variety. If you don't care if the
        key pressed is left or right, you can
        check <tt>W_SHIFT</tt>, <tt>W_CTRL</tt> and <tt>W_ALT</tt>. If
        you want to check for the right version of these keys, check
        for <tt>W_RIGHT_SHIFT</tt>, <tt>W_RIGHT_CTRL</tt>
        and <tt>W_RIGHT_ALT</tt>. If you want to check the left
        variety, check <tt>W_LEFT_SHIFT</tt>, <tt>W_LEFT_CTRL</tt>
        and <tt>W_LEFT_ALT</tt>.
      </p>
      <p>
        You can also check if any key was pressed checking the
        position <tt>W_ANY</tt> in the array.
      </p>
      <p>
        If a key is not pressed, it's position in the keyboard array
        will have the value 0.
      </p>
      <p>
        If a key just started to be pressed in this frame (in this
        iteration in the main loop), it's position will store the
        value 1.
      </p>
      <p>
        If a key is being pressed, but the user didn't start to press
        it in this frame, it's position will store the number of
        microseconds since the user is pressing the key.
      </p>
      <p>
        If the user released a key in this frame, it's position will
        store (just in this frame) a negative value witch is -1
        multiplyed by the number of microseconds that the key was
        kept pressed.
      </p>
      <h5 id="mouse">struct W.mouse <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        The mouse is represented by the following struct:
      </p>
      <pre class="codigo">
<span class="tipo">struct</span>{
  <span class="tipo">long</span> buttons[];
  <span class="tipo">int</span> x, y, dx, dy, ddx, ddy;
} W.mouse;</pre>
      <p>
        Weaver assumes a mouse can have 5 buttons. You can check if
        some of these keys are being pressed checking the
        positions <tt>W_MOUSE_LEFT</tt> (mouse left
        button), <tt>W_MOUSE_MIDDLE</tt> (mouse middle
        button), <tt>W_MOUSE_RIGHT</tt> (mouse right button) and the
        aditional buttons <tt>W_MOUSE_B1</tt> and <tt>W_MOUSE_B2</tt>
        in the array <tt>W.mouse.buttons</tt>. Keep in mind that not
        everybody have access to all the buttons. And if the game was
        compiled to a web browser, we may not to be able to check for
        buttons <tt>W_MOUSE_B1</tt> and <tt>W_MOUSE_B2</tt>.
      </p>
      <p>
        If a mouse button is not pressed, it will have the value 0 in
        the array.
      </p>
      <p>
        If a mouse button starts to get pressed in this frame, it will
        have the value 1 in the array.
      </p>
      <p>
        If a mouse button is getting pressed for more than 1 frame, it
        will have the value of microseconds since the key started to
        be pressed.
      </p>
      <p>
        And if a mouse button is released in this frame, it will have
        a negative value of -1 multiplied by the number of
        microseconds that the button was kept pressed.
      </p>
      <p>
        The variables <tt>W.mouse.x</tt> and <tt>W.mouse.y</tt> stores
        thw mouse position in our game window. We considet the x axis
        as the horizontal axis and the y axis as the vertical
        axis. The position in the lower left of the window is (0,0)
        and the position in the upper right is
        (<a href="#width">W.width</a>-1, <a href="#height">W.height</a>-1).
      </p>
      <p>
        You can get the horizontal and vertical speed of the mouse in
        pixels per second checking the variables <tt>W.mouse.dx</tt>
        and <tt>W.mouse.dy</tt>.
      </p>
      <p>
        You can get the horizontal and vertical acceleration of the
        mouse in pixels per second squared checking the
        variables <tt>W.mouse.ddx</tt> and <tt>W.mouse.ddy</tt>.
      </p>
      <h4 id="input_functions">User Input Functions</h4>
      <h5 id="hide_cursor">void W.hide_cursor(void)</h5>
      <p>
        Makes the cursor hidden.
      </p>
      <h3 id="scheduling">Scheduling</h3>
      <h4 id="scheduling_functions">Scheduling Functions</h4>
      <h5 id="cancel">void W.cancel(void (*f)(void))<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        If you asked Weaver to run some function f periodically with
        <a href="#run_periodically">W.run_periodically</a> or in some
        moment in the future
        with <a href="#run_futurelly">W.run_futurelly</a>, you can
        cancel this passing the function f to W.cancel.
      </p>
      <p>
        If you pass a function not scheduled for future execution or
        an invalid pointer for this function, nothing happens.
      </p>
      <h5 id="period">float W.period(void (*f)(void))<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        If <b>f</b> is a function scheduled to be run periodically
        using <a href="#run_periodically">W.run_periodically</a>, this
        function returns the function period in seconds.
      </p>
      <p>
        If <b>f</b> is a function scheduled to be run once in some
        moment in the future
        with <a href="#run_futurelly">W.run_futurelly</a>, this
        function returns INFINITY.
      </p>
      <p>
        Otherwise, this function returns NaN.
      </p>
      <h5 id="run_futurelly">void W.run_futurelly(void (*f)(void),
               float s)<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        Run the function <b>f</b> in the future. Waits the number of
        seconds <b>s</b> passed as argument before executing the
        function.
      </p>
      <p>
        If the function <b>f</b> was already scheduled for execution,
        the entry in the scheduler is updated to transform the
        function in a non-periodic function.
      </p>
      <p>
        This function won't work if your scheduler has more than
        <a href="configuring.htm#W_MAX_SCHEDULING">W_MAX_SCHEDULING</a>
        waiting for execution.
      </p>
      <h5 id="run_periodically">void W.run_periodically(void (*f)(void),
               float s)<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        Run the function <b>f</b> periodically, every <b>s</b>
        seconds. The first execution will be <b>s</b> seconds after
        you call this function.
      </p>
      <p>
        If the function <b>f</b> was already scheduled for execution,
        the entry in the scheduler is updated to transform the
        function in a periodic function and it's period is also
        updated.
      </p>
      <p>
        This function won't work if your scheduler has more than
        <a href="configuring.htm#W_MAX_SCHEDULING">W_MAX_SCHEDULING</a>
        waiting for execution.
      </p>
      <h3 id="plugins">Plugins</h3>
      <h4 id="plugins_functions">Plugin Functions</h4>
      <h5 id="disable_plugin">bool W.disable_plugin(int id)</h5>
      <p>
        This function disables a plugin given it's id number and
        returns true if the opperation was successful. This function
        fails if a plugin id is invalid and returns false.
      </p>
      <p>
        Trying to disable an already disabled plugin does nothing (but
        the function returns true anyway.
      </p>
      <p>
        Immediately before the plugin is disabled, it executes it's
        function _disable_plugin_PLUGIN_NAME.  A disabled plugin won't
        run it's function _run_plugin_PLUGIN_NAME every iteration in
        the main loop. Check <a href="plugin.htm">Weaver Plugins</a>
        for more info.
      </p>
      <h5 id="enable_plugin">bool W.enable_plugin(int id)</h5>
      <p>
        This function enables a plugin given it's id number and
        returns true if the opperation was successful. This function
        fails if a plugin id is invalid and returns false.
      </p>
      <p>
        Trying to enable an already enabled plugin does nothing. But
        the function returns true anyway.
      </p>
      <p>
        Immediately after the plugin is enabled, it executes it's
        function _enable_plugin_PLUGIN_NAME.  An enabled plugin will
        run it's function _run_plugin_PLUGIN_NAME every iteration in
        the main loop. Check <a href="plugin.htm">Weaver Plugins</a>
        for more info.
      </p>
      <h5 id="get_plugin">int W.get_plugin(char *plugin_name)</h5>
      <p>
        Get a plugin id number given it's name. If a plugin is not
        found, this function returns -1.
      </p>
      <h5 id="get_plugin_data">void *W.get_plugin_data(int id)</h5>
      <p>
        This function stores some data previously stored with
        <a href="#set_plugin_data">W.set_plugin_data</a>, given a
        plugin id number.
      </p>
      <p>
        This function should be called by plugins, not by your
        program. It's how plugins should store data that should be
        preserved, even if the plugin is disabled or if the plugin is
        reloaded.
      </p>
      <h5 id="is_plugin_enabled">bool W.is_plugin_enabled(int id)</h5>
      <p>
        A simple test which returns true if a plugin is enabled and
        returns false otherwise. The plugin is identified by it's id
        number.
      </p>
      <h5 id="reload_all_plugins">void W.reload_all_plugins(void)</h5>
      <p>
        This function reloads all the existing plugins, updating them
        if they were recompiled. It also checks the directory
        <a href="configuring.htm#W_PLUGIN_PATH">W_PLUGIN_PATH</a> if
        there are new plugins. If it finds a new plugin, the function
        makes it accessible by <a href="#get_plugin">W.get_plugin</a>,
        allowing you to enable or disable the plugin.
      </p>
      <p>
        This function always is called before you enter in a new main
        loop.
      </p>
      <p>
        This function does nothing if your game is compiled for a web
        browser.
      </p>
      <h5 id="reload_plugin">void W.reload_plugin(int id)</h5>
      <p>
        This function checks if a plugin was recompiled since it was
        loaded. In this case, it reloads the plugin, updating all the
        changes made to him.
      </p>
      <p>
        This function does nothing if your game was compiled to a web
        browser.
      </p>
      <h5 id="set_plugin_data">bool W.set_plugin_data(int id, void
        *data)</h5>
      <p>
        This function stores data in the place reserved for a plugin
        identified by it's id number. You can put any kind of data
        there. If you wast to retrieve data stored with this function,
        use <a href="#get_plugin_data">W.get_plugiin_data</a>.
      </p>
      <p>
        This function should be used by plugins, not your main
        program. It's how plugins can store data that is preserved,
        even after they are disabled and enabled again or if they are
        reloaded.
      </p>
      <h3 id="interfaces">Interfaces</h3>
      <h4 id="interfaces_records">Interface Records</h4>
      <h5 id="struct_interface">struct interface</h5>
      <p>
        An "interface" is a record (what C calls "struct") which
        stores information about a graphical element which usually
        appears in the screen. This element can be manipulated by
        built-in functions to move it in the screen, rotate and
        resize. But there's no built-in functions to make it interact
        with other objects, even other interfaces. This record was
        created to represent user interface elements.
      </p>
      <p>
        An interface is defined roughly as:
      </p>
      <pre class="codigo">
<span class="word">struct</span> <span class="tipo">interface</span>{
  <span class="tipo">int</span> type;
  <span class="tipo">int</span> integer;
  <span class="tipo">float</span> x,y;
  <span class="tipo">float</span> rotation;
  <span class="tipo">float</span> r, g, b, a;
  <span class="tipo">float</span> width, height;
  <span class="tipo">bool</span> visible;
  <span class="tipo">bool</span> stretch_x, stretch_y;
}</pre>
      <p>
        An interface record is created with the function
        <a href="#new_interface">W.new_interface</a>
        or <a href="#copy_interface">W.copy_interface</a> and can be
        destroyed
        by <a href="#destroy_interface">W.destroy_interface</a>.
      </p>
      <p>
        Every interface record has the following variables:
      </p>
      <h6>int type</h6>
      <p>
        How the interface should be rendered. If it's a positive
        integer, then it's the number of the shader which will render
        the interface in the screen. It can also have the
        value <tt>W_INTERFACE_SQUARE</tt> (if it should be rendered as
        a solid rectangle) or <tt>W_INTERFACE_PERIMETER</tt> (if it
        should be rendered as the perimeter of a rectangle).
      </p>
      <h6>int integer</h6>
      <p>
        An integer which will be passed to the shader. You have
        freedom to change and use this value as you wish in your
        shaders. Weaver sets this variable as 0 in the initialization
        and never changes it again. The built-in shaders never uses
        this variable.
      </p>
      <h6>float x, y <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        The interface position in the screen. The interface position
        is defined as the position of the interface's central
        pixel. The bottom left position in the window is the position
        x=0.0, y=0.0. The upper right position in the screen in the
        window is the position
        x=(float)<a href="#width">W.width</a>-1,
        y=(float)<a href="#height">W.height</a>-1.
      </p>
      <p>
        If you want to change an interface position, don't try to set
        directly it's <tt>x</tt> and <tt>y</tt> variable. Use the
        function <a href="#move_interface">W.move_interface</a>
        instead.
      </p>
      <h6>float rotation <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        This is the angle in which the interface is rotated counter
        clockwise in radians.
      </p>
      <p>
        If you want to change an interface rotation, don't try to set
        directly it's <tt>rotation</tt> variable. Use the
        function <a href="#rotate_interface">W.rotate_interface</a>
        instead.
      </p>
      <h6>float r, g, b, a</h6>
      <p>
        These variables are passed as the color in the
        shader. Built-in shaders will treat this value as the
        interface color whem applicable. You can create custom shaders
        which use these variables in different ways.
      </p>
      <h6>float width, height <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        This is the interface width and height in pixels.
      </p>
      <p>
        If you want to change an interface size, don't try to set
        directly it's <tt>width</tt> and <tt>height</tt>
        variables. Use the
        function <a href="#resize_interface">W.resize_interface</a>
        instead.
      </p>
      <h6>bool visible</h6>
      <p>
        This variable sets if the interface is visible and should be
        rendered or if it's invisible. This is set as true by default.
      </p>
      <h6>bool stretch_x, stretch_y</h6>
      <p>
        This variable sets if the interface should be stretched or
        shrinked is the window changes it's size. This is set as false
        by default.
      </p>
      <h4 id="interface_functions">Interface Functions</h4>
      <h5 id="copy_interface">struct interface
        *W.copy_interface(struct interface *i)<img class="icon"
        src="images/loop.png" width="25px" height="25px" title="Main
        loop only"></h5>
      <p>
        This function creates a
        new <a href="#struct_interface">interface record</a> which is
        a copy of the interface record pointed by the argument. It
        returns a pointer for the new interface record created. If
        some error happened (you can't create more interfaces in this
        main loop because
        of <a href="configuring.htm#W_MAX_INTERFACES">W_MAX_INTERFACES</a>
        or the creation of some mutex failed), this function returns NULL.
      </p>
      <p>
        The interface passed as argument can be an interface created
        in another main loop. But the new interface created will be
        created in the current main loop.
      </p>
      <h5 id="destroy_interface">bool W.destroy_interface(struct
        interface *i) <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only"></h5>
      <p>
        This function destroys the interface passed as argument if we
        are in the same main loop that the interface was created. Use
        this function only if you need more space for new interfaces
        in the current loop. Otherwise, let the garbage collector
        erase interfaces not used anymore.
      </p>
      <p>
        This function returns if the opperation was successful. If you
        pass an invalid pointer or a pointer to an interface created
        in another main loop, the function does nothing and returns
        false.
      </p>
      <h5 id="move_interface"> void W.move_interface(struct interface
        *i, float x, float y)</h5>
      <p>
        This function changes the interface position. It puts the
        center of the interface in position (x, y) passed as argument,
        where the bottom left corner of the window is position (0,0)
        and the upper right corner is position
        (<a href="#width">W.width</a>-1, <a href="#height">W.height</a>-1).
      </p>
      <h5 id="new_interface">struct interface *W.new_interface(int
        type, int x, int y, int width, int height, ...)
        <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only"></h5>
      <p>
        This function creates a
        new <a href="#struct_interface">interface</a> record and
        returns a pointer for it. In case of error (you can't create
        more interfaces in the current main loop because of
        <a href="#W_MAX_INTERFACES">W_MAX_INTERFACES</a> or the
        creation of some mutex failed), this function returns NULL.
      </p>
      <p>
        The arguments <tt>x</tt>, <tt>y</tt>, <tt>width</tt>
        and <tt>height</tt> determines the initial position and size
        of the interface in the screen. More arguments can be passed
        depending of the interface type.
      </p>
      <p>
        If type is a positive integer, then the interface will be
        rendered using a custom shader created by you and idetified by
        that number. No more arguments should be passed.
      </p>
      <p>
        If type is <tt>W_INTERFACE_SQUARE</tt>
        or <tt>W_INTERFACE_PERIMETER</tt>, then you must pass 4 more
        values which represent the interface color. These 4 values
        should be floating point numbers between 0.0 and 1.0 and they
        represent the color RGBA value.
      </p>
      <h5 id="resize_interface">void W.resize_interface(struct
        interface *i, float width, float height)</h5>
      <p>
        Resize an existing interface. It's width and height becames
        the value passed as argument in pixels.
      </p>
      <h5 id="rotate_interface">void W.rotate_interface(struct
        interface *i, float angle)</h5>
      <p>
        This function changes how the interface should be rotated
        comparing with it's original position. The second argument is
        the counter clockwise rotation angle in radians.
      </p>
      <h3 id="shader">Shaders</h3>
      <h4 id="shader_variables">Shader Variables</h4>
      <h5 id="final_shader_integer">int W.final_shader_integer</h5>
      <p>
        If you enable 2-pass rendering, where you first render your
        game to a texture, and then use a custom shader to render it
        in the screen
        using <a href="#change_final_shader">W.change_final_shader</a>,
        then you can set this variable to pass any integer you wish
        for this custom shader.
      </p>
      <h4 id="shader_functions">Shader Functions</h4>
      <h5 id="change_final_shader">void W.change_final_shader(int
        shader_id)</h5>
      <p>
        This function activate the 2-pass rendering, where you first
        render all your game to a texture, and then render it to the
        screen with a custom shader, whose id number you pass as
        argument for this function.
      </p>
      <p>
        Please, ensure that you pass the id of an existing shader for
        this function. Passing an invalid id number is a fatal error.
      </p>
      <h3 id="sound">Sound</h3>
      <h4 id="sound_records">Sound Records</h4>
      <h5 id="struct_sound">struct sound</h5>
      <p>
        This record stores information about sound effects in your
        game. Not long audio like music, but small sound effects which
        should be stored in memory for fast playing.
      </p>
      <p>
        A sound record is defined roughly as:
      </p>
      <pre class="codigo">
<span class="word">struct</span> <span class="tipo">sound</span>{
  <span class="tipo">unsigned long</span> size;
  <span class="tipo">int</span> channels, freq, bitrate;
  <span class="tipo">bool</span> loaded;
};</pre>
      <p>
        A new sound record is created by
        function <a href="#new_sound">W.new_sound</a> and can be
        destroyed by
        function <a href="#destroy_sound">W.destroy_sound</a> (but if
        you created a sound inside a main loop, you shoould let the
        garbage collector destroy the record).
      </p>
      <p>
        Every sound record has the following variables:
      </p>
      <h6>unsigned long size</h6>
      <p>
        The sound size in bytes.
      </p>
      <h6>int channels</h6>
      <p>
        The number of channels. If the sound in monoaural (1), stereo
        (2) or have even more channels.
      </p>
      <h6>int freq</h6>
      <p>
        The sampling frequency. Usually it's value is 44100, because
        it's the sampling frequency of Compact Disks.
      </p>
      <h6>int bitrate</h6>
      <p>
        The bit rate, or the number of bits per second that should be
        converted to sound and played.
      </p>
      <h4 id="sound_variables">Sound Variables</h4>
      <h4 id="sound_functions">Sound Functions</h4>
    </div>
  </body>
</html>
