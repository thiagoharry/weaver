<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Weaver Reference Guide</title>
    <link rel="stylesheet" href="weaver.css">
  </head>
  <body>
    <header>
      <h1><a href="index.htm">Weaver: A Game Engine for GNU/Linux</a></h1>
      <span class="menu">
        <a href="documentation.htm">Documentation</a>
        <a href="tutorial.htm">Tutorial</a>
        <a href="examples.htm">Examples</a>
        <a href="download.htm">Download</a>
      </span>
    </header>
    <div class="docs">
      <h2>Weaver Reference Guide</h2>
      <p>
        This page lists all functions and data structures defined in
        Weaver API. We use the following icons to help you check some
        properties of the variables in Weaver API:
      </p>
      <ul>
        <li><img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only">: This variable is
          read-only. Never try to change it's value.</li>
        <li>
          <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only">: This variable or
               function should be run or read only inside a main
               loop.
        </li>
        <li>
          <img class="icon" src="images/not_thread.png" width="25px"
               height="25px" title="Not thread-safe">: This function
               is not thread-safe.
        </li>
      </ul>
      <h3>Index</h3>
      <ol>
        <li><a href="#basic">Basic Functions and Variables</a></li>
        <ol>
          <li><a href="#basic_variable">Variables</a></li>
          <ol>
            <li><a href="#W">W</a></li>
            <li><a href="#game">W.game</a></li>
            <li><a href="#pending_files">W.pending_files</a></li>
            <li><a href="#t">W.t</a></li>
            <li><a href="#dt">W.dt</a></li>
          </ol>
          <li><a href="#basic_functions">Functions</a></li>
          <ol>
            <li><a href="#Walloc">Walloc</a></li>
            <li><a href="#Wexit">Wexit</a></li>
            <li><a href="#Wexit_loop">Wexit_loop</a></li>
            <li><a href="#Wfree">Wfree</a></li>
            <li><a href="#Winit">Winit</a></li>
            <li><a href="#Wloop">Wloop</a></li>
            <li><a href="#Wsubloop">Wsubloop</a></li>
          </ol>
        </ol>
        <li><a href="#numeric">Numeric Functions and
            Variables</a></li>
        <ol>
          <li><a href="#numeric_functions">Functions</a>
            <ol>
              <li><a href="#random">W.random</a>
            </ol>
        </ol>
        <li><a href="#window">Window and Screen</a></li>
        <ol>
          <li><a href="#window_variables">Variables</a></li>
          <ol>
            <li><a href="#framerate">W.framerate</a></li>
            <li><a href="#width">W.height</a></li>
            <li><a href="#resolution_x">W.resolution_x</a></li>
            <li><a href="#resolution_y">W.resolution_y</a></li>
            <li><a href="#width">W.width</a></li>
            <li><a href="#x">W.x</a></li>
            <li><a href="#y">W.y</a></li>
          </ol>
          <li><a href="#window_functions">Functions</a></li>
          <ol>
            <li><a href="#change_resolution">W.change_resolution</a></li>
            <li><a href="#move_window">W.move_window</a></li>
          </ol>
        </ol>
        <li><a href="#input">User Input</a></li>
        <ol>
          <li><a href="#input_variables">Variables</a></li>
          <ol>
            <li><a href="#keyboard">W.keyboard</a></li>
            <li><a href="#mouse">W.mouse</a></li>
          </ol>
          <li><a href="#input_functions">Functions</a></li>
          <ol>
            <li><a href="#hide_cursor">W.hide_cursor</a></li>
          </ol>
        </ol>
        <li><a href="#scheduling">Scheduling</a></li>
        <ol>
          <li><a href="#scheduling_functions">Scheduling
              Functions</a></li>
          <ol>
            <li><a href="#cancel">W.cancel</a></li>
            <li><a href="#period">W.period</a></li>
            <li><a href="#run_futurelly">W.run_futurelly</a></li>
            <li><a href="#run_periodically">W.run_periodically</a></li>
          </ol>
        </ol>
        <li><a href="#plugins">Plugins</a></li>
        <ol>
          <li><a href="#plugins_functions">Plugin Functions</a></li>
          <ol>
            <li><a href="#disable_plugin">W.disable_plugin</a></li>
            <li><a href="#enable_plugin">W.enable_plugin</a></li>
            <li><a href="#get_plugin">W.get_plugin</a></li>
            <li><a href="#get_plugin_data">W.get_plugin_data</a></li>
            <li><a href="#is_plugin_enabled">W.is_plugin_enabled</a></li>
            <li><a href="#reload_all_plugins">W.reload_all_plugins</a></li>
            <li><a href="#reload_plugin">W.reload_plugin</a></li>
            <li><a href="#set_plugin_data">W.set_plugin_data</a></li>
          </ol>
        </ol>
        <li><a href="#interfaces">Interfaces</a></li>
        <ol>
          <li><a href="#interfaces_records">Records</a></li>
          <ol>
            <li><a href="#struct_interface">struct interface</a></li>
          </ol>
          <li><a href="#interface_functions">Interface
              Functions</a></li>
          <ol>
            <li><a href="#copy_interface">W.copy_interface</a></li>
            <li><a href="#destroy_interface">W.destroy_interface</a></li>
            <li><a href="#move_interface">W.move_interface</a></li>
            <li><a href="#new_interface">W.new_interface</a></li>
            <li><a href="#resize_interface">W.resize_interface</a></li>
            <li><a href="#rotate_interface">W.rotate_interface</a></li>
          </ol>
        </ol>
        <li><a href="#shader">Shaders</a></li>
        <ol>
          <li><a href="#shader_variables">Shader Variables</a></li>
          <ol>
            <li><a href="#final_shader_integer">W.final_shader_integer</a></li>
          </ol>
          <li><a href="#shader_functions">Shader Functions</a></li>
          <ol>
            <li><a href="#change_final_shader">W.change_final_shader</a></li>
          </ol>
        </ol>
        <li><a href="#sound">Sound</a></li>
        <ol>
          <li><a href="#sound_records">Sound Records</a></li>
          <ol>
            <li><a href="#struct_sound">struct sound</a></li>
          </ol>
          <li><a href="#sound_variables">Sound Variables</a></li>
          <ol>
            <li><a href="#number_of_sound_devices">W.number_of_sound_devices</a>
            </li>
            <li><a href="#sound_device_name">W.sound_device_name</a></li>
          </ol>
          <li><a href="#sound_functions">Sound Functions</a></li>
          <ol>
            <li><a href="#current_sound_device">W.current_sound_device</a></li>
            <li><a href="#destroy_sound">W.destroy_sound</a></li>
            <li><a href="#get_volume">W.get_volume</a></li>
            <li><a href="#increase_volume">W.increase_volume</a></li>
            <li><a href="#new_sound">W.new_sound</a></li>
            <li><a href="#pause_music">W.pause_music</a></li>
            <li><a href="#play_music">W.play_music</a></li>
            <li><a href="#play_sound">W.play_sound</a></li>
            <li><a href="#select_sound_device">W.select_sound_device</a></li>
            <li><a href="#stop_music">W.stop_music</a></li>
          </ol>
        </ol>
        <li><a href="#data">Data</a></li>
        <ol>
          <li><a href="#data_functions">Data Functions</a></li>
          <ol>
            <li><a href="#delete_all">W.delete_all</a></li>
            <li><a href="#delete_float">W.delete_float</a></li>
            <li><a href="#delete_integer">W.delete_integer</a></li>
            <li><a href="#delete_string">W.delete_string</a></li>
            <li><a href="#read_float">W.read_float</a></li>
            <li><a href="#read_integer">W.read_float</a></li>
            <li><a href="#read_string">W.read_string</a></li>
            <li><a href="#write_float">W.write_float</a></li>
            <li><a href="#write_integer">W.write_integer</a></li>
            <li><a href="#write_string">W.write_string</a></li>
          </ol>
        </ol>
      </ol>
      <h3 id="#basic">Basic Functions and Variables</h3>
      <h4 id="basic_variable">Variables</h4>
      <h5 id="W">struct W <img class="icon" src="images/read_only.png"
             width="25px" height="25px" title="Read-only"></h5>
      <p>
        The <tt>W</tt> struct is a struct where you can find almost
        all the variables and functions defined by Weaver API. It's
        main function is act as a namespace, avoiding conflicts
        between user variable names and the API names. Almost all
        variables and functions listed in this page is
        inside <tt>W</tt>.
      </p>
      <p>
        Another advantage of defining almost all variables and
        functions inside this struct it's that we can pass the struct
        to plugins and then they can have access to all Weaver
        functions and variables.
      </p>
      <p>
        Usually you shouldn't worry about the <tt>W</tt> struct and
        never should need to pass it directly to some function. You
        just invoke it's functions and access it's variables.
      </p>
      <h5 id="game">struct _game_struct *W.game</h5>
      <p>
        This is just a pointer to the struct defined
        at <tt>src/game.h</tt> in your project. You decide which
        variables you create and define in this struct. This
        user-defined struct is a way to store your game's global
        variables and also where you put data that should be
        accessible for plugins.
      </p>
      <h5 id="pending_files">unsigned int
             W.pending_files<img class="icon"
             src="images/read_only.png" width="25px" height="25px"
                                 title="Read-only"></h5>
      <p>
        When you ask to Weaver open some kind of files like sound
        effect files, sometimes it opens and reads the file in a
        parallel thread, even when you compile your game to a web
        browser. This variable holds how many files Weaver is still
        reading.
      </p>
      <h5 id="t">unsigned long long W.t <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This variable hold the times in microseconds since the
        program's initialization. A microsecond is 0.000001 second. So
        if you wish to know the value in seconds, you should divide it
        by 1,000,000.
      </p>
      <p>
        As this value is at least 64-bits long, this would overflow
        only after more than 500,000 years.
      </p>
      <h5 id="dt">unsigned long long W.dt <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This variable holds the time in microseconds between the
        current main loop iteration and the previous loop
        iteration. As Weaver uses a fixed time step to run C code in
        the game loop, it's value should always be about 40,000, wich
        means that your C-code is running at 25 frames per second (but
        the game probably is rendering at a higher rate).
      </p>
      <p>
        If you check this value and it has a value much higher than
        40,000, it means that your game is running slowly. You should
        then do something like render less things, lower the
        resolution or the ammount of calculations in each frame.
      </p>
      <h4 id="basic_functions">Functions</h4>
      <h5 id="Walloc">void *Walloc(size_t size)</h5>
      <p>
        This function is like <tt>malloc</tt>, but the memory
        allocated is handled by Weaver's memory manager and usually
        don't need to be manually freed. The gargage collector
        will take away the memory allocated when you exit the current
        main loop.
      </p>
      <p>
        You should free the memory only if you use this function
        outside a main loop. Or if you just allocated the memory but
        won't need it anymore. In this case, use
        the <a href="#Wfree">Wfree</a> function.
      </p>
      <p>
        Weaver garbage collector runs when you call the functions
        <a href="#Wloop">Wloop</a> (except in the first invocation)
        and <a href="#Wexit_loop">Wexit_loop</a>.
      </p>
      <p>
        <b>Tip:</b> Avoid calling <tt>Walloc</tt> in a main loop
        body. This leads to memory leaks. It's better to allocate a
        pool of objects in the loop initialization and then in the
        loop body you check which objects in the pool are initialized
        and should be handled.
      </p>
      <h5 id="Wexit">void Wexit(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
               title="Not thread-safe"></h5>
      <p>
        This function exits the game immediately. The game window is
        closed and the program exits if applicable. You can't access
        any variable or function listed here after
        calling <tt>Wexit</tt>.
      </p>
      <h5 id="Wexit_loop">void Wexit_loop(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                               title="Not
                                                      thread-safe">
      <img class="icon" src="images/loop.png" width="25px"
             height="25px" title="Main loop only"></h5>
      <p>
        This function exits the current main loop, remove it from the
        stack and resume the execution of the next main loop in the
        stack. If there's just one main loop in the stack when this
        function is called, then it just exits the game.
      </p>
      <p>
        The garbage collector frees all the memory allocated in a loop
        when you call this function. To know more about main loops,
        please check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Wfree">void Wfree(void *memory)</h5>
      <p>
        This function frees the memory allocated
        with <a href="#Walloc">Walloc</a>. Call this only if the
        memory was allocated outside a main loop or it was allocated
        in the same main loop where we currently are. Otherwise, you
        risk calling the function in a memory already freed by the
        garbage collector.
      </p>
      <p>
        When in doubt, don't use <tt>Wfree</tt>. Just let the garbage
        collector do the work. If your
        macro <a href="configuration.htm#W_DEBUG_LEVEL">W_DEBUG_LEVEL</a>
        is greater than 0, then Weaver will print a warning in the
        screen if it detects a memory leak while exiting the game.
      </p>
      <p>
        To check how the garbage collector and the memory in Weaver
        works, check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Winit">void Winit(void)<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                          title="Not thread-safe"></h5>
      <p>
        This is the first function you should call in a Weaver
        program. Only after calling this function you can call any
        other function listed here or read any Weaver variable.
      </p>
      <p>
        This is the function who creates a new window according with
        the configurations in <tt>conf/conf.h</tt>.
      </p>
      <h5 id="Wloop">void Wloop(MAIN_LOOP (*loop)(void))<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
                                          title="Not
                                                 thread-safe"></h5>
      <p>
        If this function is called outside a main loop, it puts the
        loop received as argument in the loop stack and executes it.
        If this function is called inside a main loop, it stops the
        execution of the current loop, removes it from the stack, put
        the received loop in the stack and executes it. In other
        words, it substitute the current loop by the loop passed as
        argument.
      </p>
      <p>
        A main loop is where a game spends almost all the time, where
        we can get player's input and update the screen showing the
        objects created.
      </p>
      <p>
        To know more how main loops work in Weaver,
        check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h5 id="Wsubloop">void Wsubloop(MAIN_LOOP
               (*loop)(void))<img class="icon"
               src="images/not_thread.png" width="25px" height="25px"
               title="Not thread-safe"><img class="icon"
               src="images/loop.png" width="25px" height="25px"
                                            title="Main loop only"></h5>
      <p>
        This function pauses the execution of the current main loop,
        put the loop received as argument in the loop stack and
        executes it.
      </p>
      <p>
        It doesn't destroy the previous loop. So the garbage collector
        won't free the memory allocated in that loop.
      </p>
      <p>
        To know more how main loops work in Weaver,
        check <a href="loop.htm">Weaver Main Loops</a>.
      </p>
      <h3 id="numeric">Numeric Variables and Functions</h3>
      <h4 id="numeric_functions">Numeric Functions</h4>
      <h5 id="random">unsigned long W.random(void)</h5>
      <p>
        This function uses a variation of the Mersenne Twister
        algorithm to generate a 32-bits pseudo-random number. If you
        want your game to always use the same seed, set the
        macro <a href="configuration.htm#W_SEED">W_SEED</a>
        at <tt>conf/conf.h</tt>, otherwise Weaver tries to use an
        unpredictable seed, as a value read from <tt>/dev/urandom</tt>
        or the current time in milisseconds.
      </p>
      <h3 id="window">Window and Screen</h3>
      <h4 id="window_variables">Window and Screen Variables</h4>
      <h5 id="framerate">int W.framerate <img class="icon"
                                       src="images/read_only.png"
                                       width="25px" height="25px"
                                              title="Read-only"></h5>
      <p>
        This variable holds the screen frame rate, the frequency at
        which consecutive images are displayed in your screen. Usually
        it's value is 60, which means that your screen is updated once
        each 0.017 second. Of course there are machines where this
        value can be different.
      </p>
      <p>
        Don't trust in this variable f your game was compiled to a web
        browser. There's no reliable way to discover the frame rate
        inside a web browser and so Weaver just guesses the value as
        60.
      </p>
      <h5 id="width">int W.height <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                       title="Read-only"></h5>
      <p>
        This variable holds the height your game have in pixels. It
        starts with the value defined in
        macro <a href="configuration.htm#W_HEIGHT">W_HEIGHT</a>. The
        value will keep updated if your window changes the size
        (either because the user resized the window or because you
        called the
        function <a href="#resize_window">W.resize_window</a>).
      </p>
      <p>
        If your game was compiled to a Web Browser, this variable
        holds the height of the canvas where your game is being drawn.
      </p>
      <h5 id="resolution_x">int W.resolution_x <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                             title="Read-only"></h5>
      <p>
        This variable holds your screen horizontal resolution. The
        width a full screen window would have in the screen. If your
        program is running in a web browser, this variable holds the
        width of the web browser window excluding toolbars and
        scrollbars (the same value present in
        Javascript's <tt>window.innerWidth</tt>).
      </p>
      <p>
        This variable doesn't change when you
        use <a href="#change_resolution">W.change_resolution</a>. This
        variable keeps the resolution of your window manager or your
        browser body area. This is the amximum resolution your game
        can have. The
        function <a href="#change_resolution">W.change_resolution</a>
        changes the resolution in the game internal renderer.
      </p>
      <h5 id="resolution_y">int W.resolution_y <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                             title="Read-only"></h5>
      <p>
        This variable holds your screen vertical resolution. The
        height a full screen window would have in the screen. If your
        program is running in a web browser, this variable holds the
        height of the web browser window excluding toolbars and
        scrollbars (the same value present in
        Javascript's <tt>window.innerHeight</tt>).
      </p>
      <p>
      <p>
        This variable doesn't change when you
        use <a href="#change_resolution">W.change_resolution</a>. This
        variable keeps the resolution of your window manager or your
        browser body area. This is the amximum resolution your game
        can have. The
        function <a href="#change_resolution">W.change_resolution</a>
        changes the resolution in the game internal renderer.
      </p>
      </p>
      <h5 id="width">int W.width <img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                                      title="Read-only"></h5>
      <p>
        This variable holds the width your game have in pixels. It
        starts with the value defined in
        macro <a href="configuration.htm#W_WIDTH">W_WIDTH</a>.  The
        value will keep updated if your window changes the size
        (either because the user resized the window or because you
        called the
        function <a href="#resize_window">W.resize_window</a>).
      </p>
      <p>
        If your game was compiled to a Web Browser, this variable
        holds the widtht of the canvas where your game is being drawn.
      </p>
      <h5 id="x">int W.x <img class="icon" src="images/read_only.png"
                              width="25px" height="25px"
                              title="Read-only"></h5>
      <p>
        This variable holds the horizontal position of your game
        window in the screen. This position is defined as the column
        where the pixel in the center of your window is. The leftmost
        column is the column 0 and the rightmost colummn has the
        number
        <a href="#resolution_x">W.resolution_x</a>-1.
      </p>
      <p>
        Inside a web browser, your game canvas can't move, so this
        variable is always assumed to have the value
        <a href="#resolution_x">W.resolution_x</a>/2 (Weaver assumes
        that the game canvas is centralized).
      </p>
      <p>
        Don't change this variable. If you want to move your window,
        call the function <a href="#move_window">W.move_window</a>.
      </p>
      <h5 id="y">int W.y <img class="icon" src="images/read_only.png"
                              width="25px" height="25px"
                              title="Read-only"></h5>
      <p>
        This variable holds the vertical position of your game window
        in the screen. This position is defined as the line where the
        pixel in the center of your window is. The bottom line is the
        line 0 and the top lline has the number
        <a href="#resolution_x">W.resolution_y</a>-1.
      </p>
      <p>
        Inside a web browser, your game canvas can't move, so this
        variable is always assumed to have the value
        <a href="#resolution_x">W.resolution_y</a>/2 (Weaver assumes
        that the game canvas is centralized).
      </p>
      <p>
        Don't change this variable. If you want to move your window,
        call the function <a href="#move_window">W.move_window</a>.
      </p>
      <h4 id="window_functions">Window Functions</h4>
      <h5 id="change_resolution">void W.change_resolution(int horizontal, int
        vertical)</h5>
      <p>
        This changes the resolution of your game window. If you are
        not in fullscreen mode, this just changes the window
        size. Otherwise, it changes the game renderer to show your
        game in the desired resolution.
      </p>
      <h5 id="move_window">void W.move_window(int x, int y)</h5>
      <p>
        This function moves your game window for the giver
        coordinate. The position x and y are in pixels and the
        position (0, 0) is in the left lower part of your screen while
        the coordinate (<a href="#resolution_x">W.resolution.x</a>-1,
        <a href="#resolution_y">W.resolution.y</a>-1) is the right upper
        part of your screen.
      </p>
      <p>
        Moving a window to a coordinate means placing it's center in
        this coordinate.
      </p>
      <p>
        This function does nothing in a game compiled to a web
        browser.
      </p>
      <h3 id="input">User Input</h3>
      <h4 id="input_variables">User Input Variables</h4>
      <h5 id="keyboard">long W.keyboard[] <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        This array stores information about the user interaction with
        the keyboard. Each key has it's own position in the
        array. There's a set of macros created to help finding the
        right position in the array. To check if the key "A" is
        pressed, for example.  check <tt>W.keyboard[W_A]</tt>.
      </p>
      <p>
        Besides <tt>W_A</tt>, you can check also
        for <tt>W_B</tt>, <tt>W_C</tt>, and all other letters, you can
        also check the digits <tt>W_0</tt>, <tt>W_1</tt> and
        others. The keys F1, F2, F3 and others
        are <tt>W_F1</tt>, <tt>W_F2</tt>, <tt>W_F3</tt> and so on. The
        arrow keys
        are <tt>W_UP</tt>, <tt>W_RIGHT</tt>, <tt>W_LEFT</tt>
        and <tt>W_DOWN</tt>. The Esc key is <tt>W_ESC</tt>. The Enter
        key is <tt>W_ENTER</tt>, the spacebar is <tt>W_SPACEBAR</tt>
        and the backspace is <tt>W_BACKSPACE</tt>. You also
        have <tt>W_TAB</tt>, <tt>W_PAUSE</tt>, <tt>W_DELETE</tt>, <tt>W_SCROLL_LOCK</tt>, <tt>W_HOME</tt>, <tt>W_PAGE_UP</tt>, <tt>W_PAGE_DOWN</tt>, <tt>W_END</tt>,
        <tt>W_INSERT</tt> and <tt>W_NUM_LOCK</tt> for keys Tab, Home,
        Page Up, Page Down, End, Insert and Num Lock. And there's
        the <tt>W_PLUS</tt> for "+" and <tt>W_MINUS</tt> for "-".
      </p>
      <p>
        The keys Shift, Ctrl and Alt are a little different because
        they have a left and a right variety. If you don't care if the
        key pressed is left or right, you can
        check <tt>W_SHIFT</tt>, <tt>W_CTRL</tt> and <tt>W_ALT</tt>. If
        you want to check for the right version of these keys, check
        for <tt>W_RIGHT_SHIFT</tt>, <tt>W_RIGHT_CTRL</tt>
        and <tt>W_RIGHT_ALT</tt>. If you want to check the left
        variety, check <tt>W_LEFT_SHIFT</tt>, <tt>W_LEFT_CTRL</tt>
        and <tt>W_LEFT_ALT</tt>.
      </p>
      <p>
        You can also check if any key was pressed checking the
        position <tt>W_ANY</tt> in the array.
      </p>
      <p>
        If a key is not pressed, it's position in the keyboard array
        will have the value 0.
      </p>
      <p>
        If a key just started to be pressed in this frame (in this
        iteration in the main loop), it's position will store the
        value 1.
      </p>
      <p>
        If a key is being pressed, but the user didn't start to press
        it in this frame, it's position will store the number of
        microseconds since the user is pressing the key.
      </p>
      <p>
        If the user released a key in this frame, it's position will
        store (just in this frame) a negative value witch is -1
        multiplyed by the number of microseconds that the key was
        kept pressed.
      </p>
      <h5 id="mouse">struct W.mouse <img class="icon"
             src="images/read_only.png" width="25px" height="25px"
             title="Read-only"><img class="icon" src="images/loop.png"
             width="25px" height="25px" title="Main loop only"></h5>
      <p>
        The mouse is represented by the following struct:
      </p>
      <pre class="codigo">
<span class="tipo">struct</span>{
  <span class="tipo">long</span> buttons[];
  <span class="tipo">int</span> x, y, dx, dy, ddx, ddy;
} W.mouse;</pre>
      <p>
        Weaver assumes a mouse can have 5 buttons. You can check if
        some of these keys are being pressed checking the
        positions <tt>W_MOUSE_LEFT</tt> (mouse left
        button), <tt>W_MOUSE_MIDDLE</tt> (mouse middle
        button), <tt>W_MOUSE_RIGHT</tt> (mouse right button) and the
        aditional buttons <tt>W_MOUSE_B1</tt> and <tt>W_MOUSE_B2</tt>
        in the array <tt>W.mouse.buttons</tt>. Keep in mind that not
        everybody have access to all the buttons. And if the game was
        compiled to a web browser, we may not to be able to check for
        buttons <tt>W_MOUSE_B1</tt> and <tt>W_MOUSE_B2</tt>.
      </p>
      <p>
        If a mouse button is not pressed, it will have the value 0 in
        the array.
      </p>
      <p>
        If a mouse button starts to get pressed in this frame, it will
        have the value 1 in the array. But remember that mouse clicks
        can be really fast and sometimes the user click and release
        the button in the same frame. If this happens, you detect just
        the button being released, so it won't start with the value 1.
      </p>
      <p>
        If a mouse button is getting pressed for more than 1 frame, it
        will have the value of microseconds since the key started to
        be pressed.
      </p>
      <p>
        And if a mouse button is released in this frame, it will have
        a negative value of -1 multiplied by the number of
        microseconds that the button was kept pressed. If the button
        is pressed and released really fast, in the same frame, the
        first value different than 0 detected is the value -1, not 1.
      </p>
      <p>
        The variables <tt>W.mouse.x</tt> and <tt>W.mouse.y</tt> stores
        thw mouse position in our game window. We considet the x axis
        as the horizontal axis and the y axis as the vertical
        axis. The position in the lower left of the window is (0,0)
        and the position in the upper right is
        (<a href="#width">W.width</a>-1, <a href="#height">W.height</a>-1).
      </p>
      <p>
        You can get the horizontal and vertical speed of the mouse in
        pixels per second checking the variables <tt>W.mouse.dx</tt>
        and <tt>W.mouse.dy</tt>.
      </p>
      <p>
        You can get the horizontal and vertical acceleration of the
        mouse in pixels per second squared checking the
        variables <tt>W.mouse.ddx</tt> and <tt>W.mouse.ddy</tt>.
      </p>
      <h4 id="input_functions">User Input Functions</h4>
      <h5 id="hide_cursor">void W.hide_cursor(void)</h5>
      <p>
        Makes the cursor hidden.
      </p>
      <h3 id="scheduling">Scheduling</h3>
      <h4 id="scheduling_functions">Scheduling Functions</h4>
      <h5 id="cancel">float W.cancel(void (*f)(void))<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        If you asked Weaver to run some function f periodically with
        <a href="#run_periodically">W.run_periodically</a> or in some
        moment in the future
        with <a href="#run_futurelly">W.run_futurelly</a>, you can
        cancel this passing the function f to W.cancel.
      </p>
      <p>
        The function returns the time in seconds in which the function
        would be executed if it wasn't cancelled.
      </p>
      <p>
        If you pass a function not scheduled for future execution or
        an invalid pointer for this function, nothing happens and it
        returns NaN (Not a Number). The same happens if you try to
        cancel a function scheduled to be executed only once and which
        already executed.
      </p>
      <h5 id="period">float W.period(void (*f)(void))<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        If <b>f</b> is a function scheduled to be run periodically
        using <a href="#run_periodically">W.run_periodically</a>, this
        function returns the function period in seconds.
      </p>
      <p>
        If <b>f</b> is a function scheduled to be run once in some
        moment in the future
        with <a href="#run_futurelly">W.run_futurelly</a>, this
        function returns INFINITY.
      </p>
      <p>
        Otherwise, this function returns NaN.
      </p>
      <h5 id="run_futurelly">void W.run_futurelly(void (*f)(void),
               float s)<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        Run the function <b>f</b> in the future. Waits the number of
        seconds <b>s</b> passed as argument before executing the
        function.
      </p>
      <p>
        If the function <b>f</b> was already scheduled for execution,
        the entry in the scheduler is updated to transform the
        function in a non-periodic function.
      </p>
      <p>
        This function won't work if your scheduler has more than
        <a href="configuring.htm#W_MAX_SCHEDULING">W_MAX_SCHEDULING</a>
        waiting for execution.
      </p>
      <h5 id="run_periodically">void W.run_periodically(void (*f)(void),
               float s)<img class="icon"
               src="images/loop.png" width="25px" height="25px"
               title="Main loop only"></h5>
      <p>
        Run the function <b>f</b> periodically, every <b>s</b>
        seconds. The first execution will be <b>s</b> seconds after
        you call this function.
      </p>
      <p>
        If the function <b>f</b> was already scheduled for execution,
        the entry in the scheduler is updated to transform the
        function in a periodic function and it's period is also
        updated.
      </p>
      <p>
        This function won't work if your scheduler has more than
        <a href="configuring.htm#W_MAX_SCHEDULING">W_MAX_SCHEDULING</a>
        waiting for execution.
      </p>
      <h3 id="plugins">Plugins</h3>
      <h4 id="plugins_functions">Plugin Functions</h4>
      <h5 id="disable_plugin">bool W.disable_plugin(int id)</h5>
      <p>
        This function disables a plugin given it's id number and
        returns true if the opperation was successful. This function
        fails if a plugin id is invalid and returns false.
      </p>
      <p>
        Trying to disable an already disabled plugin does nothing (but
        the function returns true anyway.
      </p>
      <p>
        Immediately before the plugin is disabled, it executes it's
        function _disable_plugin_PLUGIN_NAME.  A disabled plugin won't
        run it's function _run_plugin_PLUGIN_NAME every iteration in
        the main loop. Check <a href="plugin.htm">Weaver Plugins</a>
        for more info.
      </p>
      <h5 id="enable_plugin">bool W.enable_plugin(int id)</h5>
      <p>
        This function enables a plugin given it's id number and
        returns true if the opperation was successful. This function
        fails if a plugin id is invalid and returns false.
      </p>
      <p>
        Trying to enable an already enabled plugin does nothing. But
        the function returns true anyway.
      </p>
      <p>
        Immediately after the plugin is enabled, it executes it's
        function _enable_plugin_PLUGIN_NAME.  An enabled plugin will
        run it's function _run_plugin_PLUGIN_NAME every iteration in
        the main loop. Check <a href="plugin.htm">Weaver Plugins</a>
        for more info.
      </p>
      <h5 id="get_plugin">int W.get_plugin(char *plugin_name)</h5>
      <p>
        Get a plugin id number given it's name. If a plugin is not
        found, this function returns -1.
      </p>
      <h5 id="get_plugin_data">void *W.get_plugin_data(int id)</h5>
      <p>
        This function stores some data previously stored with
        <a href="#set_plugin_data">W.set_plugin_data</a>, given a
        plugin id number.
      </p>
      <p>
        This function should be called by plugins, not by your
        program. It's how plugins should store data that should be
        preserved, even if the plugin is disabled or if the plugin is
        reloaded.
      </p>
      <h5 id="is_plugin_enabled">bool W.is_plugin_enabled(int id)</h5>
      <p>
        A simple test which returns true if a plugin is enabled and
        returns false otherwise. The plugin is identified by it's id
        number.
      </p>
      <h5 id="reload_all_plugins">void W.reload_all_plugins(void)</h5>
      <p>
        This function reloads all the existing plugins, updating them
        if they were recompiled. It also checks the directory
        <a href="configuring.htm#W_PLUGIN_PATH">W_PLUGIN_PATH</a> if
        there are new plugins. If it finds a new plugin, the function
        makes it accessible by <a href="#get_plugin">W.get_plugin</a>,
        allowing you to enable or disable the plugin.
      </p>
      <p>
        This function always is called before you enter in a new main
        loop.
      </p>
      <p>
        This function does nothing if your game is compiled for a web
        browser.
      </p>
      <h5 id="reload_plugin">void W.reload_plugin(int id)</h5>
      <p>
        This function checks if a plugin was recompiled since it was
        loaded. In this case, it reloads the plugin, updating all the
        changes made to him.
      </p>
      <p>
        This function does nothing if your game was compiled to a web
        browser.
      </p>
      <h5 id="set_plugin_data">bool W.set_plugin_data(int id, void
        *data)</h5>
      <p>
        This function stores data in the place reserved for a plugin
        identified by it's id number. You can put any kind of data
        there. If you wast to retrieve data stored with this function,
        use <a href="#get_plugin_data">W.get_plugiin_data</a>.
      </p>
      <p>
        This function should be used by plugins, not your main
        program. It's how plugins can store data that is preserved,
        even after they are disabled and enabled again or if they are
        reloaded.
      </p>
      <h3 id="interfaces">Interfaces</h3>
      <h4 id="interfaces_records">Interface Records</h4>
      <h5 id="struct_interface">struct interface</h5>
      <p>
        An "interface" is a record (what C calls "struct") which
        stores information about a graphical element which usually
        appears in the screen. This element can be manipulated by
        built-in functions to move it in the screen, rotate and
        resize. But there's no built-in functions to make it interact
        with other objects, even other interfaces. This record was
        created to represent user interface elements.
      </p>
      <p>
        An interface is defined roughly as:
      </p>
      <pre class="codigo">
<span class="word">struct</span> <span class="tipo">interface</span>{
  <span class="tipo">int</span> type;
  <span class="tipo">int</span> integer;
  <span class="tipo">int</span> number_of_frames;
  <span class="tipo">int</span> current_frame;
  <span class="tipo">int</span> max_repetition;
  <span class="tipo">float</span> x,y;
  <span class="tipo">float</span> rotation;
  <span class="tipo">float</span> r, g, b, a;
  <span class="tipo">float</span> width, height;
  <span class="tipo">bool</span> visible;
  <span class="tipo">bool</span> animate;
}</pre>
      <p>
        An interface record is created with the function
        <a href="#new_interface">W.new_interface</a>
        or <a href="#copy_interface">W.copy_interface</a> and can be
        destroyed
        by <a href="#destroy_interface">W.destroy_interface</a>.
      </p>
      <p>
        Every interface record has the following variables:
      </p>
      <h6>int type<img class="icon" src="images/read_only.png"
             width="25px" height="25px" title="Read-only"></h6>
      <p>
        How the interface should be rendered. If it's a positive
        integer, then it's the number of the shader which will render
        the interface in the screen. It can also have the
        value <tt>W_INTERFACE_SQUARE</tt> (if it should be rendered as
        a solid rectangle) or <tt>W_INTERFACE_PERIMETER</tt> (if it
        should be rendered as the perimeter of a rectangle).
      </p>
      <p>
        Interfaces with the same type are rendered together. If he
        interface type is user-defined (its value is a positive
        integer), interfaces with greater type numbers will be
        rendered first. Knowing this may be useful if you want to
        render correctly translucent interfaces (interfaces with parts
        not completely opaque nor completely transparent). In this
        case, you need to ensure that the translucent interfaces are
        rendered after the others.
      </p>
      <h6>int integer</h6>
      <p>
        An integer which will be passed to the shader. You have
        freedom to change and use this value as you wish in your
        shaders. Weaver sets this variable as 0 in the initialization
        and never changes it again. The built-in shaders never uses
        this variable.
      </p>
      <h6>int number_of_frames<img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        If this interface was created from an animated GIF, this
        stores asn integer greater than 1 which orresponds to the
        number of frames in the animation. Otherwise, the value is 1.
      </p>
      <h6>int current_frame</h6>
      <p>
        If this is an animated interface read from an animated GIF
        file, then his variable have a value between 0 and
        (number_of_frames-1). It stores which frame should appear in
        the screen. In not animated interfaces, the value is always
        0. Never put in this variable (number_of_frames) or greater.
      </p>
      <h6>int max_repetition</h6>
      <p>
        How many times should we repeat the animation if this is an
        animated interface. A value of -1 means that the animation
        will repeat forever. A 0 means that the animation is frozen in
        the last frame. Avalue greater than 0 means that the animation
        is running, but the value will decrement each time the
        animation shows its last frame. In a not animated interface,
        the value is ignored.
      </p>
      <h6>float x, y <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        The interface position in the screen. The interface position
        is defined as the position of the interface's central
        pixel. The bottom left position in the window is the position
        x=0.0, y=0.0. The upper right position in the screen in the
        window is the position
        x=(float)<a href="#width">W.width</a>-1,
        y=(float)<a href="#height">W.height</a>-1.
      </p>
      <p>
        If you want to change an interface position, don't try to set
        directly it's <tt>x</tt> and <tt>y</tt> variable. Use the
        function <a href="#move_interface">W.move_interface</a>
        instead.
      </p>
      <h6>float rotation <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        This is the angle in which the interface is rotated counter
        clockwise in radians.
      </p>
      <p>
        If you want to change an interface rotation, don't try to set
        directly it's <tt>rotation</tt> variable. Use the
        function <a href="#rotate_interface">W.rotate_interface</a>
        instead.
      </p>
      <h6>float r, g, b, a</h6>
      <p>
        These variables are passed as the color in the
        shader. Built-in shaders will treat this value as the
        interface color whem applicable. You can create custom shaders
        which use these variables in different ways.
      </p>
      <h6>float width, height <img class="icon" src="images/read_only.png"
                 width="25px" height="25px" title="Read-only"></h6>
      <p>
        This is the interface width and height in pixels.
      </p>
      <p>
        If you want to change an interface size, don't try to set
        directly it's <tt>width</tt> and <tt>height</tt>
        variables. Use the
        function <a href="#resize_interface">W.resize_interface</a>
        instead.
      </p>
      <p>
        The interface width and height will also change if you change
        resolution
        with <a href="#change_resolution">W.change_resolution</a>. During
        a resolution change the interfaces will keep their proportions
        with the window size in pixels.
      </p>
      <h6>bool visible</h6>
      <p>
        This variable sets if the interface is visible and should be
        rendered or if it's invisible. This is set as true by default.
      </p>
      <h6>bool animate</h6>
      <p>
        This variable enables and disables the interface animation if
        the interface was created from an animated GIF. Enabling
        animation in other kind of interfaces has no effect.
      </p>
      <h4 id="interface_functions">Interface Functions</h4>
      <h5 id="copy_interface">struct interface
        *W.copy_interface(struct interface *i)<img class="icon"
        src="images/loop.png" width="25px" height="25px" title="Main
        loop only"></h5>
      <p>
        This function creates a
        new <a href="#struct_interface">interface record</a> which is
        a copy of the interface record pointed by the argument. It
        returns a pointer for the new interface record created. If
        some error happened (you can't create more interfaces in this
        main loop because
        of <a href="configuring.htm#W_MAX_INTERFACES">W_MAX_INTERFACES</a>
        or the creation of some mutex failed), this function returns NULL.
      </p>
      <p>
        The interface passed as argument can be an interface created
        in another main loop. But the new interface created will be
        created in the current main loop.
      </p>
      <h5 id="destroy_interface">bool W.destroy_interface(struct
        interface *i) <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only"></h5>
      <p>
        This function destroys the interface passed as argument if we
        are in the same main loop that the interface was created. Use
        this function only if you need more space for new interfaces
        in the current loop. Otherwise, let the garbage collector
        erase interfaces not used anymore.
      </p>
      <p>
        This function returns if the opperation was successful. If you
        pass an invalid pointer or a pointer to an interface created
        in another main loop, the function does nothing and returns
        false.
      </p>
      <h5 id="move_interface"> void W.move_interface(struct interface
        *i, float x, float y)</h5>
      <p>
        This function changes the interface position. It puts the
        center of the interface in position (x, y) passed as argument,
        where the bottom left corner of the window is position (0,0)
        and the upper right corner is position
        (<a href="#width">W.width</a>-1, <a href="#height">W.height</a>-1).
      </p>
      <h5 id="new_interface">struct interface *W.new_interface(int
        type, int x, int y, int width, int height, ...)
        <img class="icon" src="images/loop.png" width="25px"
               height="25px" title="Main loop only"></h5>
      <p>
        This function creates a
        new <a href="#struct_interface">interface</a> record and
        returns a pointer for it. In case of error (you can't create
        more interfaces in the current main loop because of
        <a href="#W_MAX_INTERFACES">W_MAX_INTERFACES</a> or the
        creation of some mutex failed), this function returns NULL.
      </p>
      <p>
        The arguments <tt>x</tt>, <tt>y</tt>, <tt>width</tt>
        and <tt>height</tt> determines the initial position and size
        of the interface in the screen. More arguments can be passed
        depending of the interface type.
      </p>
      <p>
        If type is a positive integer, then the interface will be
        rendered using a custom shader created by you and identified
        by that number. You should pass than an argument with the
        filename of the texture that should be sent as "texture1" for
        your shader or NULL or an empty string if no texture should be
        passed.
      </p>
      <p>
        If type is <tt>W_INTERFACE_SQUARE</tt>
        or <tt>W_INTERFACE_PERIMETER</tt>, then you must pass 4 more
        values which represent the interface color. These 4 values
        should be floating point numbers between 0.0 and 1.0 and they
        represent the color RGBA value.
      </p>
      <h5 id="resize_interface">void W.resize_interface(struct
        interface *i, float width, float height)</h5>
      <p>
        Resize an existing interface. It's width and height becames
        the value passed as argument in pixels.
      </p>
      <h5 id="rotate_interface">void W.rotate_interface(struct
        interface *i, float angle)</h5>
      <p>
        This function changes how the interface should be rotated
        comparing with it's original position. The second argument is
        the counter clockwise rotation angle in radians.
      </p>
      <h3 id="shader">Shaders</h3>
      <h4 id="shader_variables">Shader Variables</h4>
      <h5 id="final_shader_integer">int W.final_shader_integer</h5>
      <p>
        If you enable 2-pass rendering, where you first render your
        game to a texture, and then use a custom shader to render it
        in the screen
        using <a href="#change_final_shader">W.change_final_shader</a>,
        then you can set this variable to pass any integer you wish
        for this custom shader.
      </p>
      <p>
        Changes to this variable are always local to a main loop. When
        you enter in a main loop this variable is set to 0 again. And
        if you exit from a subloop, this variable recover the value it
        had before entering in the last subloop.
      </p>
      <h4 id="shader_functions">Shader Functions</h4>
      <h5 id="change_final_shader">void W.change_final_shader(int
        shader_id)</h5>
      <p>
        This function activate the 2-pass rendering, where you first
        render all your game to a texture, and then render it to the
        screen with a custom shader, whose id number you pass as
        argument for this function.
      </p>
      <p>
        Please, ensure that you pass the id of an existing shader for
        this function. Passing an invalid id number is a fatal error.
      </p>
      <p>
        When you change the final shader, the change is always local
        to the main loop where the function is invoked.
      </p>
      <h3 id="sound">Sound</h3>
      <h4 id="sound_records">Sound Records</h4>
      <h5 id="struct_sound">struct sound</h5>
      <p>
        This record stores information about sound effects in your
        game. Not long audio like music, but small sound effects which
        should be stored in memory for fast playing.
      </p>
      <p>
        A sound record is defined roughly as:
      </p>
      <pre class="codigo">
<span class="word">struct</span> <span class="tipo">sound</span>{
  <span class="tipo">unsigned long</span> size;
  <span class="tipo">int</span> channels, freq, bitrate;
  <span class="tipo">bool</span> loaded;
};</pre>
      <p>
        A new sound record is created by
        function <a href="#new_sound">W.new_sound</a> and can be
        destroyed by
        function <a href="#destroy_sound">W.destroy_sound</a> (but if
        you created a sound inside a main loop, you should let the
        garbage collector destroy the record).
      </p>
      <p>
        Every sound record has the following variables:
      </p>
      <h6>unsigned long size<img class="icon"
                 src="images/read_only.png" width="25px" height="25px"
                 title="Read-only"></h6>
      <p>
        The sound size in bytes.
      </p>
      <h6>int channels<img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only"></h6>
      <p>
        The number of channels. If the sound in monoaural (1), stereo
        (2) or have even more channels.
      </p>
      <h6>int freq<img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only"></h6>
      <p>
        The sampling frequency. Usually it's value is 44100, because
        it's the sampling frequency of Compact Disks.
      </p>
      <h6>int bitrate<img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only"></h6>
      <p>
        The bit rate, or the number of bits per second that should be
        converted to sound and played.
      </p>
      <h6>bool loaded<img class="icon" src="images/read_only.png" width="25px"
                 height="25px" title="Read-only"></h6>
      <p>
        If the sound was properly loaded or not. If this variable is
        false, it means that Weaver still is loading the sound
        asynchronously. Or the code which should load the sound
        asynchronously failed for some reason and the sound won't
        load. You can try to play the sound
        with <a href="#play_sound">W.play_sound</a>, but this function
        will fail silenly when asked to play a non-loaded sound.
      </p>
      <p>
        You can check the value of the
        variable <a href="#pending_files">W.pending_files</a> if you
        want to know if Weaver still is loading your files. If it's
        value is 0, it means that Weaver isn't loading any file and if
        your sound have the variable <tt>loaded</tt> set as false,
        then the loading failed.
      </p>
      <h4 id="sound_variables">Sound Variables</h4>
      <h5 id="number_of_sound_devices">int
        W.number_of_sound_devices<img class="icon"
        src="images/read_only.png" width="25px" height="25px"
        title="Read-only"></h5>
      <p>
        This variable holds the number of detected sound devices in
        your system. It's useful to know the size of the
        array <a href="#sound_device_name">W.sound_device_name</a> and
        to know which values you can pass to
        function <a href="#select_sound_device">W.select_sound_device</a>.
      </p>
      <h5 id="sound_device_name">char*
        W.sound_device_name[ ]<img class="icon"
        src="images/read_only.png" width="25px" height="25px"
        title="Read-only"></h5>
      <p>
        This is an array of strings with the name of each sound device
        detected in the system. The array
        has <a href="#number_of_sound_devices">W.number_of_sound_devices</a>
        elements and if you wish to choose one of them as the default
        sound device, pass it's position to the
        function <a href="#select_sound_device">W.select_sound_device</a>. If
        you want to know the position of the current sound device (if
        we can detect), call
        function <a href="#current_sound_device">W.current_sound_device</a>.
      </p>
      <p>
        If we didn't detect any sound device, this variabel is set as NULL.
      </p>
      <h4 id="sound_functions">Sound Functions</h4>
      <h5 id="current_sound_device">int
        W.current_sound_device(void)</h5>
      <p>
        This function identify if possible which sound device we are
        using in the
        list <a href="#sound_device_name">W.sound_device_name</a>. The
        function return the position of the sound device name in that
        list, or -1 if it isn't able to detect the current device.
      </p>
      <h5 id="destroy_sound">void W.destroy_sound(struct sound
        *snd)</h5>
      <p>
        This function frees the memory previously allocated
        by <a href="#new_sound">W.new_sound</a>. Usually you don't
        need to use this function because the garbage collector will
        free the memory when you exit the main loop where the sound
        was allocated. But if you allocated the sound outside a main
        loop, you need this function to avoid a memory leak.
      </p>
      <h5 id="get_volume">float W.get_volume(char *filename)</h5>
      <p>
        If the music file at <tt>music</tt> directory is loaded and
        playing or paused, this function returns it's volume as a
        floating pont number between 0 and 1. If the music isn't
        playing, it returns -1.0.
      </p>
      <h5 id="increase_volume">float W.get_volume(char *filename,
        float increment)</h5>
      <p>
        If the music found in the given filename at <tt>music</tt>
        directory is playing or is paused, this function increases its
        volume by the value passed as the second argument. the value
        can be negative if you want to lower the volume.
      </p>
      <p>
        If the function would change a volume to a value greater than
        1, it changes the value to 1 instead. If the function woulkd
        change a volume to a value lesser than 0, it changes to 0
        instead.
      </p>
      <p>
        The function returns the new volume after the change or
        returns -1.0 if the music wasn't loaded.
      </p>
      <h5 id="new_sound">struct sound *W.new_sound(char
        *filename)</h5>
      <p>
        This function opens a sound file in the <tt>sound/</tt>
        directory given it's filename. Then it parses and extract the
        file content as a <a href="#struct_sound">sound record</a>.
      </p>
      <p>
        Weaver can return from this function before finishing to
        extact the file. The engine prefers to extract files
        asynchronously in a thread if possible. You can check if a
        sound was really extracted checking it's
        variable <tt>loaded</tt>.
      </p>
      <p>
        Currently Weaver is able to extract WAVE and MP3 files.  If
        Weaver can't extract a sound file, it returns NULL.
      </p>
      <h5 id="pause_music">bool W.pause_music(char *filename)</h5>
      <p>
        Pauses the music which is being played and whose contents are
        being read from the file in the <tt>music</tt> directory whose
        name is passed as argument.
      </p>
      <p>
        The function returns if the operation was successful. If the
        given music wasn't loaded, doesn't exist or was already
        paused, the function returns false. Otherwise, it returns
        true.
      </p>
      <h5 id="play_music">bool W.play_music(char *filename, bool loop)</h5>
      <p>
        Start to play the music or sound effect in the filename passed
        as first argument inside the <tt>music</tt> directory. If the
        music is already loaded, but was paused
        (with <a href="#pause_music">W.pause_music</a>), the music
        resumes playing. The second argument defines if the music
        should loop after it ends.
      </p>
      <p>
        Currently Weaver can only play music encoded as MP3.
      </p>
      <p>
        If Weaver can't play the music (or it's already playing), the
        function returns false. Otherwise, it returns true.
      </p>
      <h5 id="play_sound">bool W.play_sound(struct sound *snd)</h5>
      <p>
        Play a sound created by <a href="#new_sound">W.new_sound</a>
        and then returns if it was possible to play the sound. If the
        sound was already playing, if we are already playing the
        maximum number of music (defined by
        macro <a href="configuration.htm#W_HEIGHT">W_MAX_MUSIC</a>),
        or if the file was not found this function returns
        false. Otherwise, it returns true.
      </p>
      <h5 id="select_sound_device">bool W.select_sound_device(int
        id)</h5>
      <p>
        This function selects a detected sound device to play our
        audio. You should pass for this function the position of the
        chosen audio in the
        array <a href="#sound_device_name">W.sound_device_name</a>.
      </p>
      <p>
        If you pass an invalid number or this function fails for some
        other reason, it returns false.
      </p>
      <h5 id="stop_music">bool W.stop_music(char *filename)</h5>
      <p>
        Stops playing a music identified by the filename passed as
        argument and inside the <tt>music</tt> directory. The music is
        also unloaded from memory and a different music can be played
        in its place.
      </p>
      <p>
        The function returns if the operation was successful. If the
        music doesn' exist, or it wasn't loaded, it returns
        false. Otherwise, it returns true.
      </p>
      <h3 id="data">Data</h3>
      <p>
        Here you will find functions created to store, read and delete
        data which should be preserved, even after your program
        ends. If the game is running natively, the data is stored
        using Sqlite3. If the game is running in a web browser with
        Web Assembly, the data is stored in cookies with a very long
        expiration date.
      </p>
      <h4 id="data_functions">Data Functions</h4>
      <h5 id="delete_all">void W.delete_all(void)</h5>
      <p>
        This function erases all saved data in your game. Anything
        stored with <a href="#write_float">W.write_float</a>,
        <a href="#write_integer">W.write_integer</a> or
        <a href="#write_string">W.write_string</a> will be erased.
      </p>
      <h5 id="delete_float">void W.delete_float(char *name)</h5>
      <p>
        This function erases the saved data stored as a floating point
        number with <a href="#write_float">W.write_float</a> and
        identified by the name passed as argument. If the data doesn't
        exist, this function doesn't nothing.
      </p>
      <h5 id="delete_integer">void W.delete_integer(char *name)</h5>
      <p>
        This function erases the saved data stored as an integer
        number with <a href="#write_integer">W.write_integer</a> and
        identified by the name passed as argument. If the data doesn't
        exist, this function doesn't nothing.
      </p>
      <h5 id="delete_string">void W.delete_string(char *name)</h5>
      <p>
        This function erases the saved data stored as a string
        with <a href="#write_string">W.write_string</a> and identified
        by the name passed as argument. If the data doesn't exist,
        this function doesn't nothing.
      </p>
      <h5 id="read_float">bool W.read_float(char *name, float
        *value)</h5>
      <p>
        This functions reads a floating point number stored in the
        past with <a href="#write_float">W.write_float</a> function
        and identified with the name passed as the first argument. If
        the number is found, it's stored in the pointer passed as
        second argument and the function returns true. Otherwise, the
        second argument is ignored and the function returns false.
      </p>
      <h5 id="read_integer">bool W.read_integer(char *name, int
        *value)</h5>
      <p>
        This functions reads an integer number stored in the past
        with <a href="#write_integer">W.write_integer</a> function and
        identified with the name passed as the first argument. If the
        number is found, it's stored in the pointer passed as second
        argument and the function returns true. Otherwise, the second
        argument is ignored and the function returns false.
      </p>
      <h5 id="read_string">bool W.read_string(char *name, char
        *value, int n)</h5>
      <p>
        This functions reads the string stored in the past
        with <a href="#write_integer">W.write_string</a> function and
        identified with the name passed as the first argument. If the
        string is found, it's copied in the array passed as second
        argument, but not more than <tt>n</tt> bytes are copied and
        the function returns true. Otherwise, the second argument is
        ignored and the function returns false.
      </p>
      <h5 id="write_float">void W.write_float(char *name, float
        value)</h5>
      <p>
        This function stores a floating point number and identifies it
        with the name passed as argument. The value is preserved even
        after the program exits. The value can be overwritten calling
        this function again passing the same name as argument. If you
        want to delete the number and it's identifier,
        call <a href="#delete_float">W.delete_float</a>.
      </p>
      <h5 id="write_integer">void W.write_integer(char *name, int
        value)</h5>
      <p>
        This function stores an integer number and identifies it with
        the name passed as argument. The value is preserved even after
        the program exits. The value can be overwritten calling this
        function again passing the same name as argument. If you want
        to delete the number and it's identifier,
        call <a href="#delete_integer">W.delete_integer</a>.
      </p>
      <h5 id="write_string">void W.write_string(char *name, char
        *value)</h5>
      <p>
        This function stores a string and identifies it with the name
        passed as argument. The value is preserved even after the
        program exits. The value can be overwritten calling this
        function again passing the same name as argument. If you want
        to delete the string and it's identifier,
        call <a href="#delete_string">W.delete_string</a>.
      </p>
    </div>
  </body>
</html>
