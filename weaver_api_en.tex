\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{The Weaver API}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article describes using literary programming the
  Weaver API. Weaver is a game engine and this API are how programmers
  interact with the engine in their game projects. Besides the API,
  this article also covers how the configuration file is interpreted
  and how game loops should be managed in a game project. The API is
  portable code which should work under OpenBSD, Linux, Windows and
  Web Assembly environments.}

\secao{1. Introduction}

\subsecao{1.1. File Organization}

When a user types \monoespaco{weaver PROJECT} at command line, a
directory with a new Weaver project is created. Inside the directory,
the file with the main loop is in \monoespaco{src/game.c} and inside
them we find:

\linha
\alinhaverbatim
#include "game.h"

void main_loop(void){ // The game main loop
 LOOP_INIT: // Initialization code 

 LOOP_BODY: // Code executed each iteration
    if(W.keyboard[W_ANY])
        Wexit_loop();
 LOOP_END: // Code executed at finalization
    return;
}

int main(void){
  Winit(); // Initializes Weaver
  Wloop(main_loop); // Enter a new game loop
  return 0;
}
\alinhanormal
\linha

And inside \monoespaco{src/game.h}, we find:

\linha
\alinhaverbatim
#ifndef _game_h_
#define _game_h_

#include "weaver/weaver.h"
#include "includes.h"

struct _game_struct{
  // You can customise this structure declaring variables here.
  // But don't change it's name. And access it by its pointer: W.game
  int whatever; // <- This variable is here to prevent compiler errors
} _game;

void main_loop(void);

#endif
\alinhanormal
\linha

In this file there's an struct which can be customized by the user and
which is where variables with global states should be declared. The
variables declared here are also variables which will be saved in a
player's save file and which will be sent over a network to inform
clients about the game state. This struct should be referenced by the
variable \monoespaco{W.game}. This also gives us information that the
API will be organized in a way that will exist a \monoespaco{struct}
called \monoespaco{W} where the API resources will be centralized.

The file \monoespaco{includes.h} is just a header which includes in
the project all the other headers of modules created by the user (each
module is a C source file and a header).

All the API code shall be present or be included by macros in the
files \monoespaco{weaver.c} and \monoespaco{weaver.h}. The
\monoespaco{weaver.h} organization is:

\iniciocodigo
@(project/src/weaver/weaver.h@>=
#ifndef _weaver_h_
#define _weaver_h_
#ifdef __cplusplus
  extern "C" {
#endif
#include "../../conf/conf.h"
@<Global Structure@>
@<Weaver Headers@>
@<Weaver Macros@>
#ifdef __cplusplus
  }
#endif
#endif
@
\fimcodigo

We include in the header the configuration file \monoespaco{conf.h}
responsible to control the settings of our engine.

\subsecao{1.2. The W Structure}

The global structure referenced in the previous code is a
\monoespaco{struct} called \monoespaco{W}. We already mentioned it
in the code comments that the
\monoespaco{struct \_game\_struct \_game} definded in
\monoespaco{game.h}. Now we can start to define this structure:

\iniciocodigo
@<Global Structure@>=
// This structure will contain all the variables and functions defined at
// Weaver API:
extern struct _weaver_struct{
  struct _game_struct *game;
  @<Weaver Variables@>
  //@<Weaver Functions@>
} W;
@
\fimcodigo

Besides \monoespaco{W.game}, there will be other variables in this
structure. We basically will centralize all the public functions of
our API here. Only private functions whose names starts with ``\_''
and some initialization and finalization functions won't be inside
the \monoespaco{W} structure. In this way we prevent the pollution of
the global namespace.

We will also define here the general structure of
our \monoespaco{weaver.c} file:

\iniciocodigo
@(project/src/weaver/weaver.c@>=
#include "weaver.h"
#include "../game.h"
@<Weaver API: Definitions@>
@<Weaver API: Functions@>
@<Weaver API: Base@>
@
\fimcodigo

In ``Weaver API: Definitions'' we will declare new kind of structures.
The first thing will be the \monoespaco{W} structure, which we already
declared in the header:

\iniciocodigo
@<Weaver API: Definitions@>=
struct _weaver_struct W;
@
\fimcodigo

In ``Weaver API: Functions'' we will put almost all our
functions. Except some base functions which can't or shouldn't be put
inside the \monoespaco{W} structure, like initialization and
finalization functions.

\subsecao{1.3. Initialization and Finalization Functions}

One thing that the initialization function must do is initialize the
values inside the  \monoespaco{W} structure:

\iniciocodigo
@<Weaver Headers@>=
void Winit(void);
@
\fimcodigo

\iniciocodigo
@<Weaver API: Base@>=
void Winit(void){
  W.game = &_game;
  @<Weaver API: Initialization@>
}
@
\fimcodigo

The finalization function shall deallocate any pending memory, end
resource usage and close the program informing if everything happened
as expected:

\iniciocodigo
@<Weaver Headers@>=
void Wexit(void);
@
\fimcodigo

\iniciocodigo
@<Weaver API: Base@>=
void Wexit(void){
  //@<Weaver API: Finalization@>
  exit(0);
}
@
\fimcodigo

The \monoespaco{exit} function requires the inclusion of the standard
header:

\iniciocodigo
@<Weaver Headers@>=
#include <stdlib.h>
@
\fimcodigo

The rest of the code executed in initialization and finalization will
be described along the article.

\secao{2. Time Counting}

Weaver measeures elapsed time in microseconds ($10^{-6}$s) and stores
the time counting in at least 64 bits of memory. Besides the total
elapsed time since the program initialization, we also store the time
difference between the current iteration in the main loop and the
previous one.

First we neet a place to store our last time measure and we use a
global variable. In Windows we use a specific type to store large
integers (\monoespaco{LARGE\_INTEGER}) and in other systems we use a
\monoespaco{timeval} structure to store the time measure at high
resolution.


\iniciocodigo
@<Weaver Headers@>=
#if defined(_WIN32)
#include <windows.h>
LARGE_INTEGER _last_time;
#else
#include <sys/time.h>
struct timeval _last_time;
#endif
@
\fimcodigo

The idea is store in this variable always the last time measure. It's
initialized with our first time measure at initialization:

\iniciocodigo
@<Weaver API: Initialization@>=
#if defined(_WIN32)
QueryPerformanceCounter(&_last_time);
#else
gettimeofday(&_last_time, NULL);
#endif
@
\fimcodigo

After initialization, all other updates in this variable will happen
using the following declared function:

\iniciocodigo
@<Weaver Headers@>+=
unsigned long _update_time(void);
@
\fimcodigo

This function will read thecurrent time and store the variable. It
will always return the difference in microseconds between the last two
measures. In Unix systems we compute the time difference using the
method recommended in the GNU C Library manual. This subtraction
method is more portable and works even if the \monoespaco{timeval}
elements are stored as ``unsigned''. The disadvantage is that the code
is less clear and intuitive. The code is:


\iniciocodigo
@<Weaver API: Definitions@>=
#if !defined(_WIN32)
unsigned long _update_time(void){
  int nsec;
  unsigned long result;
  struct timeval _current_time;
  gettimeofday(&_current_time, NULL);
  // Performing the carry:
  if(_current_time.tv_usec < _last_time.tv_usec){
    nsec = (_last_time.tv_usec - _current_time.tv_usec) / 1000000 + 1;
    _last_time.tv_usec -= 1000000 * nsec;
    _last_time.tv_sec += nsec;
  }
  if(_current_time.tv_usec - _last_time.tv_usec > 1000000){
    nsec = (_current_time.tv_usec - _last_time.tv_usec) / 1000000;
    _last_time.tv_usec += 1000000 * nsec;
    _last_time.tv_sec -= nsec;
  }
  if(_current_time.tv_sec < _last_time.tv_sec){
    // Overflow
    result = (_current_time.tv_sec - _last_time.tv_sec) * (-1000000);
    // This is always positive:
    result += (_current_time.tv_usec - _last_time.tv_usec);
  }
  else{
    result = (_current_time.tv_sec - _last_time.tv_sec) * 1000000;
    result += (_current_time.tv_usec - _last_time.tv_usec);
  }
  _last_time.tv_sec = _current_time.tv_sec;
  _last_time.tv_usec = _current_time.tv_usec;
  return result;
}
#endif
@
\fimcodigo

At Windows systems, there's already a function that measure time in
microseconds. So the function becames much simpler:

\iniciocodigo
@<Weaver API: Definitions@>=
#if defined(_WIN32)
unsigned long _update_time(void){
  LARGE_INTEGER prev;
  prev.QuadPart = _last_time.QuadPart;
  QueryPerformanceCounter(&_last_time);
  return (_last_time.QuadPart - prev.QuadPart);
}
#endif
@
\fimcodigo

\secao{3. The main loops.}

All games are organized inside main loops. They are code which
iterates indefinitelly until some condition send the program for
another main loop or terminate the program.

As shown in the initial code at \monoespaco{game.c}, a main loop
should be declared as:

\alinhaverbatim
void nome\_do\_loop(void){
 LOOP\_INIT: // Código executado na inicialização

 LOOP\_BODY: // Código executado a cada iteração
    if(W.keyboard[W\_ANY])
        Wexit\_loop();
 LOOP\_END: // Código executado na finalização
    return;
}
\alinhanormal

Before understanding how we should enter correctly in a main loop,
it's important to describe how the loop is executed. Note that it has
an initialization section, an execution section and a finalization
section. These sections are delimited by labels in upper case.

Interpreting this is very simple. You can see the code above as:

\alinhaverbatim
void nome\_do\_loop(void){
  // LOOP\_INIT
  for(;;){
    // LOOP\_BODY
    if(W.keyboard[W\_ANY])
        Wexit\_loop();
  }
  // LOOP\_END
}
\alinhanormal

While this interpretation is suitable in some contexts, this is not
how the main loop code is translated. We can't run an infinite loop in
all environments without blocking tha game interface. In Web Assembly
environments, a game loop can be executed only if they are correctly
declared as such and these functions shouldn't have an infinite loop,
instead they are called successively.

Because of such differences, to create more portable code, we should
interpret a main loop execution as:

\alinhaverbatim
for(;;)
  nome\_do\_loop();
\alinhanormal

Inside the main loop function, we don't put an explicit loop. Instead,
we decide which section of the function we should execute with the
help of the labels inserted. Such labels are in fact macros with
aditional logic inside and with some \monoespaco{goto} to decide which
section should be executed.

Because of this, we can't declare variables in a main loop
initialization. If so, they would have the correct value only during
the first iteration, not in the others. For example, the following
code would have an undefinded result and perhaps it wouldn't print
anything in the screen:

\alinhaverbatim
// WRONG
void loop(void){
LOOP\_INIT:
  int var = 5;
LOOP\_BODY:
  if(var == 5)
    printf("var == 5\\n");
LOOP\_END:
}
\alinhanormal

But the following code is correct and print in the screen in all
iterations because the variable is declared outside the function:

\alinhaverbatim
// CORRECT
static int var;

void loop(void){
LOOP\_INIT:
  var = 5;
LOOP\_BODY:
  if(var == 5)
    printf("var == 5\\n");
LOOP\_END:
}
\alinhanormal

Other thing that should be considered is that in fact there's not just
one main loop being executed in a given moment, but two of them. One
of the loops execute in a fixed frequency: the loop handling physics
and game logic. The other main loop runs as fast as it: the loop
rendering graphics in the screen.

Ideally in each physics and logic loop iteration, we execute one or
more iterations of rendering loop. It means that we can render with a
frequency greater than we move objects, detect collisions and read
user input. And in each of the rendering loop iteration, we need to
render different images, otherwise there's no point in running this
loop faster than the physics loop. So in the rendering loop we also
interpolate the objects positions, knowing their current speed,
acceleration and position.

And ensuring that our game physics and logic runs always in a fixed
interval, we ensure the necessary determinism for synchronizing games
in networks like the Internet. And at same time, rendering as fast as
we can with interpolation gives us a more pleasant and natural
experience.

For more details of how to implement thism you can check [Fiedler
2004]. Our implementation swill be like in this reference, except that
our code will be much less explicit because it will be hiden by macros
without explicit loops.

Let's define in the following subsections what exactly we will put in
the macros present in every main loop.

\subsecao{3.1. Loop Initialization.}

This is what the macro \monoespaco{LOOP\_INIT} does:

First it checks variables to determine if we should finish the
loop. If so, but we still have resources being loaded (images, videos,
shaders, sounds), we just return from the function. If we have nothing
being loaded but we still didn't executed the finalization section, we
use \monoespaco{goto} and go to the finalization section. If there's
nothing being loaded and we already ran the finalization, we finally
stop the loop.

If we don't need to finish the loop, but this function is being called
for the first time, we just continue the execution. Otherwise, we use
a \monoespaco{goto} to avoid executing more than once the
initialization section. Finally, if we are still here, it's because we
are running the function for the first time. So we make the variable
|W.loop_name| represents a string with the name of current main loop.

How do we know if we should keep executing the loop? We use a global
variable. As there's only one main loop, we don't need to protect it
with semaphores. The same can be done to know if we are executing a
main loop for the first time, if we are in the beginning of a loop of
if we already executed the finalization. Let's declare the variables:

\iniciocodigo
@<Weaver Headers@>+=
#include <stdbool.h>
bool _running_loop, _loop_begin, _loop_finalized;
@
\fimcodigo

And let's initialize them:

\iniciocodigo
@<Weaver API: Initialization@>+=
_running_loop = false;
_loop_begin = false;
_loop_finalized = false;
@
\fimcodigo

Know if we are still loading resources (usually reading files) or the
name of the current loop is useful not only for the engine's internal
logic, but also for the user. Knowing if we are still loading files
permits showing a loading screen. Knowing the current loop name is
useful for debugging and for loading different resources depending of
the loop. Because of this, both variables shall be declared in |W|
structure. The maximum loop name which we can store can be setted with
the macro \monoespaco{W\_MAX\_LOOP\_NAME}.

\iniciocodigo
@<Weaver Variables@>+=
// Inside W structure:
#if !defined(W_MAX_LOOP_NAME)
#define W_MAX_LOOP_NAME 64
#endif
unsigned pending_files;
char loop_name[W_MAX_LOOP_NAME];
@
\fimcodigo

During initialization we set these variables as 0 and |NULL|
respectivelly:

\iniciocodigo
@<Weaver API: Initialization@>+=
W.pending_files = 0;
W.loop_name[0] = '\0';
@
\fimcodigo

The function which exits the loop is:


\iniciocodigo
@<Weaver Headers@>+=
#if !defined(_MSC_VER)
void _exit_loop(void) __attribute__ ((noreturn));
#else
__declspec(noreturn) void _exit_loop(void);
#endif
@
\fimcodigo

But we still won't define it. By the header, this is a function which
never returns, specified as such in the above code using notation from
GCC and Clang and from Visual Studio. It's so because when it exists,
it just calls previous main loop which never returns, or it just
exists the program, depending of the case.

After desscribing thism we can finally define the loop initialization
macro:

\iniciocodigo
@<Weaver Headers@>+=
#define LOOP_INIT                                                   \
  if(!_running_loop){                                               \
    if(W.pending_files)                                             \
      return;                                                       \
    if(!_loop_finalized){                                           \
      _loop_finalized = true;                                       \
      goto _LOOP_FINALIZATION;                                      \
    }                                                              \
    _exit_loop();                                                   \
  }                                                                 \
  if(!_loop_begin)                                                   \
    goto _END_LOOP_INITIALIZATION;                                   \
  snprintf(W.loop_name, W_MAX_LOOP_NAME, "%s", __func__);            \
  _BEGIN_LOOP_INITIALIZATION
@
\fimcodigo

We end with th identifier \monoespaco{\_BEGIN\_LOOP\_INITIALIZATION},
which is the true label name from this macro (remember, this macro is
always invoked as ``\monoespaco{LOOP\_INIT:}'' with ``:'' )  .

\subsecao{3.2. Loop Body.}    
     
This is what the macro \monoespaco{LOOP\_BODY} does:

When we are in this macro, we shall set as false the information that
this is our first loop execution avoiding to re-execute the
initialization again. Then, we put an \monoespac{goto} after
a \monoespaco{if} which never will be executed. This is done just so
we can use the label \monoespaco{\_BEGIN\_LOOP\_INITIALIZATION} with
no compiler warnings of unused label. We mark with the
label \monoespaco{\_END\_LOOP\_INITIALIZATION} the real beginning of
our loop body. We then measure the elapsed time since the last loop
and store in an accumulator. If this accumulator holds a value bigger
than the time expected between execution of physics code and logic
code, we execute thee code. Otherwise, we just ignore these code and
jump for finalization where we just render in the screen. If a lot of
time passed since last loop execution, we could run more than once
this loop body code.

The accumulator which determines if we should run physics code or
logic code will be called \monoespaco{\_lag}. It is a global variable:

\iniciocodigo
@<Weaver Headers@>+=
unsigned long _lag;
@
\fimcodigo

This is ts initialization:

@<Weaver API: Initialization@>+=
_lag = 0;
@

We need some variables which could be read by an user with information
about time. One of them (\monoespaco{W.t}) will store the elapsed
microseconds since the game initialization. Another one
(\monoespaco{W.dt}) will hold the interval between executions of our
physics engine and game logic. Both variables needs to be declared
inside \monoespaco{W} struct:

\iniciocodigo
@<Weaver Variables@>+=
unsigned long long t;
unsigned long dt;
@
\fimcodigo

The first variable obviously shall be initialized as zero.  The second
one shall be initialized with the same value than
macro \monoespaco{W\_TIMESTEP}, which could be defined by the user to
cntrol the granularity of code execution in physics and logic. If this
macro is not defined, we assume 40000 microsecons. This ensures a
frequency of 25 Hz for the execution of physics engine.

\iniciocodigo
@<Weaver API: Initialization@>+=
#if !defined(W_TIMESTEP)
#define W_TIMESTEP 40000
#endif
W.dt = W_TIMESTEP;
W.t = 0;
@
\fimcodigo

The code of physics engine and internal logic shall be encapsuled in a
function called \monoespaco{\_update}:

\iniciocodigo
@<Weaver Headers@>+=
void _update(void);
@
\fimcodigo

We won't at this moment define the code in this function:

\iniciocodigo
@<Weaver API: Base@>+=
void _update(void){
  @<Código a executar todo loop@>
}
@
\fimcodigo

With all these definitions, we already can define our macro which
marks the beginning of the main loop:

\iniciocodigo
@<Weaver Headers@>+=
#define LOOP_BODY                                            \
  _loop_begin =  false;                                      \
  if(_loop_begin)                                            \
    goto _BEGIN_LOOP_INITIALIZATION;                         \
_END_LOOP_INITIALIZATION:                                    \
  _lag += _update_time();                                    \
  while(_lag >= W.dt){                                       \
    _update();                                               \
_LABEL_0
@
\fimcodigo

Notice that the previous macro opens a \monoespaco{while} loop, but
don't close it. It should be closed by the code inserter by our macro
which delimits the end of loop body. This macro also should decrement
the variable \monoespaco{\_lag} to prevent an infinite loop.

\subsecao{3.3. Loop Finalization.}

This is what our macro \monoespaco{LOOP\_END} will do:

First to ensure that the loop from last macro ends, we decrement from
\monoespaco{\_lag} the value of \monoespaco{W.dt}. Next we increment
\monoespaco{W.t} with that ammount of microseconds. And next we end
the block of the loop. Outside the loop we keep doing activities not
related with the physics engine and game logic. As these activities
are tipically about rendering, we put them in a function called 
\monoespaco{\_render}. Next we return. After the return we put a
\monoespaco{goto} to a label which never will be executed to protect us
from compiler warnings. Finally, we put a label signaling the
beginning of finalization.

The only new thing here is the rendering function:

\iniciocodigo
@<Weaver Headers@>+=
void _render(void);
@
\fimcodigo

For now we are not defining the code inside this function:

\iniciocodigo
@<Weaver API: Base@>+=
void _render(void){
  @<Código de renderização@>
}
@
\fimcodigo

And now we define the macro code:

\iniciocodigo
@<Weaver Headers@>+=
#define LOOP_END                                           \
    _lag -=  40000;                                        \
    W.t +=  40000;                                         \
  }                                                        \
  _render();                                               \
  return;                                                  \
  goto _LABEL_0;                                           \
_LOOP_FINALIZATION
@
\fimcodigo

\subsecao{3.4. Entering in a main loop.}

Frequantemente estaremos trocando de laços principais ao longo de um
jogo. Mas nem sempre isso significa uma substituição completa. Alguns
laços principais ocorrem dentro de outros laços principais. Por
exemplo, quando acessamos um menu de configurações durante um jogo. Ou
quando em um RPG clássico por turnos mudamos para o modo de combate
após um encontro aleatório.

Podemos então formar uma pilha de laços principais, onde ao sairmos do
último laço voltamos para o que está empilhado imediatamente abaixo
dele ao invés de sairmos do jogo.

Sendo assim, existem duas formas de entrar em um laço principal. Uma
delas, por meio da função que definiremos chamada \monoespaco{Wloop} e
a segunda por meio da \monoespaco{Wsubloop}. A primeira envolve
substituirmos o laço principal atual por um novo. A segunda enolve
apenas criar um laço principal dentro do laço atual. A primeira é algo
que só poderemos fazer se não houverem arquivos pendentes sendo
carregados (possivelmente haverá uma tela de carregamento neste
caso). Por isso apenas nos asseguramos disso por mieo de um truque com
macros:

\iniciocodigo
@<Weaver Headers@>+=
#if !defined(_MSC_VER)
void _Wloop(void (*f)(void)) __attribute__ ((noreturn));
void Wsubloop(void (*f)(void)) __attribute__ ((noreturn));
#else
__declspec(noreturn) void _Wloop(void (*f)(void));
__declspec(noreturn) void Wsubloop(void (*f)(void));
#endif
#define Wloop(a) ((W.pending_files)?(false):(_Wloop(a)))
@
\fimcodigo

Nenhum dos dois tipos de função irá retornar jamais. Então
especificamos isso tanto na convenção de compiladores como Clang e GCC
como na do Visual Studio.

Vamos precisar de uma pilha de laços principais, que representaremos
por meio de uma sequência de ponteiros para funções. Essa nossa
sequência será um vetor com \monoespaco{W\_MAX\_SUBLOOP}
posições. Esta macro poderá ser controlada pelo usuário, mas se não
estiver definida, assumiremos que será 3. Além da pilha, vamos
precisar de uma variável para nos informar em qual profundidade da
pilha estamos no momento (\monoespaco{\_number\_of\_loops}).

A declaração destas duas variáveis será:

\iniciocodigo
@<Weaver Headers@>+=
#if !defined(W_MAX_SUBLOOP)
#define W_MAX_SUBLOOP 3
#endif
int _number_of_loops;
void (*_loop_stack[W_MAX_SUBLOOP]) (void);
@
\fimcodigo

E inicializamos a contagem do número de laços como zero:

\iniciocodigo
@<Weaver API: Initialization@>+=
_number_of_loops = 0;
@
\fimcodigo

Entrar em um novo laço principal por meio de \monoespaco{Wloop}
envolve verificar se já estamos antes em um laço. Se for o caso,
cancelamos ele. Em seguida, carregamos o novo laço para a pilha e
ajustamos o valor da contagem de laços em execução. Atualizamos o
nosso valor de contagem de tempo e finalmente executamos o laço. Em
ambiente Web Assembly em navegador de Internet isso envolve chamar
diretamente uma função que estabelece nossa função escolhida como laço
principal. Nos demais, basta executar a função em
um \monoespaco{while} comum:

\iniciocodigo
@<Weaver API: Base@>+=
void _Wloop(void (*f)(void)){
  if(_number_of_loops > 0){
    @<Cancela Loop Principal@>
    _number_of_loops --;
  }
  @<Código antes de Loop e Subloop@>
  @<Código andes de Loop, não de Subloop@>
  _loop_stack[_number_of_loops] = f;
  _number_of_loops ++;
#if defined(__EMSCRIPTEN__)
  emscripten_set_main_loop(f, 0, 1);
#else
  while(1)
    f();
#endif
}
@
\fimcodigo

Cancelar um laço principal já existente envolve caso estejamos
executando em ambiente Web Assembly invocar a função que interrompe o
laço atual:

\iniciocodigo
@<Cancela Loop Principal@>=
#if defined(__EMSCRIPTEN__)
emscripten_cancel_main_loop();
#endif
@
\fimcodigo

Iniciar um novo subloop, ou sublaço, é bastante semelhante. Mas
tratamos de maneira diferente o nosso contador de laços, já que ele
realmente precisa ser incrementado. E também temos que checar se
tivemos um estouro na nossa pilha de laços:

\iniciocodigo
@<Weaver API: Definitions@>+=
void Wsubloop(void (*f)(void)){
#if defined(__EMSCRIPTEN__)
    emscripten_cancel_main_loop();
#endif
  @<Código antes de Loop e Subloop@>
  @<Código andes de Subloop, não de Loop@>
  if(_number_of_loops >= W_MAX_SUBLOOP){
    fprintf(stderr, "Error: Max number of subloops achieved.\n");
    fprintf(stderr, "Please, increase W_MAX_SUBLOOP in conf/conf.h"
            " to a value bigger than %d.\n", W_MAX_SUBLOOP);
    exit(1);
  }
  _loop_stack[_number_of_loops] = f;
  _number_of_loops ++;
#if defined(__EMSCRIPTEN__)
  emscripten_set_main_loop(f, 0, 1);
#else
  while(1)
    f();
#endif
}
@
\fimcodigo

Vamos incluir o cabçalho para podermos imprimir mensagens de erro:

@<Weaver Headers@>+=
#include <stdio.h>
@

Uma coisa que faremos tanto antes de um laço como de um sublaço é
atualizar a variável \monoespaco{\_running\_loop} que avisa ao motor
que realmente estamos executando um laço ao invés de tentar sair dele,
ajustamos a variável que diz que estamos entrando no começo de um laço
e que portanto precisaremos executar o código de inicialização, a
variável que informa que a finalização do laço ainda não foi executada
e também atualizamos nosso contador de tempo:

\iniciocodigo
@<Código antes de Loop e Subloop@>=
_running_loop = true;
_loop_begin = true;
_loop_finalized = false;
_update_time();
@
\fimcodigo

\subsecao{3.4. Saindo do Laço Principal.}

Assim como existem duas funções para entrar em laços prinicpais,
existitão duas funções para sair. Uma delas apenas sai do laço
prinicpal atual, voltando para o próximo laço principal da pilha se
existit. A outra sai de todos os laços existentes e encerra o
programa.

A que sai de todos os laços já foi parcialmetne definida e é
a \monoespaco{Wexit}.

Sair de um laço atual já existente envolve ajustar a variável global
que diz que estamos executando o laço para um valor que significa que
queremos sair do laço:

\iniciocodigo
@<Weaver Headers@>+=
#define Wexit_loop() (_running_loop = false)
@
\fimcodigo

Se você verificar novamente o código inserido pelas macros presentes
em laços principais, verá que se esta variável for falsa e não existir
nenhum recurso ou arquivo ainda sendo carregado, então será chamada a
função \monoespaco{\_exit\_loop}:

\iniciocodigo
@<Weaver Headers@>+=
#if !defined(_MSC_VER)
void _exit_loop(void) __attribute__ ((noreturn));
#else
__declspec(noreturn) void _exit_loop(void);
#endif
@
\fimcodigo

Já o código desta função envolve cancelar o laço atual e checar se
existe outro na pilha. Se não existir, o programa se encerra. Se
existir, executa código de entrada no novo laço:

\iniciocodigo
@<Weaver API: Definitions@>+=
void _exit_loop(void){
  if(_number_of_loops <= 1){
    Wexit();
    exit(1); // Esta linha apenas previne aviso na compilação
  }
  else{
    @<Código após sairmos de Subloop@>
    _number_of_loops --;
    @<Código antes de Loop e Subloop@>
#if defined(__EMSCRIPTEN__)
    emscripten_cancel_main_loop();
    emscripten_set_main_loop(_loop_stack[_number_of_loops - 1], 0, 1);
#else
    while(1)
      _loop_stack[_number_of_loops - 1]();
#endif
  }
}
@
\fimcodigo

\secao{Definições Vazias}

As seguintes definições ainda estão em branco e estão aqui para manter
o projeto compilando com sucesso. Esta parte não existirá na versão
final deste documento e as partes que aparecem aqui vazias estarão
posteriormente preenchidas e melhor explicadas.

\iniciocodigo
@<Código andes de Subloop, não de Loop@>=
@
\fimcodigo

\iniciocodigo
@<Código após sairmos de Subloop@>=
@
\fimcodigo

\iniciocodigo
@<Weaver API: Functions@>=
@
\fimcodigo

\iniciocodigo
@<Código a executar todo loop@>=
@
\fimcodigo

\iniciocodigo
@<Código de renderização@>=
@
\fimcodigo

\iniciocodigo
@<Código andes de Loop, não de Subloop@>=
@
\fimcodigo

\iniciocodigo
@<Weaver Macros@>=
@
\fimcodigo


\secao{Referências}

\referencia{Fiedler, G. (2004) ``Fix Your Timestep!'', acessado em
\monoespaco{https://gafferongames. com/post/fix\_your\_timestep/}
em 2020.}


\fim
